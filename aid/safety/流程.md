# 采购模块数据流程深度审计 V2

> **Purpose**: 此文件是采购模块核心业务逻辑的 **深度审计记录**。它比代码更直观地阐述了 PO -> Send -> Receive -> Diff 的完整数据流转、表写入顺序和事务逻辑。
> **AI Attention**: 这是理解 Purchase 模块业务逻辑的 **最高优先级文档**。在修改任何采购、发货、入库代码前，**必须** 先理解此文档中的逻辑，尤其是 History/Final 表的同步机制。
> **Constraints**: `HARD` - 业务逻辑修改不得违反此文档描述的数据流一致性。
> **Related Files**: 
> - `aid/system/数据库表.md`: 具体的表结构定义。
> - `aid/system/文件存储规范.md`: 流程中产生文件的存储位置。



> **审计日期**: 2026-01-09
> **审计状态**: 100% 完整理解
> **审计范围**: 采购→发货→入库→差异 完整流程

---

## 一、表结构概览

### 1.1 订单模块 (PO)

| 表名 | 类型 | 主要字段 | 唯一Key |
|------|------|----------|---------|
| `in_po` | 日志表 | update_date, supplier_code, po_num, po_sku, po_quantity, po_price, currency, usd_rmb, by, action, note, seq | (po_num, po_sku, po_price, seq) |
| `in_po_final` | 快照表 | po_date, po_update_date, po_num, po_sku, po_quantity, po_price, po_note, po_seq, po_by | (po_num, po_sku, po_price) |
| `in_po_strategy` | 策略表 | date, po_num, cur_currency, cur_usd_rmb, cur_float, cur_ex_float, cur_deposit, cur_deposit_par, by, note, seq | (po_num, seq) |

**关键**: 同一 `(po_num, po_sku)` 可有多个 `po_price`，形成不同的库存批次。

### 1.2 发货模块 (Send)

| 表名 | 类型 | 主要字段 | 唯一Key |
|------|------|----------|---------|
| `in_send` | 主表 | date_sent, logistic_num, price_kg, total_weight, total_price, usd_rmb, mode, date_eta, pallets, note, date_record, by, seq | (logistic_num, seq) |
| `in_send_list` | 日志表 | date, logistic_num, po_num, sku, quantity, price, action, note, by, po_change, seq | (logistic_num, po_num, sku, price, seq) |
| `in_send_final` | 快照表 | sent_date, sent_update_date, sent_logistic_num, po_num, po_sku, sent_quantity, po_price, sent_note, sent_seq, sent_by | (sent_logistic_num, po_num, po_sku, po_price) |

### 1.3 入库模块 (Receive)

| 表名 | 类型 | 主要字段 | 唯一Key |
|------|------|----------|---------|
| `in_receive` | 日志表 | sent_date, eta_date_final, receive_date, update_date, logistic_num, po_num, po_sku, sent_quantity, receive_quantity, po_price, action, note, seq, by | (logistic_num, po_num, po_sku, po_price, seq) |
| `in_receive_final` | 快照表 | eta_date_final, receive_date, update_date, logistic_num, po_num, po_sku, sent_quantity, receive_quantity, po_price, note, seq, by | (logistic_num, po_num, po_sku, po_price) |

### 1.4 差异模块 (Diff)

| 表名 | 类型 | 主要字段 | 唯一Key |
|------|------|----------|---------|
| `in_diff` | 日志表 | record_num, logistic_num, po_num, receive_date, po_sku, po_quantity, sent_quantity, receive_quantity, diff_quantity, status, action, note, seq, by | (logistic_num, po_num, po_sku, seq) |
| `in_diff_final` | 快照表 | record_num, logistic_num, receive_date, po_num, po_sku, po_quantity, sent_quantity, receive_quantity, diff_quantity, status, note, seq, by | (logistic_num, po_num, po_sku) |

**关键**: `in_diff_final` 不存储 `po_price`！需要运行时从 `in_receive_final` 获取。

---

## 二、日志表 vs 快照表模式

### 2.1 设计模式

```
日志表 (in_po, in_send_list, in_receive, in_diff)
    ↓ 每次操作追加一条记录 (INSERT)
    ↓ seq 递增 (L01 → L02 → L03...)
    ↓ action 标记操作类型 (new/add/adjust/delete)
    
快照表 (in_po_final, in_send_final, in_receive_final, in_diff_final)
    ↓ 反映当前最终状态
    ↓ INSERT/UPDATE/DELETE 实现状态同步
```

### 2.2 删除模式

**日志表**: 插入 `quantity=0, action='adjust'` 记录
**快照表**: 物理 DELETE

### 2.3 恢复模式

**日志表**: 回溯找 seq-1 的 quantity，插入 `action='add'` 记录
**快照表**: INSERT 恢复的记录

---

## 三、核心操作详解

### 3.1 新建采购订单 (`po_create/submit.py`)

**写入表**: `in_po`, `in_po_final`, `in_po_strategy`

```
事务开始:
  1. in_po: 每个SKU INSERT action='new', seq='L01'
     字段: update_date, supplier_code, po_num, po_sku, po_quantity, po_price, 
           currency, usd_rmb, by, action, note, seq
           
  2. in_po_final: 每个SKU INSERT po_seq='L01'
     字段: po_date, po_update_date, po_num, po_sku, po_quantity, po_price,
           po_note, po_seq, po_by
           
事务结束

3. in_po_strategy: INSERT seq='V01'
   字段: date, po_num, cur_currency, cur_float, cur_ex_float, 
         cur_deposit, cur_deposit_par, cur_usd_rmb, note, by, seq
```

### 3.2 修改采购订单 (`po_mgmt/edit.py`)

**写入表**: `in_po`, `in_po_final`, `in_po_strategy`

```
1. 策略修改 (strategy_modified=true):
   - in_po_strategy: INSERT new seq (V02, V03...)

2. 明细修改 (items_modified=true):
   - in_po: INSERT new seq (L02, L03...)
     - action='add' 新增SKU
     - action='adjust' 修改数量/价格
     - action='adjust', qty=0 删除单项
     
   - in_po_final:
     - add: INSERT 新行
     - adjust: UPDATE 匹配 (po_num, po_sku, original_qty, original_price)
     - delete: DELETE 匹配行

3. 合并重复记录:
   - 同 (po_num, po_sku, po_price) 的多条记录
   - SUM(po_quantity), 保留最新元数据
   - DELETE 所有 → INSERT 合并后的单条
```

### 3.3 删除采购订单 (`po_mgmt/delete.py`)

**写入表**: `in_po`, `in_po_final`

```
1. 验证:
   - 检查发货状态 (已发货不允许删除)
   
2. in_po: 为每个SKU INSERT qty=0, action='adjust'
   - note='删除订单_操作人_时间'
   - new seq (L02, L03...)
   
3. in_po_final: DELETE WHERE po_num = :po_num
```

### 3.4 恢复采购订单 (`po_mgmt/delete.py`)

**写入表**: `in_po`, `in_po_final`

```
1. 查找删除记录: note LIKE '删除订单%', 取最大 seq 批次

2. 回溯每个SKU:
   - 找 seq-1 的记录获取原 quantity
   
3. in_po: INSERT action='add', 恢复的 quantity
   - new seq

4. in_po_final:
   - DELETE WHERE po_num = :po_num (清理可能的残留)
   - INSERT 恢复的记录
```

---

### 3.5 新建发货单 (`send_create/submit.py`)

**写入表**: `in_send`, `in_send_list`, `in_send_final`, `in_po`, `in_po_final`

```
事务开始:
  1. in_send: INSERT 发货单头 seq='V01'
     字段: date_sent, logistic_num, price_kg, total_weight, total_price,
           usd_rmb, mode, date_eta, pallets, note, date_record, by, seq

  2. 预处理: 从 in_po_final 获取价格信息
     - 按 (po_num, po_sku) 分组
     - 按 po_price DESC 排序 (高价优先)
     - 支持"价格位列"机制选择特定价格

  3. in_send_list: 每个SKU INSERT seq='L01'
     字段: date, logistic_num, po_num, sku, quantity, price, action, note, 
           by, po_change, seq
     - po_change='Y' 表示需要规整订单

  4. in_send_final: 仅 quantity>0 的 INSERT
     字段: sent_date, sent_update_date, sent_logistic_num, po_num, po_sku,
           sent_quantity, po_price, sent_note, sent_seq, sent_by

  5. 规整处理 (po_change='Y' 的行):
     a. 从 in_po 获取原始订货量
     b. 从 in_send_final 计算已发货总量: SUM(sent_quantity)
     c. in_po: INSERT action='adjust', qty=已发货总量
        - note='物流单据规整操作_物流单号'
     d. in_po_final: UPDATE po_quantity=已发货总量
        - 通过 (po_num, po_sku, po_price) 匹配
        
  6. 清理: DELETE FROM in_po_final WHERE po_quantity = 0
事务结束
```

**关键逻辑**: 规整操作使订货量=发货量，处理"实际发货与订单不一致"的场景。

### 3.6 修改发货单货物 (`send_mgmt/edit_items/submit.py`)

**写入表**: `in_send`, `in_send_list`, `in_send_final`, `in_po`, `in_po_final`

```
1. in_send: 若物流参数有修改 INSERT new seq (S02, S03...)

2. in_send_list: 每个变更项 INSERT new seq (L02, L03...)
   - action='add' 新增
   - action='adjust' 修改数量
   - action='adjust', qty=0 删除单项

3. in_send_final:
   - add: INSERT 新行
   - adjust: DELETE + INSERT (先删后插)
   - delete: DELETE 匹配行
   匹配 Key: (sent_logistic_num, po_num, po_sku, po_price)

4. 规整操作 (po_change='Y' 的行):
   - 同新建发货单的规整逻辑
   - in_po: INSERT action='adjust'
   - in_po_final: DELETE + INSERT
```

### 3.7 删除发货单 (`send_mgmt/delete.py`)

**写入表**: `in_send_list`, `in_po`, `in_po_final`, `in_send_final`

```
1. 从 in_send_final 获取该发货单所有货物

2. 对每条记录:
   a. in_send_list: INSERT qty=0, action='adjust'
      - note='删除发货单_操作人_时间'
   b. 如果原记录 po_change='Y':
      - in_po: INSERT action='add', 恢复原订货量
      (如何获取原订货量? 回溯 in_po 找删除前的记录)

3. in_send_final: DELETE WHERE sent_logistic_num = :logistic_num

4. in_po_final:
   - 更新或插入恢复的订货量
   - DELETE WHERE po_quantity = 0
```

---

### 3.8 货物入库 (`receive/submit.py`)

**写入表**: `in_receive`, `in_receive_final`, `in_diff`, `in_diff_final`

```
事务开始:
  0. 重复入库检查: 
     SELECT FROM in_receive_final WHERE logistic_num IN :nums
     若存在则拒绝

  对每个入库项 (logistic_num, po_num, po_sku):
  
  1. 查询 in_send_final 获取所有匹配行（可能多个 po_price）
     SELECT ... ORDER BY po_price DESC

  2. 按 po_price 分配 receive_quantity:
     - 单行: 直接使用
     - 多行 (收货>=发货): 多余加到最高价
     - 多行 (收货<发货): 差额从最低价扣除

  3. in_receive: INSERT action='new', seq='V01'
     字段: sent_date, eta_date_final, receive_date, update_date, logistic_num,
           po_num, po_sku, sent_quantity, receive_quantity, po_price,
           action, note, seq, by

  4. in_receive_final: INSERT
     字段: eta_date_final, receive_date, update_date, logistic_num,
           po_num, po_sku, sent_quantity, receive_quantity, po_price,
           note, seq, by

  5. 差异处理 (sent_quantity != receive_quantity):
     a. diff_quantity = sent_quantity - receive_quantity
        - diff > 0 → 少收 (入库 < 发货)
        - diff < 0 → 多收 (入库 > 发货)
     b. record_num = f"{logistic_num}_{receive_date}"
     c. po_quantity = SUM(po_quantity) FROM in_po_final
     d. in_diff: INSERT status='pending', seq='D01'
     e. in_diff_final: INSERT status='pending'
事务结束
```

### 3.9 修改入库单 (`receive_mgmt/edit.py`)

**写入表**: `in_receive`, `in_receive_final`, `in_diff`, `in_diff_final`

```
对每个修改项:

1. 从 in_send_final 获取发货明细（含多价格）

2. 按价格分配入库量（同入库提交逻辑）

3. in_receive: INSERT action='adjust', new seq (R02, R03...)

4. in_receive_final:
   - 匹配 (logistic_num, po_num, po_sku, po_price)
   - 存在: UPDATE receive_quantity, note, seq, by
   - 不存在: INSERT

5. 差异处理:
   - 有差异 (sent != receive):
     - in_diff: INSERT action='adjust', new seq (D02, D03...)
     - in_diff_final: 存在则 UPDATE, 不存在则 INSERT
   - 无差异 (sent == receive):
     - in_diff_final: DELETE 该记录 (差异消除)
```

---

### 3.10 定金付款 (`finance/deposit/api.py`)

**写入表**: `in_pmt_deposit`, `in_pmt_deposit_final`, `in_pmt_prepay`, `in_pmt_prepay_final`

```
1. in_pmt_deposit: 插入付款明细
   - pmt_no: `PMT_{YYYYMMDD}_N{seq}` (批量共享)
   - dep_paid: 现金支付金额 (cash)
   - dep_prepay_amount: 预付款抵扣金额 (deduction)
   - extra_amount: 额外费用 (extra fee)
   - ops='new', seq='D01'

2. in_pmt_deposit_final: 触发器自动同步

3. in_pmt_prepay (仅当 dep_prepay_amount > 0):
   - tran_num: `{supplier_code}_{YYYYMMDD}_out_{seq}`
   - tran_type: 'out' (使用预付款)
   - tran_amount: dep_prepay_amount
   - note: `Deposit_{pmt_no}_原始支付单`

4. in_pmt_prepay_final: 触发器自动同步
```

**业务规则**:
- **批量付款**: 同一次提交的多个订单共享同一个 `pmt_no`
- **预付款抵扣**: 优先使用预付款余额，不足部分走现金支付
- **额外费用**: 平均分摊到选中的每个订单行

---

## 四、价格传递路径

```
新建订单:
  用户输入 unit_price → in_po.po_price → in_po_final.po_price

发货时:
  in_po_final.po_price ── (价格位列选择) ──→ in_send_list.price → in_send_final.po_price

入库时:
  in_send_final.po_price ── (直接继承) ──→ in_receive.po_price → in_receive_final.po_price

差异查询时:
  in_diff_final (无 po_price) ── (运行时JOIN) ──→ in_receive_final.po_price
```

---

## 五、差异定义与策略

### 5.1 差异计算

```python
diff_quantity = sent_quantity - receive_quantity
```

| diff_quantity | 含义 | 场景 |
|---------------|------|------|
| > 0 (正) | 少收 | 发货100, 入库90, diff=+10 |
| < 0 (负) | 多收 | 发货100, 入库110, diff=-10 |

### 5.2 策略可用性

| 策略 | 少收 (diff > 0) | 多收 (diff < 0) |
|------|-----------------|-----------------|
| 1. 仅修正发货单 | ✓ | ✓ |
| 2. 同步修正发货+订单 | ✓ | ✓ |
| 3. 延迟入库 | ✓ | ✗ |
| 4. 厂商错误 | ✓ | ✓ |

**策略3只能用于少收**: 货物还没到，可以延迟等待到货。

---

## 六、异常处理后端逻辑 (待实现)

### 6.1 策略1: 仅修正发货单

```
1. in_send_list: INSERT action='adjust', quantity=receive_quantity
2. in_send_final: UPDATE sent_quantity=receive_quantity
3. in_diff_final: UPDATE status='resolved'
```

### 6.2 策略2: 同步修正发货单与订单

```
1-2. 同策略1
3. in_po: INSERT action='adjust', qty=receive_quantity
4. in_po_final: UPDATE po_quantity=receive_quantity
5. in_diff_final: UPDATE status='resolved'
```

### 6.3 策略3: 延迟入库 (仅少收)

```
新建延迟入库发货单:
1. in_send: INSERT 新发货单头 (logistic_num + '-D')
2. in_send_list: INSERT 差异数量
3. in_send_final: INSERT 差异数量
4. in_diff_final: UPDATE status='resolved'
```

### 6.4 策略4: 厂商错误

**少收 (diff > 0)**:
```
缺少的货物按原价出库耗损:
1. in_receive: INSERT 负数量记录 (-diff), note='厂商错误_出库耗损'
2. in_diff_final: UPDATE status='resolved'
```

**多收 (diff < 0)**:
```
多余的货物以0成本入库:
1. in_receive: INSERT 正数量记录 (+|diff|), po_price=0, note='厂商错误_0成本入库'
2. in_diff_final: UPDATE status='resolved'
```

---

## 七、关键业务规则总结

1. **同订单同SKU多价格**: `(po_num, po_sku, po_price)` 是完整Key
2. **价格位列**: 发货时可选择使用第几个价格（按价格DESC排序）
3. **规整操作**: po_change='Y' 时，订货量自动调整为发货量
4. **多价格分配**: 入库时按价格分配：多余加到高价，不足从低价扣
5. **差异记录**: `in_diff_final` 不存储 `po_price`，需运行时获取
6. **删除模式**: 日志表 qty=0，快照表物理DELETE
7. **事务保护**: 所有写入使用 `DBClient.atomic_transaction()`

---

## 八、尚存疑问

**已确认无疑问**: 所有核心流程的表写入逻辑已完全理解。

---

*审计完成 - 2026-01-04*
