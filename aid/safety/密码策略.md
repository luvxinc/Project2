# 密码策略系统架构文档

> **Purpose**: 此文件阐述了系统的安全核心 —— **L0-L4 安全矩阵**。它定义了如何保护敏感操作、如何配置 `action_registry.json` 以及前端如何调用 `requestPasswordVerify`。
> **AI Attention**: 在实现任何“删除”、“修改”、“审批”等敏感功能时，**必须** 查阅此文档并实现相应的安全验证流程。
> **Constraints**: `HARD` - 敏感操作必须有 Security Check。
> **Related Files**: 
> - `aid/module/模块权限.md`: 权限与安全策略的配合。
> - `aid/flow/双modal.md`: 处理密码框与其他 Modal 的冲突。



> **最后更新**: 2026-01-09
> **维护者**: AI Agent
> **系统版本**: Security Policy Manager V5.3

---

## 一、系统概述

密码策略系统是 MGMT ERP 的核心安全组件，用于控制敏感操作的身份验证要求。该系统实现了 **L0-L4 五级安全矩阵**，管理员可通过 UI 动态配置每个操作所需的验证级别。

### 核心设计原则

1. **Fail-Closed（失败即关闭）**: 任何未注册的 actionKey 都会被拒绝
2. **No Frontend Mapping（前端无映射）**: 前端不存储 actionKey 到安全级别的映射，全部从后端实时获取
3. **Hot Reload（热更新）**: 策略变更即时生效，无需重启服务器
4. **Centralized Audit（集中审计）**: 所有安全相关操作都会被记录到审计日志

---

## 二、安全令牌级别 (L0-L4 Matrix)

| 级别 | 令牌名称 | 环境变量 | 验证方式 | 适用场景 |
|------|----------|----------|----------|----------|
| **L0** | `user` | N/A | 当前登录用户密码 | 常规敏感操作（删除、修改等） |
| **L1** | `query` | `SEC_CODE_QUERY` | 静态安全码 | 低风险查询操作 |
| **L2** | `modify` | `SEC_CODE_MODIFY` | 静态安全码 | 数据修改操作 |
| **L3** | `db` | `SEC_CODE_DB` | 静态安全码 | 数据库/系统运维操作 |
| **L4** | `system` | `SEC_CODE_SYSTEM` | 静态安全码 | 最高级别（不可逆操作） |

### 请求参数名映射

| 令牌 | POST 参数名 |
|------|-------------|
| `user` | `sec_code_l0` 或 `sec_code_user` |
| `query` | `sec_code_l1` |
| `modify` | `sec_code_l2` |
| `db` | `sec_code_l3` |
| `system` | `sec_code_l4` |

> **重要**: 前端 `requestPasswordVerify` 返回的 passwords 对象格式为 `{ user: "密码" }`，需要转换为 `sec_code_user` 发送到后端。

---

## 三、核心配置文件

### 3.1 动作注册表 (action_registry.json)

**位置**: `backend/common/action_registry.json`

**作用**: 定义系统中所有可配置安全策略的操作（按模块/子模块/Tab 组织）

**结构示例**:
```json
{
  "_meta": { "version": "5.0" },
  "modules": [
    {
      "key": "purchase",
      "name": "采购板块",
      "submodules": [
        {
          "key": "po_mgmt",
          "name": "订单管理",
          "tabs": [
            {
              "key": "delete",
              "name": "删除订单",
              "actions": [
                {
                  "key": "btn_po_delete",
                  "name": "确认删除订单",
                  "displayName": "删除订单",
                  "description": "软删除采购订单记录",
                  "default_security": []
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}
```

**关键字段**:
- `key`: actionKey，唯一标识符
- `name`: 操作名称（用于密码策略矩阵 UI）
- `displayName`: 前端显示名称（用于密码验证弹窗）
- `description`: 操作描述
- `default_security`: 默认安全要求（如 `["user"]` 或 `["db", "system"]`）

### 3.2 安全覆盖配置 (security_overrides.json)

**位置**: `backend/data/security_overrides.json`

**作用**: 存储管理员通过 UI 配置的安全策略覆盖

**结构示例**:
```json
{
  "btn_po_delete": ["user"],
  "btn_po_modify": ["user"],
  "btn_receive_confirm": ["user"],
  "btn_purge_logs": ["db", "system"]
}
```

**优先级**: `security_overrides.json` > `action_registry.json` 中的 `default_security`

### 3.3 管理员职能开关 (admin_capabilities.json)

**位置**: `backend/data/admin_capabilities.json`

**作用**: 控制普通管理员的功能权限

---

## 四、后端核心组件

### 4.1 SecurityPolicyManager

**位置**: `backend/core/services/security/policy_manager.py`

**职责**: 
- 加载和缓存安全策略配置
- 验证请求是否满足安全要求
- 支持热更新（通过文件时间戳检测）

**核心方法**:

```python
# 获取 actionKey 所需的验证令牌列表
tokens = SecurityPolicyManager.get_required_tokens('btn_po_delete')
# 返回: ['user'] 或 ['db', 'system'] 或 []

# 验证请求是否通过安全检查
is_valid, msg = SecurityPolicyManager.verify_action_request(request, 'btn_po_delete')
# 返回: (True, "Security Check Passed") 或 (False, "缺少验证码: 当前用户密码")

# 验证单个令牌
is_ok = SecurityPolicyManager.validate_single_token('user', password, request)
# 对于 L0: 验证当前登录用户的密码
# 对于 L1-L4: 验证环境变量中的静态安全码

# 强制重置缓存
SecurityPolicyManager.reset_cache()
```

**热更新机制**:
- 每次调用 `get_required_tokens()` 时检查文件修改时间
- 如果 `security_overrides.json` 有变化，自动重新加载
- 管理员保存策略后调用 `reset_cache()` 确保立即生效

### 4.2 安全要求 API

**URL**: `/api/sys/security_requirements?action=xxx`

**位置**: `backend/web_ui/views/system.py` → `get_security_requirements()`

**作用**: 前端调用此 API 获取某个 actionKey 需要的验证级别

**响应示例**:
```json
# 需要用户密码验证
{ "status": "ok", "required_slots": ["l0"] }

# 需要 L3+L4 验证
{ "status": "ok", "required_slots": ["l3", "l4"] }

# 无需验证
{ "status": "ok", "required_slots": [] }

# actionKey 未注册（Fail-Closed）
{ "status": "error", "message": "Security Policy Block: Action 'xxx' is not registered." }
```

### 4.3 Django Template Tag

**位置**: `backend/web_ui/templatetags/security_tags.py`

**作用**: 在模板中自动渲染安全输入框（旧版模式，已被 GlobalModal 替代）

**用法**:
```html
{% load security_tags %}
{% security_inputs 'btn_po_delete' %}
```

---

## 五、前端核心组件

### 5.1 统一安全验证适配层 (security-verify.js)

**位置**: `backend/static/js/security-verify.js`

**核心函数**: `requestPasswordVerify(actionKey, onSuccess, contextEl, actionDisplayName, onCancel)`

**参数说明**:

| 参数 | 类型 | 说明 |
|------|------|------|
| `actionKey` | string | 操作标识（如 `btn_po_delete`） |
| `onSuccess` | function | 验证通过回调，**接收 passwords 参数** |
| `contextEl` | HTMLElement | 上下文元素（用于回填，可选） |
| `actionDisplayName` | string | 操作显示名称（如"删除订单"） |
| `onCancel` | function | 用户取消回调（可选） |

**工作流程**:

```
1. 调用 /api/sys/security_requirements?action=xxx
2. 获取 required_slots: ['l0'] 或 ['l3', 'l4']
3. 如果 required_slots 为空 → 直接调用 onSuccess({})
4. 否则 → 显示 GlobalModal.showPassword() 弹窗
5. 用户输入密码并点击确认
6. 调用 onSuccess(passwords) 传递密码对象
```

**passwords 对象格式**:
```javascript
// 需要 L0 (用户密码) 时
{ "user": "用户输入的密码" }

// 需要 L3 + L4 时
{ "db": "L3安全码", "system": "L4安全码" }
```

### 5.2 GlobalModal 密码验证弹窗

**位置**: `backend/static/js/global-modal.js` → `showPassword(options)`

**功能**: 根据 required_slots 动态渲染密码输入框

---

## 六、完整数据流

### 6.1 前端发起验证流程

```
┌─────────────────────────────────────────────────────────────────┐
│  用户点击"删除订单"按钮                                          │
└───────────────────────┬─────────────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  调用 requestPasswordVerify('btn_po_delete', onSuccess, ...)    │
└───────────────────────┬─────────────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  GET /api/sys/security_requirements?action=btn_po_delete        │
│  返回: { "required_slots": ["l0"] }                              │
└───────────────────────┬─────────────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  GlobalModal.showPassword({ requiredCodes: ['l0'], ... })       │
│  显示密码输入弹窗                                                │
└───────────────────────┬─────────────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  用户输入密码，点击确认                                          │
│  passwords = { "user": "输入的密码" }                            │
└───────────────────────┬─────────────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  调用 onSuccess(passwords)                                       │
│  → 将密码转换为 sec_code_user 添加到请求体                       │
│  → POST 到后端 API                                               │
└───────────────────────┬─────────────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  后端 SecurityPolicyManager.verify_action_request(...)          │
│  从 request.POST 读取 sec_code_user 进行验证                     │
└─────────────────────────────────────────────────────────────────┘
```

### 6.2 密码传递模式

**模式 A: 直接传递（验证后立即提交）**

```javascript
requestPasswordVerify(
    'btn_po_delete',
    (passwords) => submitDelete(passwords),  // 直接接收并传递
    null, '删除订单', () => {}
);

function submitDelete(passwords) {
    const requestBody = { po_num: currentPoNum };
    
    // 转换密码格式
    if (passwords) {
        for (const [slot, code] of Object.entries(passwords)) {
            requestBody[`sec_code_${slot}`] = code;
        }
    }
    
    fetch('/api/po/delete', {
        method: 'POST',
        body: JSON.stringify(requestBody)
    });
}
```

**模式 B: 全局变量（验证和提交跨步骤）**

```javascript
// Step 5: 验证通过后存储密码
let verifiedPasswords = null;

requestPasswordVerify(
    'btn_send_modify',
    (passwords) => {
        verifiedPasswords = passwords;  // 存储
        showStep(6);  // 跳转到提交步骤
    },
    null, '修改发货单', () => {}
);

// Step 6: 提交时读取密码
function runStep6Submit() {
    const requestBody = { logistic_num: xxx };
    
    if (verifiedPasswords) {
        for (const [slot, code] of Object.entries(verifiedPasswords)) {
            requestBody[`sec_code_${slot}`] = code;
        }
    }
    
    fetch('/api/send/modify', { ... });
}
```

**模式 C: 公共组件集成（GlobalFileViewer）**

```javascript
// GlobalFileViewer 初始化时配置密码验证
new GlobalFileViewer({
    containerId: 'invoice-view',
    title: '账单文件查看',
    // ... 其他配置
    
    // 删除功能配置
    deleteUrl: '/api/po/delete_invoice/',
    deletePayload: { po_num: currentPoNum },
    
    // [关键] 启用密码验证
    requireDeletePassword: true,
    deletePasswordActionKey: 'btn_po_delete_invoice'  // action_registry.json 中注册的 key
});

// GlobalFileViewer 内部流程：
// 1. 用户点击删除按钮
// 2. 显示 GlobalModal.showConfirm() 确认对话框
// 3. 用户确认后调用 requestPasswordVerify()
// 4. 密码验证通过后，发送删除请求（包含 sec_code_* 参数）
```

---

## 七、管理员 UI

### 7.1 密码策略矩阵页面

**URL**: `/dashboard/admin/password_policy/`

**位置**: `backend/templates/user_admin/pages/password_policy.html`

**功能**:
- 显示所有可配置安全策略的操作
- 每行显示 L0-L4 五个开关
- 修改后点击"保存"立即生效

### 7.2 策略更新 API

**URL**: `/dashboard/admin/actions/policy_update/`

**位置**: `backend/apps/user_admin/views/actions.py` → `policy_update()`

**权限**: 仅 Super Admin

**流程**:
1. 接收 actionKey 和选中的 tokens 列表
2. 更新 `security_overrides.json`
3. 调用 `SecurityPolicyManager.reset_cache()` 刷新缓存
4. 返回成功/失败状态

---

## 八、涉及的所有文件

### 后端文件

| 文件路径 | 作用 |
|----------|------|
| `core/services/security/policy_manager.py` | 核心安全策略管理器 |
| `common/action_registry.json` | 动作注册表 |
| `data/security_overrides.json` | 安全策略覆盖配置 |
| `web_ui/views/system.py` | 安全要求 API |
| `web_ui/templatetags/security_tags.py` | 模板标签 |
| `apps/user_admin/views/actions.py` | 策略更新 API |
| `apps/user_admin/core/services.py` | 策略保存服务 |
| `templates/user_admin/pages/password_policy.html` | 策略矩阵 UI |

### 前端文件

| 文件路径 | 作用 |
|----------|------|
| `static/js/security-verify.js` | 统一安全验证适配层 |
| `static/js/global-modal.js` | 密码验证弹窗组件 |
| `templates/components/security_password_modal.html` | 密码输入模板（旧版） |

### 使用密码验证的业务文件（采购模块）

| 文件路径 | 相关 actionKey |
|----------|----------------|
| `templates/purchase/pages/po_mgmt/po_delete.html` | `btn_po_delete` |
| `templates/purchase/pages/po_mgmt/po_edit.html` | `btn_po_modify` |
| `templates/purchase/pages/po_mgmt.html` | `btn_po_undelete`, `btn_po_upload_invoice`, `btn_po_delete_invoice` |
| `templates/purchase/pages/send_mgmt/send_delete.html` | `btn_send_delete` |
| `templates/purchase/pages/send_mgmt/send_edit_step5.html` | `btn_send_modify` |
| `templates/purchase/pages/send_mgmt.html` | `btn_send_undelete`, `btn_send_upload_invoice`, `btn_send_delete_invoice` |
| `templates/purchase/pages/receive.html` | `btn_receive_confirm` |
| `templates/purchase/pages/receive_mgmt.html` | `btn_receive_undelete`, `btn_receive_delete_file` |
| `templates/purchase/pages/receive_mgmt/receive_delete.html` | `btn_receive_delete` |
| `templates/purchase/pages/receive_mgmt/receive_edit.html` | `btn_receive_mgmt_edit` |
| `templates/purchase/pages/supplier_add.html` | `btn_add_supplier` |
| `templates/purchase/pages/strategy.html` | `btn_modify_strategy` |
| `templates/purchase/pages/abnormal_process_wizard.html` | `btn_abnormal_process` |

### 使用密码验证的业务文件（财务模块）

| 文件路径 | 相关 actionKey |
|----------|----------------|
| `backend/apps/finance/views/deposit/api.py` | `deposit_payment_submit` |
| `backend/apps/finance/views/logistic.py` | `logistic_payment_delete` |

### 使用密码验证的公共组件

| 文件路径 | 集成方式 | 说明 |
|----------|----------|------|
| `static/js/global_file_viewer.js` | `requireDeletePassword` + `deletePasswordActionKey` | 文件删除操作密码验证 |

---

## 九、常见问题排查

### Q1: "缺少验证码: 当前用户密码"

**原因**: 前端 `requestPasswordVerify` 的 `onSuccess` 回调没有正确接收和传递 `passwords` 参数

**检查点**:
1. `onSuccess` 回调是否接收 `passwords` 参数
2. 密码是否正确添加到请求体（`sec_code_user` 或 `sec_code_l0`）

**正确写法**:
```javascript
requestPasswordVerify(
    'btn_xxx',
    (passwords) => executeAction(passwords),  // ✅ 接收 passwords
    null, '操作名称', () => {}
);

function executeAction(passwords) {
    const body = { ... };
    if (passwords) {
        for (const [slot, code] of Object.entries(passwords)) {
            body[`sec_code_${slot}`] = code;  // ✅ 添加到请求体
        }
    }
    fetch('/api/xxx', { body: JSON.stringify(body) });
}
```

### Q2: "Security Policy Block: Action 'xxx' is not registered"

**原因**: actionKey 未在 `action_registry.json` 中注册

**解决**: 在 `action_registry.json` 中添加该 action 的定义

### Q3: 策略修改后不生效

**检查点**:
1. `security_overrides.json` 是否已更新
2. 后端是否调用了 `SecurityPolicyManager.reset_cache()`
3. 前端是否有缓存（刷新页面或清除 `CACHE` 对象）

---

## 十、扩展新功能的标准流程

### 添加新的密码保护操作

1. **注册 actionKey** (`action_registry.json`)
```json
{
  "key": "btn_new_action",
  "name": "新操作",
  "displayName": "执行新操作",
  "description": "描述"
}
```

2. **配置默认安全级别** (`security_overrides.json`)
```json
{
  "btn_new_action": ["user"]
}
```

3. **前端调用验证**
```javascript
requestPasswordVerify(
    'btn_new_action',
    (passwords) => executeNewAction(passwords),
    null, '执行新操作', () => {}
);
```

4. **后端验证**
```python
is_valid, msg = SecurityPolicyManager.verify_action_request(request, 'btn_new_action')
if not is_valid:
    return JsonResponse({'success': False, 'message': msg}, status=403)
```

---

## 十一、SecurityGateMiddleware 白名单

### 11.1 中间件说明

**位置**: `backend/middleware/security_gate.py`

`SecurityGateMiddleware` 是一个**全局拦截中间件**，用于对所有非白名单路径的 POST 请求强制检查 `X-Security-Code` Header。

### 11.2 白名单配置

```python
self.whitelist = [
    '/api/sys/config/',
    '/api/health/',
    '/admin/',
    '/login/',
    '/logout/',
    '/static/',
    '/dashboard/',          # ← 大部分模块的 API 都在这个路径下
    '/api/sys/log_error/',
    '/log/',                # ← 2026-01-11 新增，日志系统有自己的密码验证
]
```

### 11.3 ⚠️ 关键注意事项

当创建**新的顶级路由**（如 `/log/`、`/custom_module/`）时，**必须**将其加入白名单，否则：

1. 所有 POST 请求都会被拦截
2. 返回 `403` 和 `"Security Gate: Invalid Security Code"` 错误
3. 即使前端正确传递了密码，后端也无法接收到请求

**症状**: 密码验证弹窗正常显示，用户输入密码后提交，但返回 `403 Forbidden - Security Gate: Invalid Security Code`

**解决方案**: 在 `security_gate.py` 的 `whitelist` 中添加新路径

---

## 十二、标准密码传递模式（JSON Body）

### 12.1 推荐模式（参考 deposit_step3_confirm.html）

对于使用 `fetch` + JSON 请求体的场景，推荐以下模式：

```javascript
function executeSecureAction() {
    requestPasswordVerify(
        'btn_action_key',           // action_registry.json 中注册的 key
        function(passwords) {
            // 1. 构建请求体
            var requestBody = {
                // 业务数据
                po_num: 'xxx',
                amount: 100
            };
            
            // 2. 密码注入 - 严格遵循密码策略
            if (passwords) {
                console.log('[Action] Injecting passwords:', Object.keys(passwords));
                for (var slot in passwords) {
                    // 标准注入: sec_code_l0, sec_code_user, sec_code_l3, sec_code_l4 等
                    requestBody['sec_code_' + slot] = passwords[slot];
                    
                    // 兼容性冗余: 确保后端能识别 (user ↔ l0 互通)
                    if (slot === 'user') {
                        requestBody['sec_code_l0'] = passwords[slot];
                    }
                    if (slot === 'l0') {
                        requestBody['sec_code_user'] = passwords[slot];
                    }
                }
            }
            
            // 3. 发送请求 - 必须使用 Content-Type: application/json
            fetch('/api/xxx/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCsrfToken()
                },
                body: JSON.stringify(requestBody)
            })
            .then(function(res) { return res.json(); })
            .then(function(data) {
                if (data.success) {
                    // 成功处理
                } else {
                    createAndShowToast(data.message || '操作失败', 'danger');
                }
            });
        },
        null,                       // contextEl（可选）
        '操作显示名称',               // 弹窗标题
        function() {}               // onCancel
    );
}
```

### 12.2 后端验证（JSON Body）

后端 `SecurityPolicyManager.verify_action_request` 已支持从 JSON Body 读取密码：

```python
@require_POST
def api_secure_action(request):
    from core.services.security.policy_manager import SecurityPolicyManager
    
    is_valid, msg = SecurityPolicyManager.verify_action_request(request, "btn_action_key")
    
    if not is_valid:
        return JsonResponse({'success': False, 'message': msg}, status=403)
    
    # 业务逻辑...
    return JsonResponse({'success': True})
```

### 12.3 完整流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│  用户点击按钮                                                         │
└───────────────────────────┬─────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────────────┐
│  requestPasswordVerify('btn_xxx', onSuccess, ...)                    │
│  → GET /api/sys/security_requirements?action=btn_xxx                 │
│  → 返回 required_slots: ['l0']                                       │
└───────────────────────────┬─────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────────────┐
│  GlobalModal.showPassword({ requiredCodes: ['l0'] })                 │
│  → 用户输入密码                                                       │
│  → 点击确认                                                           │
│  → passwords = { l0: "用户密码" }                                     │
└───────────────────────────┬─────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────────────┐
│  onSuccess(passwords)                                                │
│  → requestBody.sec_code_l0 = passwords.l0                            │
│  → requestBody.sec_code_user = passwords.l0  // 兼容                  │
└───────────────────────────┬─────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────────────┐
│  fetch('/api/xxx/', {                                               │
│      method: 'POST',                                                │
│      headers: { 'Content-Type': 'application/json' },               │
│      body: JSON.stringify(requestBody)                              │
│  })                                                                 │
└───────────────────────────┬─────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────────────┐
│  SecurityGateMiddleware                                             │
│  → 检查路径是否在白名单中                                             │
│  → 如果不在白名单且无 X-Security-Code Header → 返回 403               │
│  → 如果在白名单中 → 放行到后续处理                                    │
└───────────────────────────┬─────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────────────┐
│  SecurityPolicyManager.verify_action_request(request, 'btn_xxx')    │
│  → 从 request.body (JSON) 读取 sec_code_l0 / sec_code_user          │
│  → 验证密码                                                          │
│  → 返回 (True/False, msg)                                            │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 十三、版本历史

| 版本 | 日期 | 变更 |
|------|------|------|
| V5.4 | 2026-01-11 | 新增 SecurityGateMiddleware 白名单说明、标准 JSON 密码传递模式 |
| V5.3 | 2026-01-03 | GlobalFileViewer 集成 GlobalModal 删除确认、新增 `btn_po_delete_invoice` |
| V5.2 | 2026-01 | 热更新机制、完善采购模块密码传递 |
| V5.0 | 2025-12 | 三层架构（模块/子模块/Tab） |
| V4.0 | 2025-11 | GlobalModal 替代内联表单 |
| V3.0 | 2025-10 | 动态策略覆盖机制 |
