# 修改功能按钮与编辑向导 (Edit Wizard Pattern)

> **Purpose**: 本文档作为「修改/编辑功能」的标准工程参考。以 **采购板块 - 发货单管理 (Send Management)** 的修改向导为例，解析如何将修改功能构建为“带预填充的新建向导变体”，并强调基于 Append-Only 模式的版本化修改逻辑。
> **Scope**: 适用于任何需要复杂编辑流程（如多步Wizard）、需要保留历史版本（Versioning）、或涉及主子表联动修改的业务模块。

---

## 1. 核心设计理念

**"Edit is a Special Case of Create" (修改即新建的变体)**

在我们的ERP架构中，修改一个已存在的实体（如发货单），**不是**对数据库记录的直接 `UPDATE`，而是：
1.  **读取**当前最新状态 (Latest State)。
2.  **预填充**到 Wizard 中 (Pre-fill)。
3.  **新建**一条新版本的记录 (Append New Version)。

这种模式确保了：
*   **审计可追溯**: 保留了所有历史版本（V01, V02...）。
*   **UI 复用**: 修改向导与新建向导共享 90% 的 UI 组件和逻辑。

---

## 2. 前端实现逻辑 (Interaction)

### 2.1 触发入口 (The Trigger)

在列表页的操作列，放置修改按钮。通过 `can_modify` 属性控制按钮可用性（例如：已入库单据不可修改）。

```html
<!-- 列表页按钮示例 -->
<button class="action-btn edit" onclick="editOrder('{{ item.logistic_num }}')"
        disabled="{{ not item.can_modify }}">
    <i class="fas fa-pen"></i>
</button>
```

### 2.2 数据加载 (Pre-fill State)

点击按钮后，调用专用 API 获取当前状态，而非复用列表数据（列表数据可能不全）。

```javascript
/* 参考: send_edit.html -> loadOrderForEdit() */
function loadOrderForEdit(logisticNum) {
    // 1. Reset Wizard to Step 1
    editCurrentStep = 1;
    
    // 2. Fetch Latest Data
    fetch(`/api/send_mgmt/edit_data/?logistic_num=${logisticNum}`)
        .then(r => r.json())
        .then(data => {
            // 3. Pre-fill Wizard Fields
            renderLogisticsWithEdit(data.data.logistics);
            
            // 4. Update Version Indicators
            document.getElementById('current-ver-label').textContent = data.data.current_seq; // e.g., 'S01'
        });
}
```

### 2.3 向导流程设计 (GlobalWizard Integration)

修改向导通常包含比新建向导更灵活的路径，支持 **"跳过 (Skip)"** 逻辑。

**步骤定义 (Steps)**:
1.  **修改 Header (Logistics)**: 允许修改物流商、费用等。
    *   *Feature*: 提供 "跳过此步" 按钮（如果用户只想改明细）。
2.  **修改 Lines (Items)**: 允许修改货物数量、增删SKU。
    *   *Feature*: 提供 "跳过此步" 按钮（如果用户只想改Header）。
3.  **验证与提交 (Verify & Submit)**: 
    *   显示 "无变更" 警告（如果两步都跳过了）。
    *   显示 "版本变更预览" (Preview changes: `S01 -> S02`).

### 2.4 公有组件复用

必须使用 `GlobalWizard` (JS Class) 和统一的 UI 模版 (`wizard_step.html` partials)。

```javascript
editPoWizard = new GlobalWizard({
    containerId: 'edit-wizard-container',
    steps: [
        { id: 'logistics', label: '修改物流', contentSelector: '#edit-step-1' },
        { id: 'items', label: '修改明细', contentSelector: '#edit-step-3' },
        { id: 'done', label: '完成', type: 'done', contentSelector: '#edit-step-6' }
    ],
    // ...
});
```

### 2.5 汇率组件集成 (GlobalExchangeRate Integration)

在涉及跨币种业务（如采购、跨国物流）的修改场景中，必须使用 `GlobalExchangeRate` 标准组件替代传统的 `<input>` 框，以确保“自动获取/手动锁定”逻辑的一致性。

**集成规范**:

1.  **容器化**: 在 HTML 中保留空的 `div` 容器（如 `#rate-container`）。
2.  **组件初始化**:
    ```javascript
    // 初始化组件
    const rateComponent = new GlobalExchangeRate({
        container: '#rate-container',
        inputId: 'edit_usd_rmb', // 隐藏的 input ID
        apiUrl: "{% url 'web_ui:purchase:po_exchange_rate' %}", // 后端 API 地址
        defaultRate: currentData.usd_rmb || 7.0, 
        getDateFn: () => document.getElementById('edit_date').value, // 动态绑定依赖日期
        onChange: (rate, source) => { /* Optional: Trigger other Calcs */ }
    });
    ```
3.  **状态回填 (State Restoration)**:
    修改现有单据时，必须准确还原之前的“自动”或“手动”状态，而不仅仅是数值。
    ```javascript
    // 假设后端返回的数据包含 rate(数值) 和 mode('A'/'M')
    if (currentData.usd_rmb) {
        // 映射后端 mode 到组件 source 常量
        const source = currentData.mode === 'A' ? 'auto' : 'manual';
        // 使用 setRate(value, source) 还原状态
        rateComponent.setRate(currentData.usd_rmb, source);
    }
    ```
4.  **数据收集 (Submission)**:
    提交时，不仅要提交汇率值，还要提交来源（Source），以便后端审计。
    ```javascript
    const rateData = rateComponent.getValue(); 
    // Returns: { rate: 7.1234, source: 'manual' ... }
    
    payload.usd_rmb = rateData.rate;
    payload.usd_rmb_manual = (rateData.source === 'manual'); // true/false flag
    ```

---

## 3. 后端实现逻辑 (Backend Handling)

**文件参考**: `backend/apps/purchase/views/send_mgmt/edit.py`

### 3.1 获取数据的接口 (`get_po_for_edit_api`)

*   **Endpoint**: `/api/send_mgmt/edit_data/`
*   **Logic**:
    *   根据 ID (`logistic_num`) 查询 `in_send` (Header) 和 `in_send_list` (Lines)。
    *   **关键**: 必须按 `seq` 倒序排列，取 LIMIT 1，确保拿到的是 Current State。
    *   返回格式应直接适配前端 Form 结构。

### 3.2 提交修改的接口 (`submit_po_modification_api`)

*   **Endpoint**: `/api/send_mgmt/submit_modify/`
*   **Core Logic (Append-Only)**:
    1.  **Check Existence**: 确认单据存在。
    2.  **Get Max Seq**: 查询当前最大版本号 (e.g., `S01`).
        ```python
        max_num = DBClient.read_df("SELECT MAX(seq)...").iloc[0]['max_num']
        ```
    3.  **Calculate New Seq**: `S{max_num + 1}` (e.g., `S02`).
    4.  **Insert Header**: `INSERT INTO in_send ... VALUES (..., seq='S02')`.
    5.  **Insert Lines**: `INSERT INTO in_send_list ... VALUES (..., seq='L02')`.
        *   **注意**: 即使某些行没变，通常也需要完整复制或记录变更项（取决于具体的日志策略：全量快照 vs 增量日志。建议**增量日志** `action='adjust'` + **全量快照** `_final` 表更新）。
    6.  **Update Final Table**: 触发 Trigger 或手动代码逻辑更新 `_final` 表，使其反映 V02 的状态。

---

## 4. 变体与灵活性 (Variants)

在不同模块复用时，可以根据复杂度调整：

1.  **极简模式 (Simple Modal)**:
    *   如果不涉及多步，可以直接弹窗 (GlobalModal)。
    *   后台逻辑依然保持 Append-Only。
2.  **分步跳过模式 (Step Skipping)**:
    *   如上文所述，允许用户只改一部分。
    *   前端需要维护 `editedHeader = true/false` 和 `editedLines = true/false` 状态标志。
3.  **只读字段 (Immutable Fields)**:
    *   某些字段（如供应商、关联的订单号）在创建后通常不允许修改。前端应将其渲染为 `readonly` 或 `disabled`，后端应忽略这些字段的提交值。

---

## 5. 关键业务规则

1.  **Versioning Constraints**: 修改产生的版本号 (`seq`) 必须严格递增。
2.  **Concurrency Check**: 提交时最好检查前端传来的 `current_seq` 是否等于数据库的 `max_seq`，防止多人同时修改覆盖（乐观锁）。
3.  **Final State Consistency**: `_final` 表必须永远反映最新的版本。
4.  **Audit Trail**: `note` 字段应强制要求填写或自动生成（如 "用户A修改了物流费用"）。
