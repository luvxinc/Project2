# 财务删除/恢复按钮功能 (Soft Delete & Restore)

> **Purpose**: 本文档作为「财务板块 - 厂商预付款管理 删除/恢复按钮」功能的标准工程参考。详细解析如何基于 Mutation Log（日志表）+ Resolution Snapshot（终态表）的双表架构，实现**软删除**与**时间轴恢复**功能。
> **Scope**: 适用于任何采用 `in_{entity} / in_{entity}_final` 双表模式的业务模块（如 Inbound PO, Logistic Payments）。

---

## 1. 功能概述

此功能包含两个互斥状态的按钮：**"删除" (Delete)** 和 **"恢复" (Restore / Undelete)**。

1.  **删除模式**: 
    *   **触发**: 用户点击 "删除" 按钮。
    *   **行为**: 向日志表追加 `ops='delete'` 记录，触发终态表物理删除。
    *   **展现**: 列表项变灰/划线，按钮变为 "恢复"。

2.  **恢复模式**:
    *   **触发**: 用户点击 "恢复" 按钮。
    *   **行为**: 回溯日志表找到最近一次有效记录，追加 `ops='new'` 记录（复制旧数据），触发终态表重新插入。
    *   **展现**: 列表项恢复正常，按钮变为 "删除"。

---

## 2. 前端实现逻辑 (Interaction)

### 2.1 按钮定义

建议在列表的 Actions 列使用动态渲染：

```html
<!-- 模板伪代码 -->
{% if item.is_deleted %}
    <button class="btn-restore" onclick="restoreDeposit('{{ item.pmt_no }}')">
        <i class="fas fa-trash-restore"></i> 恢复
    </button>
{% else %}
    <button class="btn-delete" onclick="deleteDeposit('{{ item.pmt_no }}')">
        <i class="fas fa-trash"></i> 删除
    </button>
{% endif %}
```

### 2.2 交互逻辑

#### A. 删除操作 (`deleteDeposit`)
1.  **确认弹窗**: `Standard Delete Warning` ("确定要删除该付款记录吗？").
2.  **密码验证**: 调用 `requestPasswordVerify` (Action Key: `btn_delete_deposit`).
3.  **API 调用**: `POST /api/deposit/delete` payload `{ pmt_no: "..." }`.
4.  **UI 响应**: 成功后重新加载列表 (Reload List) 或局部更新行状态。

#### B. 恢复操作 (`restoreDeposit`)
1.  **确认弹窗**: "确定要恢复该记录吗？"
2.  **API 调用**: `POST /api/deposit/undelete` payload `{ pmt_no: "..." }`.
    *   *Note*: 恢复通常不需要密码，或者使用低级别密码验证。

---

## 3. 后端实现逻辑 (Backend Logic)

**参考架构**: [采购模块数据流程深度审计 V2](../safety/流程.md)

### 3.1 核心数据模型

*   **日志表 (`in_pmt_deposit`)**: 记录每一次操作 (`new`, `adjust`, `delete`)。
    *   `pmt_no`: 唯一标识。
    *   `ops`: 操作类型 (注意：不同模块字段名可能不同，如 `action`, `type`，请根据实际表结构会意)。
    *   `seq`: 版本序列号 (注意：字段名可能是 `version`, `sequence` 等，遵循版本递增逻辑即可)。
*   **终态表 (`in_pmt_deposit_final`)**: 仅存储最新有效状态。
    *   **触发器同步**: 
        *   `ops='new'/'adjust'` -> `REPLACE INTO final`.
        *   `ops='delete'` -> `DELETE FROM final`.

### 3.2 删除接口 (`deposit_delete_api`)

1.  **权限校验**: `check_perm(...)`.
2.  **参数提取**: `pmt_no`.
3.  **查询当前状态**: 
    *   验证 `in_pmt_deposit_final` 中是否存在（即是否处于有效状态）。
    *   获取当前最大 `seq` (e.g., `D03`).
4.  **执行软删除**:
    *   **INSERT into `in_pmt_deposit`**:
        *   `pmt_no`: 原单号.
        *   `ops`: **'delete'**.
        *   `seq`: **'D04'** (Max + 1).
        *   `dep_paid`: 0.
        *   `note`: `删除操作_用户_时间`.
    *   **关联处理**: 如果有关联的预付款记录 (`in_pmt_prepay`)，也需要追加对应的冲销记录 (Negative Entry or Delete Action)。
5.  **触发器行为**: 数据库触发器检测到 `ops='delete'`，自动从 `final` 表物理删除该行。
6.  **返回**: `{ success: true }`.

### 3.3 恢复接口 (`deposit_restore_api`)

1.  **查找回溯点**:
    *   查询日志表 `in_pmt_deposit` where `pmt_no=X` order by `seq` DESC.
    *   找到最近一条 `ops != 'delete'` 的记录 (Target Record).
2.  **获取新版本号**: Max Seq + 1 (e.g., `D05`).
3.  **执行恢复**:
    *   **INSERT into `in_pmt_deposit`**:
        *   复制 Target Record 的所有业务字段 (`dep_paid`, `dep_cur`, etc.).
        *   `ops`: **'new'** (或 'restore').
        *   `seq`: **'D05'**.
        *   `note`: `恢复操作_用户_时间`.
    *   **关联处理**: 如果需要，恢复关联的预付款记录。
4.  **触发器行为**: 数据库触发器检测到 `ops='new'`，自动将数据重新插入 `final` 表。
5.  **返回**: `{ success: true }`.

---

## 4. 复用指南 (Reusability Guide)

在其他模块（如 "发货单删除"）复用此模式：

1.  **数据库准备**: 确保存在 `_final` 表和同步触发器（Trigger Logic: `delete` -> `DELETE FROM final`）。
2.  **序列号管理**: 必须实现严谨的 `seq` 递增逻辑（Python端计算或DB端计算）。
3.  **Action Key**: 注册新的安全动作（如 `btn_send_delete`）。
4.  **UI 状态**: 前端列表需要支持显示 "已删除" 状态的数据（通常默认过滤掉，需要 Toggle switch "Show Deleted" 才能看到，或者在 History View 中看到）。

---

## 5. 关键业务规则

1.  **Sequence Integrity**: 即使是删除操作，也必须消耗一个版本号 (`seq`)，确保审计轨迹连续。
2.  **Data Preservation**: 删除**绝不**物理删除日志表数据，只做追加。
3.  **Cascading**: 主表删除时，必须考虑关联子表的处理（如：删除定金单 -> 同时释放预付款额度）。
4.  **Idempotency**: 重复点击删除应被拦截（检查 Final 表是否存在）。
