# 上传/替换账单文件按钮与向导功能 (Order Management File Upload)

> **Purpose**: 本文档作为「采购订单管理 - 上传/替换账单文件」功能的标准工程参考。重点解析与“上传按钮”交互触发的完整业务流程，包括 Wizard 交互、前端校验、后端版本控制与安全落盘。
> **Scope**: 适用于任何需要实现类似“上传并版本化存储”功能的业务模块（如 Logistical Invoices, Warehouse Receipts）。

---

## 1. 功能概述

此功能通过一个 **"上传/替换账单" (Upload/Replace Invoice)** 按钮触发，旨在解决以下工程问题：
1.  **版本迭代**: 允许用户对同一订单多次上传文件，系统自动维护 `Ver01`, `Ver02` 递增版本。
2.  **操作原子性**: 使用模态向导 (Wizard) 将操作锁定在 Step 1-2-3 流程中，防止误操作。
3.  **安全管控**: 结合密码策略 (Security Policy) 保护写入操作。

---

## 2. 前端实现逻辑 (Component Flow)

### 2.1 触发入口 (The Trigger)

我们在订单列表或详情页放置按钮，点击调用 `uploadInvoice(poNum)`。

```html
<!-- 示例按钮 -->
<button class="btn btn-sm btn-outline-warning" onclick="uploadInvoice('{{ po.po_num }}')">
    <i class="fas fa-file-upload me-1"></i>账单
</button>
```

### 2.2 核心函数: `uploadInvoice(poNum)`

此函数负责构建并显示模态向导 (Wizard)。不使用预定义的静态 Modal，而是**动态注入 DOM**，保证每次打开都是干净的状态。

**文件参考**: `backend/templates/purchase/pages/po_mgmt.html` (Lines ~911)

#### 流程步骤 (Wizard Steps):

1.  **Step 1: 选择文件 (Select)**
    *   **组件**: 使用 `GlobalFileUpload` (Standard Dropzone)。
    *   **校验**: 前端检查文件类型 (`.pdf`, `.jpg`, etc.) 和大小 (<20MB)。
    *   **用户动作**: 拖拽文件 -> 验证通过 -> 点击"下一步"。

2.  **Step 2: 确认与版本预测 (Confirm & Versioning)**
    *   **核心逻辑**: 
        *   显示文件名、大小。
        *   **异步检查 (Check Existing)**: 调用 `get_invoice_info_api` 检查服务器上是否已有文件。
        *   **版本计算**: 如果 API 返回 `has_file=true`，前端解析现有最大版本号 `maxVer`，并显示目标版本为 `Ver(maxVer + 1)`。否则显示 `Ver01`。
        *   **安全提示**: 提示"上传需要密码验证"。
    *   **用户动作**: 点击"确认上传"。

3.  **Step 3: 安全验证与提交 (Secure Submit)**
    *   **触发**: `invoiceUploadConfirm()`
    *   **拦截**: 调用 `requestPasswordVerify('btn_po_upload_invoice', ...)`。
    *   **回调**: 验证通过后，执行 `executeInvoiceUpload(passwords)`。
    *   **结果**:
        *   成功: 显示绿色打钩动画，从后端返回最终文件名。
        *   失败: 显示错误信息并允许重试。

### 2.3 关键代码片段 (Implementation Patterns)

**A. 动态版本号计算 (Frontend Header Prediction)**:

```javascript
// Step 2 Enter Hook
fetch(`/api/invoice_info?po_num=${poNum}`)
    .then(r => r.json())
    .then(data => {
        if (data.has_file) {
            // 正则提取最大版本号
            // 假设文件名格式: {po}_invoice_Ver05.pdf
            const maxVer = data.files.reduce((max, f) => {
                const match = f.filename.match(/_Ver(\d+)/); 
                return match ? Math.max(max, parseInt(match[1])) : max;
            }, 0);
            
            // 预测下一个版本
            dom.targetVersion.textContent = `Ver${String(maxVer + 1).padStart(2, '0')}`;
            dom.warningMsg.show(); 
        } else {
            dom.targetVersion.textContent = 'Ver01';
        }
    });
```

**B. 安全提交 (Password Integration)**:

```javascript
/* 引用: aid/safety/密码策略.md */
function invoiceUploadConfirm() {
    requestPasswordVerify(
        'btn_po_upload_invoice',  // Action Key (Must be registered)
        (passwords) => executeInvoiceUpload(passwords), // Success Callback
        null,                     // Cancel Callback
        '上传账单文件'              // Context Description
    );
}

function executeInvoiceUpload(passwords) {
    const formData = new FormData();
    formData.append('invoice_file', file);
    // 注入密码
    for (const [k, v] of Object.entries(passwords)) {
        formData.append(`sec_code_${k}`, v);
    }
    // Fetch POST ...
}
```

---

## 3. 后端实现逻辑 (Backend Handling)

**文件参考**: `backend/apps/purchase/views/po_mgmt/invoice.py`

### 3.1 API 接口规范

*   **URL**: `/api/po_mgmt/upload_invoice/`
*   **Method**: `POST`
*   **Permissions**: `module.purchase.po.mgmt` (参考 `aid/module/模块权限.md`)

### 3.2 核心处理流程

1.  **参数提取**: 获取 `po_num` 和 `file_obj`。
2.  **安全屏障**:
    *   **权限**: `check_perm` 确保有写入权。
    *   **密码策略**: `SecurityPolicyManager.verify_action_request` (如果配置了后端强制校验)。当前实现主要依赖前端拦截，但也可能在后端 SDK 中校验。
3.  **计算存储路径**:
    *   规则: `data/records/purchase/po/{YYYY}/{supplier_code}/`
    *   参考: `aid/system/文件存储规范.md` (规范 #2.2)。
4.  **原子版本控制 (Atomic Versioning)**:
    *   后端**不信任**前端传递的版本号。
    *   重新扫描目录 `glob(f"{po_num}_invoice_V*")`。
    *   计算 `next_version = max(existing_versions) + 1`。
    *   生成最终文件名: `{po_num}_invoice_V{next_version}.{ext}`。
5.  **落盘**: `store_file(path, content)`。
6.  **响应**: 返回 `{ success: true, filename: "..." }` 供前端 Confirm 页面显示。

### 3.3 数据一致性 (Integrity)

*   **不覆盖**: 永远不覆盖旧文件，只追加新版本。
*   **无数据库记录**: 注意，此功能**没有**在该步骤往数据库插入记录（Databaseless File System）。文件的存在本身就是记录。前端通过 `glob` 查询来感知文件状态。
    *   *Note*: 某些高级模块（如定金支付）可能会在 `in_pmt_` 表里记录，但 Invoice 系统采用文件系统作为 Source of Truth。

---

## 4. 复用指南 (Reusability Guide)

若要在其他模块（如 "入库单上传"）复用此模式，请遵循以下步骤：

1.  **定义 Action Key**: 在 `action_registry.json` 添加新 Key（如 `btn_receive_upload`）。
2.  **遵循存储规范**: 在后端实现时，必须引入 `settings.py` 中的 `RECORDS_DIR` 并在 `aid/system/文件存储规范.md` 中注册新路径。
3.  **复制 Wizard 逻辑**: 从 `po_mgmt.html` 复制 `uploadInvoice` JS 函数，修改：
    *   `containerId`
    *   `title`
    *   API Endpoint (`url`)
    *   Action Key
4.  **后端实现**: 复制 `invoice.py` 逻辑，修改目录计算方式。

此模式确保了全系统文件操作体验的一致性，同时严格遵守安全和审计要求。
