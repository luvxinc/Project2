<!-- Three.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    THREE.OrbitControls = function (object, domElement) {
        this.object = object; this.domElement = domElement; this.target = new THREE.Vector3();
        this.minDistance = 5; this.maxDistance = 50;
        var scope = this, spherical = new THREE.Spherical(), sphericalDelta = new THREE.Spherical();
        var scale = 1, rotateStart = new THREE.Vector2(), state = -1;
        this.update = function () {
            var offset = new THREE.Vector3();
            offset.copy(scope.object.position).sub(scope.target);
            spherical.setFromVector3(offset);
            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;
            spherical.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, spherical.phi));
            spherical.radius *= scale;
            spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
            offset.setFromSpherical(spherical);
            scope.object.position.copy(scope.target).add(offset);
            scope.object.lookAt(scope.target);
            sphericalDelta.theta *= 0.9; sphericalDelta.phi *= 0.9; scale = 1;
        };
        domElement.addEventListener('mousedown', e => { rotateStart.set(e.clientX, e.clientY); state = 0; });
        domElement.addEventListener('mousemove', e => { if (state !== 0) return; sphericalDelta.theta -= (e.clientX - rotateStart.x) * 0.01; sphericalDelta.phi -= (e.clientY - rotateStart.y) * 0.01; rotateStart.set(e.clientX, e.clientY); });
        domElement.addEventListener('mouseup', () => state = -1);
        domElement.addEventListener('mouseleave', () => state = -1);
        domElement.addEventListener('wheel', e => { e.preventDefault(); scale *= e.deltaY > 0 ? 1.1 : 0.9; }, { passive: false });
    };
</script>

<script>
    /* ============================================
       Warehouse Shelf Codes - Ê≠£Á°ÆÁöÑË¥ßÊû∂ÊñπÂêë
       
       ‰øØËßÜÂõæ:
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ  ‚Üê 1Ë∑® (ÂêéÂ¢ô)
       ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ  ‚Üê 2Ë∑®  
       ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ  ‚Üê 3Ë∑® (Èù†ÂÖ•Âè£)
       ‚îÇ   L   Ëµ∞ÈÅì  R    ‚îÇ
       ‚îÇ       ÂÖ•Âè£       ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       
       Ë¥ßÊû∂ÔºöÈïøËæπÊúùËµ∞ÈÅì(XÊñπÂêëÂ§ß)ÔºåÁü≠ËæπÁ∫µÂêëÊéíÂàó(ZÊñπÂêëÂ∞è)
       ============================================ */





    // Note: loadWarehouses and renderWarehouseList are defined below (after ShelfLogic)

    function init3DScene(containerId, whData) {
        const container = document.getElementById(containerId);
        if (!container || !THREE) return;

        container.innerHTML = '';

        // Ëé∑ÂèñÂÆπÂô®Á≤æÁ°ÆÂ∞∫ÂØ∏ÔºåÈÅøÂÖçÂÆΩÈ´òÊØîÂ§±Áúü
        const rect = container.getBoundingClientRect();
        let width = rect.width;
        let height = rect.height;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1d24);

        const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
        camera.position.set(0, 15, 18); // Ë∞ÉÊï¥ËßÜËßí‰ª•ÈÄÇÂ∫îÁ´ñÂ±è
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio); // ‰ºòÂåñÈ´òÂàÜÂ±èÊ∏ÖÊô∞Â∫¶
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // Ëá™Âä®ÈáçÁΩÆÂ∞∫ÂØ∏ÔºåÈò≤Ê≠¢Êãâ‰º∏Êâ≠Êõ≤
        const onResize = () => {
            const newRect = container.getBoundingClientRect();
            camera.aspect = newRect.width / newRect.height;
            camera.updateProjectionMatrix();
            renderer.setSize(newRect.width, newRect.height);
        };
        window.addEventListener('resize', onResize);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 15, 10);
        scene.add(dirLight);

        // ËÆ°ÁÆóÂêÑÊéíË∑®Êï∞
        const aisles = whData?.aisles || {};
        const hasL = !!aisles['L'], hasR = !!aisles['R'];
        const bayCountL = hasL ? Object.keys(aisles['L'].bays || {}).length : 0;
        const bayCountR = hasR ? Object.keys(aisles['R'].bays || {}).length : 0;
        const maxBays = Math.max(bayCountL, bayCountR, 1);

        // ‰ªìÂ∫ìÂ∞∫ÂØ∏ÔºàÁ´ñÈïøÂûãÔºâ
        const whWidth = 10;  // XÊñπÂêëÔºàÁü≠ËæπÔºâ
        const walkwayWidth = 2.0;
        const entranceDepth = 2.0;

        // ÂÖ≥ÈîÆÔºöË¥ßÊû∂Â∞∫ÂØ∏Ë∞ÉÊï¥ - Êª°Ë∂≥"ÈïøËæπÊå®ÁùÄ‰ªìÂ∫ìËµ∞ÈÅìÔºå‰∏îÈïøËæπË¶ÅÂæàÈïø"
        // shelfWidth: XÊñπÂêë (‰ªéÂ¢ôÂà∞Ëµ∞ÈÅìÁöÑÊ∑±Â∫¶ÔºåËæÉÁ™Ñ)
        // shelfDepth: ZÊñπÂêë (Ê≤øÁùÄËµ∞ÈÅìÁöÑÈïøÂ∫¶ÔºåËÆæ‰∏∫ÂæàÈïø)
        const shelfWidth = (whWidth - walkwayWidth) / 2 - 0.2;  // Ê≠§Â§ÑWidthÊåáXËΩ¥ÊñπÂêëÂÆΩÂ∫¶ÔºåÂ°´Êª°‰∏§‰æß
        const shelfDepth = 6.0;   // Ê≠§Â§ÑDepthÊåáZËΩ¥ÊñπÂêëÈïøÂ∫¶ÔºåË∞ÉÊï¥‰∏∫8Á±≥ (Âéü12Á±≥)Ôºå‰øùÊåÅÈïøËæπ‰ΩÜÁº©Áü≠ÊÄªÈïø
        const shelfGap = 0.5;      // Ë∑®Èó¥Èöô
        const shelfHeight = 1.0;

        // Ë¥ßÊû∂Âå∫ÂüüÂç†Êª°‰ªìÂ∫ìÁ∫µÂêëÔºà‰ª•ÊúÄÂ§öË∑®ÁöÑ‰∏Ä‰æß‰∏∫Âü∫ÂáÜÔºå‰∏çÁïôÁôΩÔºâ
        // ‰ªéÊ≠§Â§ÑËÆ°ÁÆóÊÄªÊ∑±ÔºåÁ°Æ‰øù‰ªéÊúÄÊ∑±Â§ÑÈ°∂Âà∞ÂÖ•Â∫ì‰æß
        const shelfZoneLength = maxBays * shelfDepth + Math.max(0, maxBays - 1) * shelfGap;
        const whDepth = shelfZoneLength + entranceDepth; // Á¥ßÂáëÂåÖË£π

        //ÂêéÂ¢ô‰ΩçÁΩÆ (ZËΩ¥Ë¥üÊñπÂêë‰∏∫Ê∑±Â§Ñ)
        const backWallZ = -whDepth / 2;
        // Ëµ∑ÂßãZÔºöÁ¥ßË¥¥ÂêéÂ¢ô (Ê≥®ÊÑèÔºöBoxÂá†‰Ωï‰∏≠ÂøÉÈúÄË¶ÅÂÅèÁßª‰∏ÄÂçäÈïøÂ∫¶)
        const shelfStartZ = backWallZ + shelfDepth / 2;

        // Âú∞Êùø
        scene.add(createBox(whWidth, 0.2, whDepth, 0x2a3540, 0, -0.1, 0));

        // ËæπÊ°Ü
        const border = new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.BoxGeometry(whWidth, 0.5, whDepth)),
            new THREE.LineBasicMaterial({ color: 0x4a90d9 })
        );
        border.position.set(0, 0.25, 0);
        scene.add(border);

        // Ëµ∞ÈÅì (Ë¥ØÁ©ø)
        scene.add(createBox(walkwayWidth, 0.02, whDepth, 0x5a5a4a, 0, 0.02, 0));
        createLabel(scene, (window.i18n?.t('js.aisle') || 'Aisle'), 0, 1, 0, 0xffff00);

        // ÂÖ•Âè£ (Âú®ZÊ≠£ÊñπÂêëÁ´ØÂ§¥)
        // ÂÖ•Âè£Âå∫ÂüüÊîæÂú® whDepth/2 Â§Ñ
        const entryZ = whDepth / 2 - entranceDepth / 2;
        scene.add(createBox(whWidth / 2, 0.15, entranceDepth * 0.8, 0x6aaf6a, 0, 0.08, entryZ));
        createLabel(scene, (window.i18n?.t('js.entry') || 'Entry'), 0, 0.8, entryZ, 0x00ff00);

        // Ë¥ßÊû∂X‰ΩçÁΩÆÔºöË¥¥Â∑¶Âè≥Â¢ô
        // shelfWidth ÊòØXÊñπÂêëÂ∞∫ÂØ∏„ÄÇ‰∏≠ÂøÉÁÇπÂÅèÁßª = (whWidth/2) - (wingWidth/2)
        // wingWidth ~= shelfWidth.
        const xL = -(whWidth / 2 - shelfWidth / 2 - 0.1);
        const xR = (whWidth / 2 - shelfWidth / 2 - 0.1);

        // Ê†áÁ≠æ‰ΩçÁΩÆÔºöÊîæÂà∞ÊúÄÂâçÈù¢ (ÂíåÂÖ•Âè£ZËΩ¥‰ΩçÁΩÆ‰∏ÄËá¥)
        const labelZ = whDepth / 2;

        if (hasL) {
            createAisle(scene, aisles['L'], xL, shelfStartZ, shelfWidth, shelfDepth, shelfHeight, shelfGap, 'L');
            // LÊéíÊ†áÊ≥®
            createLabel(scene, 'Aisle: L', xL, 3.0, labelZ, 0xffffff, 0.9);
        }
        if (hasR) {
            createAisle(scene, aisles['R'], xR, shelfStartZ, shelfWidth, shelfDepth, shelfHeight, shelfGap, 'R');
            // RÊéíÊ†áÊ≥®
            createLabel(scene, 'Aisle: R', xR, 3.0, labelZ, 0xffffff, 0.9);
        }

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
        animate();
    }

    function createBox(w, h, d, color, x, y, z) {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshLambertMaterial({ color }));
        mesh.position.set(x, y, z);
        return mesh;
    }

    function createAisle(scene, aisleData, xPos, startZ, w, d, h, gap, side) {
        const bays = aisleData.bays || {};
        const bayNums = Object.keys(bays).sort((a, b) => parseInt(a) - parseInt(b));

        // ‰ªéÂêéÂ¢ôÂºÄÂßãÔºå1Ë∑®Âú®ÊúÄÂÜÖ‰æß
        bayNums.forEach((bayNum, idx) => {
            const zPos = startZ + idx * (d + gap);
            createBay(scene, bays[bayNum], xPos, zPos, bayNum, w, d, h, side);
        });
    }

    function createBay(scene, bayData, x, z, bayNum, w, d, h, side) {
        if (!bayData) return;
        const levels = bayData.levels || {};
        const order = ['G', 'M', 'T'];

        // Gap constant for visual separation
        const smallGap = 0.05;

        let y = h / 2 + 0.1;
        order.forEach(level => {
            if (levels[level]) {
                const lData = levels[level];
                const bins = lData.bins ? Object.keys(lData.bins).sort() : [];
                const baseColor = LEVEL_COLORS[level] || 0xcccccc;

                // Geometry Split Logic
                if (bins.length === 0) {
                    // Case A: Whole Level
                    createBlock(scene, w, h, d, x, y, z, baseColor);
                } else {
                    // Case B: Split by Bins (Z-axis)
                    const binDepth = d / bins.length;
                    const startZ_Level = z - d / 2;

                    bins.forEach((binKey, bIdx) => {
                        const binNode = lData.bins[binKey];
                        const slots = binNode.slots ? binNode.slots : [];

                        const binZCenter = startZ_Level + (bIdx * binDepth) + (binDepth / 2);
                        const binZStart = startZ_Level + (bIdx * binDepth);

                        if (slots.length === 0) {
                            createBlock(scene, w, h, binDepth - smallGap, x, y, binZCenter, baseColor);
                        } else {
                            // Case C: Split by Slots (Z-axis nested)
                            const slotDepth = binDepth / slots.length;
                            slots.forEach((slotKey, sIdx) => {
                                const slotZCenter = binZStart + (sIdx * slotDepth) + (slotDepth / 2);
                                createBlock(scene, w, h, slotDepth - smallGap, x, y, slotZCenter, baseColor);
                            });
                        }
                    });
                }
                y += h + 0.1;
            }
        });

        // --- Original Label Logic Preserved (Positioning based on Center of Bay) ---

        // Ë∑®Âè∑
        createLabel(scene, `Bay: ${bayNum}`, x, y + 0.2, z, 0xffffff, 0.6);

        // Â∑¶Âè≥‰ΩçÁΩÆÂÅèÁßª
        const zOffsetInside = d / 2 - 0.5; // ÊîæÂú®È°∂ÈÉ®ÂÜÖÈÉ® (L/R)

        // 1. È°∂ÈÉ®Â∫ì‰ΩçÂè∑ (Bin L/R)
        let zL_Bin, zR_Bin;
        if (side === 'L') {
            zL_Bin = z + zOffsetInside;
            zR_Bin = z - zOffsetInside;
        } else {
            zL_Bin = z - zOffsetInside;
            zR_Bin = z + zOffsetInside;
        }
        createLabel(scene, 'Bin: L', x, y + 0.5, zL_Bin, 0x00ffff, 0.5);
        createLabel(scene, 'Bin: R', x, y + 0.5, zR_Bin, 0xff00ff, 0.5);

        // 2. ‰æßÈù¢Ê†º‰ΩçÂè∑ (1/2) - Only show if slots exist
        let hasSlots = false;
        try {
            if (bayData.slot_count !== undefined) {
                hasSlots = bayData.slot_count > 0;
            } else if (bayData.levels) {
                Object.values(bayData.levels).forEach(lvl => {
                    if (lvl && lvl.bins) {
                        Object.values(lvl.bins).forEach(bin => {
                            if (bin && bin.slots && bin.slots.length > 0) hasSlots = true;
                        });
                    }
                });
            }
        } catch (e) { console.error('Slot check error:', e); }

        if (hasSlots) {
            const xOffset = w / 2 + 0.6;
            const labelX = (side === 'L') ? (x - xOffset) : (x + xOffset);
            const midY = h * 1.5;
            const labels = ['Slot: L', 'Slot: R', 'Slot: L', 'Slot: R'];
            const step = d / 4;
            const halfStep = step / 2;

            labels.forEach((txt, idx) => {
                let posZ;
                if (side === 'L') {
                    posZ = (z + d / 2) - halfStep - (idx * step);
                } else {
                    posZ = (z - d / 2) + halfStep + (idx * step);
                }
                createLabel(scene, txt, labelX, midY, posZ, 0xffff00, 0.4);
            });
        }
    }

    function createBlock(scene, w, h, d, x, y, z, color) {
        const geo = new THREE.BoxGeometry(w, h, d);
        const cube = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ color: color }));
        cube.position.set(x, y, z);
        cube.castShadow = true;

        // Add wireframe for better visual separation
        const edges = new THREE.EdgesGeometry(geo);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 }));
        cube.add(line);

        scene.add(cube);
    }


    function createLabel(scene, text, x, y, z, color, scale = 1.2) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 256; canvas.height = 128;
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0, 0, 256, 128);
        ctx.font = 'bold 56px Arial';
        ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(text, 128, 64);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
        sprite.position.set(x, y, z);
        // Ë∞ÉÊï¥SpriteÂú®3DÁ©∫Èó¥ÁöÑÂ§ßÂ∞è
        sprite.scale.set(scale * 2.5, scale * 1.25, 1);
        scene.add(sprite);
    }

    const ShelfState = {
        warehouses: [],
        existingWhNums: new Set(),
        stats: {},
        config: { wh_num: '', aisles: {} },
        isEditMode: false,
        editWhNum: null
    };

    const LEVEL_COLORS = { 'G': 0x4CAF50, 'M': 0x2196F3, 'T': 0xFF9800 };
    let shelfGlobalWizard = null;
    let currentPreviewScene = null;

    document.addEventListener('DOMContentLoaded', function () {
        loadWarehouses();
        initEventListeners();
    });

    const ShelfLogic = {
        el(id) { return document.getElementById(id); }, // Helper for consistency

        updatePreview(forceResize = false) {
            this.collect();
            const previewData = this.genPreviewData();
            init3DScene('warehousePreview', { aisles: previewData });
            this.updateSummary();
        },

        updateSummary() {
            const summaryEl = this.el('configSummary');
            if (!summaryEl) return;

            let totalBays = 0, totalBins = 0, totalSlots = 0;
            Object.values(ShelfState.config.aisles).forEach(cfg => {
                if (cfg.custom_bays) {
                    Object.values(cfg.custom_bays).forEach(b => {
                        const lCount = b.levels.length;
                        totalBays++;
                        totalBins += (b.bin_count || 0) * lCount;
                        totalSlots += (b.slot_count || 0) * lCount;
                    });
                } else {
                    const lCount = cfg.levels.length;
                    totalBays += cfg.bay_count;
                    totalBins += (cfg.bin_count || 0) * lCount * cfg.bay_count;
                    totalSlots += (cfg.slot_count || 0) * lCount * cfg.bay_count;
                }
            });

            summaryEl.innerHTML = `
            <div class="d-flex gap-3 justify-content-center">
                <span><i class="fas fa-cubes me-1"></i>ÊÄªË∑®Êï∞: ${totalBays}</span>
                <span><i class="fas fa-box me-1"></i>ÊÄªÂ∫ì‰Ωç: ${totalBins}</span>
                <span><i class="fas fa-th me-1"></i>ÊÄªÊ†º‰Ωç: ${totalSlots}</span>
            </div>
        `;
        },

        toggleCustomMode(aisle) {
            const isCustom = this.el(`isCustom${aisle}`).checked;
            const uniformDiv = this.el(`uniformConfig${aisle}`);
            const customDiv = this.el(`customConfig${aisle}`);

            if (isCustom) {
                uniformDiv.classList.add('d-none');
                customDiv.classList.remove('d-none');
                this.renderBayList(aisle);
            } else {
                uniformDiv.classList.remove('d-none');
                customDiv.classList.add('d-none');
            }
            this.updatePreview();
        },

        handleLevelChange(aisle, type, level, bayIndex = null) {
            let elG, elM, elT;
            if (type === 'uniform') {
                elG = this.el(`levelG${aisle}`);
                elM = this.el(`levelM${aisle}`);
                elT = this.el(`levelT${aisle}`);
            } else {
                elG = this.el(`bayLevelG-${aisle}-${bayIndex}`);
                elM = this.el(`bayLevelM-${aisle}-${bayIndex}`);
                elT = this.el(`bayLevelT-${aisle}-${bayIndex}`);
            }

            if (!elG || !elM || !elT) return;

            // Enforce G -> M -> T dependency
            if (!elG.checked) {
                elM.checked = false; elM.disabled = true;
                elT.checked = false; elT.disabled = true;
            } else {
                elM.disabled = false;
                if (!elM.checked) {
                    elT.checked = false; elT.disabled = true;
                } else {
                    elT.disabled = false;
                }
            }
            this.updatePreview();
        },

        renderBayList(aisle) {
            const container = this.el(`bayList${aisle}`);
            const count = parseInt(this.el(`bayCount${aisle}`).value) || 1;
            container.innerHTML = '';

            const defG = this.el(`levelG${aisle}`).checked;
            const defM = this.el(`levelM${aisle}`).checked;
            const defT = this.el(`levelT${aisle}`).checked;
            const defBin = this.el(`binCount${aisle}`).value;
            const defSlot = this.el(`slotCount${aisle}`).value;

            for (let b = 1; b <= count; b++) {
                const html = `
                <div class="bay-config-item">
                    <div class=\"bay-title\">${b}${(window.i18n?.t('desc.d171') || 'Bay Config')}</div>
                    <div class="d-flex gap-3 mb-2">
                        <div class="d-flex align-items-center gap-2">
                            <small class="text-white-50" data-i18n="ui.text_388">Â±Ç:</small>
                            <label><input type="checkbox" id="bayLevelG-${aisle}-${b}" class="bay-level-check-${aisle}-${b}" value="G" ${defG ? 'checked' : ''} onchange="ShelfLogic.handleLevelChange('${aisle}', 'custom', 'G', ${b})"> G</label>
                            <label><input type="checkbox" id="bayLevelM-${aisle}-${b}" class="bay-level-check-${aisle}-${b}" value="M" ${defM ? 'checked' : ''} ${!defG ? 'disabled' : ''} onchange="ShelfLogic.handleLevelChange('${aisle}', 'custom', 'M', ${b})"> M</label>
                            <label><input type="checkbox" id="bayLevelT-${aisle}-${b}" class="bay-level-check-${aisle}-${b}" value="T" ${defT ? 'checked' : ''} ${!defM ? 'disabled' : ''} onchange="ShelfLogic.handleLevelChange('${aisle}', 'custom', 'T', ${b})"> T</label>
                        </div>
                    </div>
                    <div class="d-flex gap-3">
                        <div class="d-flex align-items-center gap-2">
                            <small class="text-white-50">Bin:</small>
                            <select class="form-select form-select-sm py-0 px-2" style="width:60px; height:24px;" id="bayBin-${aisle}-${b}" onchange="ShelfLogic.updatePreview()">
                                <option value="0" ${defBin == 0 ? 'selected' : ''}>0</option>
                                <option value="2" ${defBin == 2 ? 'selected' : ''}>2</option>
                            </select>
                        </div>
                        <div class="d-flex align-items-center gap-2">
                            <small class="text-white-50">Slot:</small>
                            <select class="form-select form-select-sm py-0 px-2" style="width:60px; height:24px;" id="baySlot-${aisle}-${b}" onchange="ShelfLogic.updatePreview()">
                                <option value="0" ${defSlot == 0 ? 'selected' : ''}>0</option>
                                <option value="2" ${defSlot == 2 ? 'selected' : ''}>2</option>
                            </select>
                        </div>
                    </div>
                </div>
            `;
                container.insertAdjacentHTML('beforeend', html);
            }
        },

        collect() {
            ShelfState.config.aisles = {};
            ['L', 'R'].forEach(a => {
                const enableEl = this.el(`enableAisle${a}`);
                if (!enableEl || !enableEl.checked) return;

                const bayCount = parseInt(this.el(`bayCount${a}`).value) || 3;
                const isCustom = this.el(`isCustom${a}`).checked;

                if (!isCustom) {
                    const levels = [];
                    ['G', 'M', 'T'].forEach(l => {
                        const lvlEl = this.el(`level${l}${a}`);
                        if (lvlEl && lvlEl.checked) levels.push(l);
                    });
                    if (levels.length === 0) return;

                    ShelfState.config.aisles[a] = {
                        bay_count: bayCount,
                        levels,
                        bin_count: parseInt(this.el(`binCount${a}`).value) || 0,
                        slot_count: parseInt(this.el(`slotCount${a}`).value) || 0
                    };
                } else {
                    const customBays = {};
                    for (let b = 1; b <= bayCount; b++) {
                        const levels = [];
                        document.querySelectorAll(`.bay-level-check-${a}-${b}:checked`).forEach(c => levels.push(c.value));
                        if (levels.length > 0) {
                            customBays[b] = {
                                levels,
                                bin_count: parseInt(this.el(`bayBin-${a}-${b}`).value) || 0,
                                slot_count: parseInt(this.el(`baySlot-${a}-${b}`).value) || 0
                            };
                        }
                    }
                    ShelfState.config.aisles[a] = {
                        bay_count: bayCount,
                        custom_bays: customBays
                    };
                }
            });
        },

        genPreviewData() {
            const result = {};
            // Helper to generate mock bin structure matching API format
            const genBins = (bCount, sCount) => {
                const bins = {};
                if (bCount > 0) {
                    const binKeys = bCount === 2 ? ['L', 'R'] : Array.from({ length: bCount }, (_, i) => (i + 1).toString());
                    binKeys.forEach(bk => {
                        const slots = [];
                        if (sCount > 0) {
                            const slotKeys = sCount === 2 ? ['L', 'R'] : Array.from({ length: sCount }, (_, i) => (i + 1).toString());
                            slots.push(...slotKeys);
                        }
                        bins[bk] = { slots };
                    });
                }
                return bins;
            };

            Object.entries(ShelfState.config.aisles).forEach(([a, cfg]) => {
                result[a] = { bays: {} };
                if (cfg.custom_bays) {
                    for (let b = 1; b <= cfg.bay_count; b++) {
                        const bayCfg = cfg.custom_bays[b];
                        if (bayCfg) {
                            const bCount = bayCfg.bin_count || 0;
                            const sCount = bayCfg.slot_count || 0;
                            result[a].bays[b] = {
                                levels: {},
                                slot_count: sCount,
                                bin_count: bCount
                            };
                            bayCfg.levels.forEach(l => {
                                result[a].bays[b].levels[l] = { bins: genBins(bCount, sCount) };
                            });
                        }
                    }
                } else {
                    const bCount = cfg.bin_count || 0;
                    const sCount = cfg.slot_count || 0;
                    for (let b = 1; b <= cfg.bay_count; b++) {
                        result[a].bays[b] = {
                            levels: {},
                            slot_count: sCount,
                            bin_count: bCount
                        };
                        cfg.levels.forEach(l => {
                            result[a].bays[b].levels[l] = { bins: genBins(bCount, sCount) };
                        });
                    }
                }
            });
            return result;
        }
    };

    // Alias for backward compatibility with HTML partial calls
    const ShelfWizard = ShelfLogic;

    function toggleAisleConfig(a, on) {
        const sec = document.getElementById(`aisleConfig${a}Section`);
        if (sec) sec.classList.toggle('disabled', !on);
        ShelfLogic.updatePreview();
    }

    function initEventListeners() {
        // 1. Wizard Buttons
        const btnNext = document.getElementById('btn-step1-next');
        if (btnNext) btnNext.addEventListener('click', () => shelfGlobalWizard.next());

        document.getElementById('btn-step2-back').addEventListener('click', () => shelfGlobalWizard.back());
        document.getElementById('btn-step2-submit').addEventListener('click', () => shelfGlobalWizard.next()); // Will trigger submitDesign

        // 2. Step 1 Input
        const inputWh = document.getElementById('inputWhNum');
        if (inputWh) {
            inputWh.addEventListener('input', e => {
                const val = e.target.value.trim().toUpperCase();
                e.target.value = val;

                const btnNext = document.getElementById('btn-step1-next');
                if (!val) {
                    e.target.classList.remove('is-invalid');
                    if (btnNext) btnNext.disabled = true;
                    ShelfState.config.wh_num = '';
                    return;
                }

                if (!ShelfState.isEditMode && ShelfState.existingWhNums.has(val)) {
                    e.target.classList.add('is-invalid');
                    if (btnNext) btnNext.disabled = true;
                } else {
                    e.target.classList.remove('is-invalid');
                    if (btnNext) btnNext.disabled = false;
                }
                ShelfState.config.wh_num = val;
            });
        }

        // 3. Aisle Configuration Listeners
        ['L', 'R'].forEach(a => {
            document.getElementById(`enableAisle${a}`).addEventListener('change', e => toggleAisleConfig(a, e.target.checked));
            document.getElementById(`bayCount${a}`).addEventListener('change', () => {
                if (document.getElementById(`isCustom${a}`).checked) {
                    ShelfLogic.renderBayList(a);
                } else {
                    ShelfLogic.updatePreview();
                }
            });
        });
    }

    const createWizardSteps = [
        { id: 'wh_num', label: (window.i18n?.t('js.warehouse_no') || 'Warehouse No'), contentSelector: '#step-wh-num' },
        { id: 'design', label: (window.i18n?.t('js.design_layout') || 'Design Layout'), contentSelector: '#step-design' },
        { id: 'done', label: (window.i18n?.t('js.complete') || 'Complete'), type: 'done', contentSelector: '#step-done' }
    ];

    const editWizardSteps = [
        { id: 'design', label: (window.i18n?.t('js.modify_design') || 'Modify Design'), contentSelector: '#step-design' },
        { id: 'done', label: (window.i18n?.t('js.complete') || 'Complete'), type: 'done', contentSelector: '#edit-step-done' }
    ];

    function startWizard() {
        startCreateWizard();
    }

    function startCreateWizard() {
        doStartWizard('create');
    }

    function startEditWizard(wh) {
        doStartWizard('edit', wh);
    }

    function doStartWizard(mode, wh = null) {
        const mainView = document.getElementById('main-view');
        const wizardView = document.getElementById('wizard-view');

        // Show Wizard
        if (mainView && wizardView) {
            mainView.classList.add('d-none');
            wizardView.classList.remove('d-none');
        }

        // Set State
        ShelfState.isEditMode = (mode === 'edit');
        ShelfState.editWhNum = wh;
        ShelfState.config.wh_num = wh || '';

        // Update UI based on Mode
        const btnSubmit = document.getElementById('btn-step2-submit');
        const btnBack = document.getElementById('btn-step2-back');
        const wizardHeader = document.querySelector('#add-shelf-wizard-container .wizard-header h5');
        const wizardSubtitle = document.querySelector('#add-shelf-wizard-container .wizard-header p');

        // Select steps based on mode
        const stepsToUse = (mode === 'edit') ? editWizardSteps : createWizardSteps;

        // Destroy and reinit wizard with correct steps
        if (shelfGlobalWizard) {
            shelfGlobalWizard.destroy();
            shelfGlobalWizard = null;
        }

        shelfGlobalWizard = new GlobalWizard({
            containerId: 'add-shelf-wizard-container',
            steps: stepsToUse,
            onStepChange: handleStepChange,
            onBeforeNext: handleBeforeNext,
            onRestart: () => cancelWizard()
        });

        if (mode === 'edit') {
            // Edit Mode
            if (wizardHeader) wizardHeader.textContent = (window.i18n?.t('js.modify_warehouse_design') || 'Modify Warehouse Design');
            if (wizardSubtitle) wizardSubtitle.textContent = `‰ªìÂ∫ì ${wh} - ÈáçÊñ∞ËÆæËÆ°Ë¥ßÊû∂Â∏ÉÂ±Ä`;
            if (btnSubmit) btnSubmit.innerHTML = '<i class="fas fa-save me-2"></i>‰øùÂ≠ò‰øÆÊîπ';
            if (btnBack) btnBack.classList.add('d-none'); // Edit mode has no "back"

            // Set preview wh num (locked, read-only display)
            const previewWhNum = document.getElementById('preview-wh-num');
            if (previewWhNum) previewWhNum.innerText = wh;

            // Hide Step 1 elements (‰ªìÂ∫ìÂè∑ËæìÂÖ• & ÂºÄÂßãËÆæËÆ°ÊåâÈíÆ)
            const stepWhNum = document.getElementById('step-wh-num');
            const btnStep1Next = document.getElementById('btn-step1-next');
            if (stepWhNum) stepWhNum.classList.add('d-none');
            if (btnStep1Next) btnStep1Next.classList.add('d-none');

            // Populate Data
            populateEditData(wh);

            // Show original config panels
            showOriginalConfig();

        } else {
            // Create Mode
            if (wizardHeader) wizardHeader.textContent = (window.i18n?.t('js.add_warehouse_wizard') || 'Add Warehouse Wizard');
            if (wizardSubtitle) wizardSubtitle.textContent = (window.i18n?.t('js.warehouse_layout_desc') || 'Plan warehouse layout, auto-generate shelves and bins.');
            if (btnSubmit) btnSubmit.innerHTML = '<i class="fas fa-check-circle me-2"></i>ÂÆåÊàêÂàõÂª∫';
            if (btnBack) btnBack.classList.remove('d-none');

            // Show Step 1 elements
            const stepWhNum = document.getElementById('step-wh-num');
            const btnStep1Next = document.getElementById('btn-step1-next');
            if (stepWhNum) stepWhNum.classList.remove('d-none');
            if (btnStep1Next) btnStep1Next.classList.remove('d-none');

            // Clear Step 1 input
            const input = document.getElementById('inputWhNum');
            if (input) {
                input.value = '';
                input.disabled = false;
                input.classList.remove('is-invalid');
            }
            document.getElementById('btn-step1-next').disabled = true;

            // Hide original config panels
            hideOriginalConfig();

            // Reset config
            resetLayoutToDefaults();
        }
    }

    function showOriginalConfig() {
        ['L', 'R'].forEach(side => {
            const el = document.getElementById(`originalConfig${side}`);
            if (el) el.classList.remove('d-none');
        });
    }

    function hideOriginalConfig() {
        ['L', 'R'].forEach(side => {
            const el = document.getElementById(`originalConfig${side}`);
            if (el) el.classList.add('d-none');
        });
    }

    function resetLayoutToDefaults() {
        // Reset to "Uniform" and default values
        ['L', 'R'].forEach(side => {
            document.getElementById(`enableAisle${side}`).checked = true;
            document.getElementById(`bayCount${side}`).value = 3;
            document.getElementById(`isCustom${side}`).checked = false;
            document.getElementById(`uniformConfig${side}`).classList.remove('d-none');
            document.getElementById(`customConfig${side}`).classList.add('d-none');
            ['G', 'M', 'T'].forEach(l => document.getElementById(`level${l}${side}`).checked = true);
            document.getElementById(`binCount${side}`).value = 0;
            document.getElementById(`slotCount${side}`).value = 0;
            toggleAisleConfig(side, true);
        });
        setTimeout(() => ShelfLogic.updatePreview(), 100);
    }

    function handleStepChange(from, to) {
        if (to.id === 'design') {
            const previewWhNum = document.getElementById('preview-wh-num');
            if (previewWhNum) previewWhNum.innerText = ShelfState.config.wh_num || 'WH??';

            setTimeout(() => {
                init3DScene('warehousePreview', { aisles: ShelfLogic.genPreviewData() });
            }, 100);
        }
    }

    async function handleBeforeNext(step) {
        if (step.id === 'wh_num') {
            const val = document.getElementById('inputWhNum').value.trim().toUpperCase();
            if (!val) { createAndShowToast((window.i18n?.t('js.enter_warehouse_no') || 'Enter Warehouse No'), 'warning'); return false; }
            if (ShelfState.existingWhNums.has(val)) { createAndShowToast((window.i18n?.t('js.warehouse_exists') || 'Warehouse No exists'), 'danger'); return false; }
            return true;
        }
        if (step.id === 'design') return await submitDesign();
        return true;
    }

    function cancelWizard() {
        document.getElementById('wizard-view').classList.add('d-none');
        document.getElementById('main-view').classList.remove('d-none');
        loadWarehouses();
    }

    async function submitDesign() {
        ShelfLogic.collect();
        const whNum = ShelfState.config.wh_num;

        // Check constraints... implementation same as before
        const aisles = Object.keys(ShelfState.config.aisles);
        if (aisles.length === 0) { createAndShowToast((window.i18n?.t('js.enable_at_least_one_row') || 'Enable at least one shelf row'), 'warning'); return false; }

        const payload = {
            action: ShelfState.isEditMode ? 'update' : 'create',
            wh_num: whNum,
            aisles: ShelfState.config.aisles
        };

        try {
            const res = await fetch('/dashboard/inventory/shelf/api/create/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': '{{ csrf_token }}' },
                body: JSON.stringify(payload)
            });
            const data = await res.json();
            if (data.success) {
                // Set correct result element based on mode
                if (ShelfState.isEditMode) {
                    const editResultEl = document.getElementById('edit-result-wh-num');
                    if (editResultEl) editResultEl.innerText = whNum;
                } else {
                    const createResultEl = document.getElementById('result-wh-num');
                    if (createResultEl) createResultEl.innerText = whNum;
                }
                return true;
            } else {
                createAndShowToast(data.message || (window.i18n?.t('toast.failed') || 'Failed'), 'danger');
                return false;
            }
        } catch (e) {
            console.error(e);
            return false;
        }
    }

    async function loadWarehouses() {
        try {
            const res = await fetch('/dashboard/inventory/shelf/api/list/');
            const data = await res.json();
            if (data.success) {
                ShelfState.warehouses = data.data.warehouses;
                ShelfState.existingWhNums = new Set(Object.keys(data.data.warehouses));
                ShelfState.stats = data.data.stats;
                renderWarehouseList();
            }
        } catch (e) { console.error('Load error:', e); }
    }

    function renderWarehouseList() {
        const container = document.getElementById('warehouseContainer');
        const empty = document.getElementById('emptyState');
        const whs = Object.keys(ShelfState.warehouses);

        if (whs.length === 0) { container.innerHTML = ''; empty.classList.remove('d-none'); return; }

        empty.classList.add('d-none');
        container.innerHTML = whs.map(wh => {
            const totalBays = ShelfState.stats[wh]?.total_bays || 0;
            const totalLocs = ShelfState.stats[wh]?.total_locations || 0;
            return `
        <div class="col-md-6">
            <div class="card bg-dark border-secondary h-100">
                <div class="card-body">
                    <div class="d-flex align-items-center mb-3">
                        <i class="fas fa-warehouse fa-2x text-primary me-3"></i>
                        <div>
                            <h5 class="card-title mb-0 text-white">${wh}</h5>
                            <small class="text-muted" data-i18n="ui.text_389">${totalBays} Ë∑® ‚Ä¢ ${totalLocs} Â∫ì‰Ωç</small>
                        </div>
                    </div>
                    <div class="threejs-container" id="scene-${wh}"></div>
                    <div class="legend-3d">
                        <div class="legend-item"><div class="legend-dot level-G"></div>GÂ±Ç</div>
                        <div class="legend-item"><div class="legend-dot level-M"></div>MÂ±Ç</div>
                        <div class="legend-item"><div class="legend-dot level-T"></div>TÂ±Ç</div>
                    </div>
                    <div class="controls-hint">üñ±Ô∏è ${(window.i18n?.t('desc.d172') || 'Drag to rotate | Scroll to zoom')}</div>
                    <div class="d-flex justify-content-between align-items-center mt-2">
                        <div class="warehouse-stats">
                            <div class="stat-item"><i class="fas fa-columns"></i>${ShelfState.stats[wh]?.aisle_count || 0}Êéí</div>
                            <div class="stat-item"><i class="fas fa-th-large"></i>${ShelfState.stats[wh]?.total_bays || 0}Ë∑®</div>
                            <div class="stat-item"><i class="fas fa-layer-group"></i>${ShelfState.stats[wh]?.total_levels || 0}Â±Ç</div>
                            <div class="stat-item"><i class="fas fa-map-marker-alt"></i>${ShelfState.stats[wh]?.total_locations || 0}‰Ωç</div>
                        </div>
                        <div class="d-flex gap-2 flex-shrink-0">
                            <button class="btn btn-outline-primary btn-sm" onclick="editWarehouse('${wh}')" data-i18n-title="tooltip.t7517" title="Modify Layout">
                                <i class="fas fa-edit me-1"></i>‰øÆÊîπ
                            </button>
                            <button class="btn btn-outline-danger btn-sm" onclick="deleteWarehouse('${wh}')" data-i18n-title="tooltip.t7982" title="Delete Warehouse">
                                <i class="fas fa-trash me-1"></i>Âà†Èô§
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>`;
        }).join('');

        // Init mini scenes
        whs.forEach(wh => {
            // We need to re-generate preview data for EACH warehouse based on its stored data.
            // Stored data is in ShelfState.warehouses[wh]
            // But createAisle expects a slightly different format (with x positions etc).
            // Actually init3DScene can handle it if we pass the data correctly.
            // For the list view, we need a separate "initMiniScene" or just reuse init3DScene with specific data.
            // Let's defer this complexity or just assume init3DScene works if we pass aisles.
            // ShelfState.warehouses[wh].aisles IS the correct format.
            setTimeout(() => init3DScene(`scene-${wh}`, { aisles: ShelfState.warehouses[wh].aisles }, true), 0);
        });
    }



    function editWarehouse(wh) {
        startEditWizard(wh);
    }

    function populateEditData(wh) {
        const data = ShelfState.warehouses[wh];
        if (!data) return;

        // Store original config for display
        ShelfState.originalConfig = JSON.parse(JSON.stringify(data.aisles || {}));

        ['L', 'R'].forEach(side => {
            const aisleData = data.aisles && data.aisles[side];
            const enableChk = document.getElementById(`enableAisle${side}`);
            const originalContentEl = document.getElementById(`originalConfigContent${side}`);

            if (!aisleData) {
                enableChk.checked = false;
                toggleAisleConfig(side, false);
                // Update original config display
                if (originalContentEl) {
                    originalContentEl.innerHTML = '<span class="text-muted" data-i18n="ui.text_390">Êú™ÂêØÁî®</span>';
                }
                return;
            }
            enableChk.checked = true;
            toggleAisleConfig(side, true);

            const bayKeys = Object.keys(aisleData.bays || {}).sort((a, b) => parseInt(a) - parseInt(b));
            document.getElementById(`bayCount${side}`).value = bayKeys.length;

            // Analyze Uniformity
            let isUniform = true;
            let firstBayCfg = null;

            const getBayCfg = (bData) => {
                const levels = Object.keys(bData.levels || {}).sort().join('');
                return {
                    levels,
                    binCount: bData.bin_count || 0,
                    slotCount: bData.slot_count || 0
                };
            };

            if (bayKeys.length > 0) {
                for (let i = 0; i < bayKeys.length; i++) {
                    const cfg = getBayCfg(aisleData.bays[bayKeys[i]]);
                    if (i === 0) firstBayCfg = cfg;
                    else if (cfg.levels !== firstBayCfg.levels || cfg.binCount !== firstBayCfg.binCount || cfg.slotCount !== firstBayCfg.slotCount) {
                        isUniform = false;
                        break;
                    }
                }
            } else {
                firstBayCfg = { levels: 'GMT', binCount: 0, slotCount: 0 };
            }

            // Populate original config display
            if (originalContentEl) {
                let originalHtml = `<div class="d-flex flex-wrap gap-2 align-items-center">`;
                originalHtml += `<span><i class="fas fa-columns me-1"></i>${bayKeys.length} Ë∑®</span>`;
                originalHtml += `<span class="text-secondary">|</span>`;
                originalHtml += `<span><i class="fas fa-layer-group me-1"></i>${firstBayCfg.levels || 'GMT'}</span>`;
                originalHtml += `<span class="text-secondary">|</span>`;
                originalHtml += `<span><i class="fas fa-box me-1"></i>Bin: ${firstBayCfg.binCount}</span>`;
                originalHtml += `<span class="text-secondary">|</span>`;
                originalHtml += `<span><i class="fas fa-th me-1"></i>Slot: ${firstBayCfg.slotCount}</span>`;
                if (!isUniform) {
                    originalHtml += `<span class="badge bg-warning text-dark ms-2" data-i18n="ui.text_391">ÊØèË∑®Áã¨Á´ã</span>`;
                }
                originalHtml += `</div>`;
                originalContentEl.innerHTML = originalHtml;
            }

            document.getElementById(`isCustom${side}`).checked = !isUniform;
            ShelfLogic.toggleCustomMode(side);

            ['G', 'M', 'T'].forEach(l => {
                document.getElementById(`level${l}${side}`).checked = firstBayCfg.levels.includes(l);
            });
            document.getElementById(`binCount${side}`).value = firstBayCfg.binCount;
            document.getElementById(`slotCount${side}`).value = firstBayCfg.slotCount;
            ShelfLogic.handleLevelChange(side, 'uniform', 'G');

            if (!isUniform) {
                // Populate custom
                ShelfLogic.renderBayList(side);
                bayKeys.forEach(b => {
                    const cfg = getBayCfg(aisleData.bays[b]);
                    ['G', 'M', 'T'].forEach(l => {
                        const el = document.getElementById(`bayLevel${l}-${side}-${b}`);
                        if (el) el.checked = cfg.levels.includes(l);
                    });
                    // Trigger change to update disabled states
                    ShelfLogic.handleLevelChange(side, 'custom', 'G', b);

                    document.getElementById(`bayBin-${side}-${b}`).value = cfg.binCount;
                    document.getElementById(`baySlot-${side}-${b}`).value = cfg.slotCount;
                });
            }
        });

        ShelfLogic.updatePreview();
    }

    function deleteWarehouse(wh) {
        if (typeof GlobalModal === 'undefined') {
            if (confirm('Delete ' + wh + '?')) executeDelete(wh);
            return;
        }
        GlobalModal.showConfirm({
            title: (window.i18n?.t('js.confirm_delete_warehouse') || 'Confirm Delete Warehouse'),
            message: (window.i18n?.t('js.confirm_delete_warehouse') || 'Confirm delete warehouse ') + wh + (window.i18n?.t('js.cannot_undo_suffix') || '? This cannot be undone.'),
            confirmStyle: 'danger',
            onConfirm: () => executeDelete(wh)
        });
    }

    async function executeDelete(wh) {
        try {
            const res = await fetch('/dashboard/inventory/shelf/api/delete/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': '{{ csrf_token }}' },
                body: JSON.stringify({ wh_num: wh })
            });
            loadWarehouses();
        } catch (e) { console.error(e); }
    }

</script>