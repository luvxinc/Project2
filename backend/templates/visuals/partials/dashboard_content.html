<div class="fade-in-up container-fluid p-4" style="animation-duration: 0.6s;">

    <!-- 1. Top Control Bar -->
    {% include 'visuals/partials/v2/control_bar.html' %}

    <!-- 2. Main Layout (Flexbox for custom width control) -->
    <div class="d-flex gap-3 align-items-stretch">

        <!-- Left: Filters (Narrrow Width ~220px) -->
        <div id="left-panel" style="width: 220px; flex-shrink: 0; display: flex; flex-direction: column;">
            {% include 'visuals/partials/v2/filter_panel.html' %}
        </div>

        <!-- ECharts CDN (must load before chart_area.html) -->
        <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>

        <div style="flex-grow: 1; min-width: 0; display: flex; flex-direction: column;">
            {% include 'visuals/partials/v2/chart_area.html' %}
        </div>

    </div>
</div>


<script>
    // --- Layout Helper ---
    function syncLayout() {
        // Ensure Right Chart Area height matches Left Panel Height
        const left = document.getElementById('left-panel');
        const viz = document.getElementById('viz-container');
        const echartsDom = document.getElementById('echarts-dom');
        const canvas = document.getElementById('sfx-canvas');

        if (left && viz) {
            // Get height of the card inside left panel
            const leftCard = left.querySelector('.card');
            if (leftCard) {
                const h = leftCard.offsetHeight;
                // Min height 600
                const targetH = Math.max(h, 600);

                viz.style.height = targetH + 'px';
                viz.style.minHeight = targetH + 'px';

                if (echartsDom) echartsDom.style.height = targetH + 'px';
                if (canvas) {
                    canvas.style.height = targetH + 'px';
                    // Resize canvas bitmap
                    const rect = viz.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = targetH;
                }

                if (window.app && window.app.chart) window.app.chart.resize();
            }
        }
    }

    // Perform sync on load and resize
    window.addEventListener('resize', syncLayout);
    // Also sync periodically in case of filter changes
    setInterval(syncLayout, 1000);

    // --- Main Controller ---
    window.app = {
        state: {
            chartType: 'line', // 'line' | 'pie'
            chartInstance: null
        },
        chart: null,
        pieEngine: null,
        sfx: null,

        init: function () {
            // Check session unlock status via DOM or just proceed (view handled it)
            this.pieEngine = new Pie3DEngine(
                document.getElementById('sfx-canvas'),
                document.getElementById('pie-overlay')
            );
            this.sfx = new LineSFXController();

            // Initial Layout Sync
            setTimeout(syncLayout, 100);

            this.refresh();
        },

        toggleChartType: function () {
            const toggle = document.getElementById('chart_type_switch');
            // Check state
            this.state.chartType = toggle.checked ? 'pie' : 'line';

            // UI State Update
            const filterOverlay = document.getElementById('filter-overlay');
            const isPie = this.state.chartType === 'pie';

            // 1. Filter Panel Overlay
            if (filterOverlay) filterOverlay.style.display = isPie ? 'block' : 'none';

            // 2. Mode Selector Disable
            document.querySelectorAll('input[name="view_mode"]').forEach(el => {
                el.disabled = isPie;
                const icon = el.nextElementSibling; // The label button
                if (icon) icon.classList.toggle('disabled', isPie);
                el.parentElement.style.opacity = isPie ? '0.5' : '1';
                el.parentElement.style.pointerEvents = isPie ? 'none' : 'auto';
            });

            if (isPie) {
                document.getElementById('mode_amount').checked = true;
                // app.refresh() called below
            }

            this.refresh();
        },

        getParams: function () {
            const modeEl = document.querySelector('input[name="view_mode"]:checked');
            const mode = modeEl ? modeEl.value : 'Amount';

            const start = document.getElementById('start_date').value;
            const end = document.getElementById('end_date').value;

            const stores = [];
            if (document.getElementById('store_esplus').checked) stores.push('esplus');
            if (document.getElementById('store_88').checked) stores.push('88');

            const actions = Array.from(document.querySelectorAll('input[name="action_filter"]:checked')).map(el => el.value);
            const ships = Array.from(document.querySelectorAll('input[name="ship_filter"]:checked')).map(el => el.value);
            const fees = Array.from(document.querySelectorAll('input[name="fee_filter"]:checked')).map(el => el.value);

            return { mode, start, end, stores, actions, ships, fees, type: this.state.chartType };
        },

        refresh: async function () {
            const params = this.getParams();
            if (params.stores.length === 0) {
                // Clear chart
                if (this.chart) this.chart.clear();
                this.sfx.stop();
                return;
            }

            // Sync layout before loading
            syncLayout();

            document.getElementById('chart-loader').classList.remove('d-none');

            try {
                const qs = new URLSearchParams();
                for (let k in params) {
                    if (Array.isArray(params[k])) params[k].forEach(v => qs.append(k + '[]', v));
                    else qs.append(k, params[k]);
                }

                const url = "{% url 'web_ui:sales:visuals:get_chart_data' %}?" + qs.toString();
                const res = await fetch(url);
                if (res.status === 403) { location.reload(); return; }

                const data = await res.json();

                // --- Reset Engines ---
                this.sfx.stop(); // Always stop Line SFX first

                if (this.state.chartType === 'pie') {
                    // Hide ECharts DOM (Line)
                    document.getElementById('echarts-dom').style.opacity = '0';
                    // Init Pie
                    if (data.pie_data) this.pieEngine.init(data.pie_data);
                } else {
                    // Show ECharts DOM
                    document.getElementById('echarts-dom').style.opacity = '1';
                    // Clear Pie 3D & Overlay
                    this.pieEngine.clear();
                    document.getElementById('pie-overlay').innerHTML = ''; // Double check clear
                    // Init Line
                    initLineChart(data, params.mode);
                }

            } catch (e) { console.error("Viz Error:", e); }
            finally { document.getElementById('chart-loader').classList.add('d-none'); }
        }
    };

    // --- Line SFX Engine ---
    class LineSFXController {
        constructor() {
            this.canvas = document.getElementById('sfx-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.animId = null;
            this.lines = [];
            this.streamers = [];
            this.particles = [];
            this.trendLine = null;
        }

        stop() {
            if (this.animId) cancelAnimationFrame(this.animId);
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.lines = []; this.streamers = []; this.particles = []; this.trendLine = null;
        }

        initLine(data, isSingle) {
            this.stop();
            // Need chart to be rendered first? Yes.
            // initLineChart sets option, then calls this.
            // ECharts needs a tick to calculate layout.
            // We use 'finished' event usually, or just a safe timeout.
            // initLineChart calls this with 100ms timeout already.

            if (!app.chart) return;
            const model = app.chart.getModel();
            if (!model) return;

            // Re-fetch canvas context just in case resized
            this.canvas.width = this.canvas.offsetWidth;
            this.canvas.height = this.canvas.offsetHeight;
            const groundY = this.canvas.height - 40;

            this.lines = [];

            data.series.forEach((s, idx) => {
                const sModel = model.getSeriesByIndex(idx);
                if (!sModel) return;
                const list = sModel.getData();
                const points = [];
                list.each((i) => {
                    const pt = app.chart.convertToPixel({ seriesIndex: idx }, [i, list.get('y', i)]);
                    // Check validity
                    if (pt && !isNaN(pt[0]) && !isNaN(pt[1])) points.push({ x: pt[0], y: pt[1] });
                });
                if (points.length < 2) return;

                this.lines.push({
                    points: points,
                    color: COLORS[idx % COLORS.length],
                    entryProgress: 0,
                    delayTimer: isSingle ? 0 : (Math.random() * 0.25 + 0.25),
                    finishedEntry: false,
                    isSingle: isSingle,
                    streamerTimer: 0
                });
            });

            // Trendline Logic (Simple Linear Reg)
            if (isSingle && this.lines.length > 0) {
                const pts = this.lines[0].points;
                if (pts.length > 1) {
                    let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0, n = pts.length;
                    pts.forEach(p => { sumX += p.x; sumY += p.y; sumXY += p.x * p.y; sumXX += p.x * p.x; });
                    const den = (n * sumXX - sumX * sumX);
                    if (Math.abs(den) > 0.001) {
                        const slope = (n * sumXY - sumX * sumY) / den;
                        const intercept = (sumY - slope * sumX) / n;
                        const p1 = { x: pts[0].x, y: slope * pts[0].x + intercept };
                        const p2 = { x: pts[n - 1].x, y: slope * pts[n - 1].x + intercept };

                        this.trendLine = {
                            p1: p1, p2: p2,
                            progress: 0, state: 'draw', timer: 0
                        };
                    }
                }
            }

            this.startLoop();
        }

        startLoop() {
            let last = performance.now();
            const loop = (now) => {
                const dt = Math.min((now - last) / 1000, 0.1);
                last = now;
                this.update(dt);
                this.animId = requestAnimationFrame(loop);
            };
            this.animId = requestAnimationFrame(loop);
        }

        update(dt) {
            const ctx = this.ctx;
            const W = this.canvas.width;
            const H = this.canvas.height;
            const groundY = H - 40; // Approx match ECharts grid bottom

            ctx.clearRect(0, 0, W, H);

            // Draw Lines
            this.lines.forEach(line => {
                if (line.delayTimer > 0) { line.delayTimer -= dt; return; }
                if (!line.finishedEntry) {
                    line.entryProgress += dt; // 1s visual entry
                    if (line.entryProgress >= 1) { line.entryProgress = 1; line.finishedEntry = true; }
                }

                this.drawPath(ctx, line.points, line.entryProgress, line.color, line.isSingle, groundY);

                // Draw Star Tip
                if (!line.finishedEntry) {
                    const tip = this.getPoint(line.points, line.entryProgress);
                    this.drawStar(ctx, tip.x, tip.y, line.color);
                }

                // Streamers
                if (line.finishedEntry) {
                    line.streamerTimer -= dt;
                    if (line.streamerTimer <= 0) {
                        this.streamers.push({ line: line, progress: 0, color: '#fff' });
                        line.streamerTimer = 2 + Math.random() * 2;
                    }
                }
            });

            // Streamers
            for (let i = this.streamers.length - 1; i >= 0; i--) {
                const s = this.streamers[i];
                s.progress += dt / 2.0; // Slow down to 2s
                if (s.progress >= 1) { this.streamers.splice(i, 1); continue; }

                const pos = this.getPoint(s.line.points, s.progress);

                // Brightness x3
                ctx.save();
                ctx.globalCompositeOperation = 'screen'; // Lighter blend
                ctx.shadowBlur = 20; ctx.shadowColor = '#fff'; ctx.fillStyle = '#fff';
                // Triple draw
                for (let k = 0; k < 3; k++) {
                    ctx.beginPath(); ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();

                if (Math.random() < 0.3) {
                    const maxDrop = Math.max(0, (groundY - pos.y) / 3);
                    this.particles.push({
                        x: pos.x, y: pos.y, vy: 100 + Math.random() * 100,
                        limitY: pos.y + maxDrop,
                        life: 0.5, color: s.line.color
                    });
                }
            }

            // Particles
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.life -= dt; p.y += p.vy * dt;
                if (p.life <= 0 || p.y >= p.limitY) { this.particles.splice(i, 1); continue; }
                ctx.globalAlpha = p.life / 0.5; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, Math.random() * 2 + 1, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1;
            }

            // Trend
            if (this.trendLine) {
                const t = this.trendLine;
                if (t.state === 'draw') { t.progress += dt / 0.75; if (t.progress >= 1) { t.progress = 1; t.state = 'wait1'; t.timer = 0.2; } }
                else if (t.state === 'wait1') { t.timer -= dt; if (t.timer <= 0) t.state = 'erase'; }
                else if (t.state === 'erase') { t.progress -= dt / 0.75; if (t.progress <= 0) { t.progress = 0; t.state = 'wait2'; t.timer = 0.2; } }
                else { t.timer -= dt; if (t.timer <= 0) t.state = 'draw'; }
                this.drawTrend(ctx, t);
            }
        }

        drawPath(ctx, points, prog, color, fill, groundY) {
            if (points.length < 2) return;
            const limit = (points.length - 1) * prog;
            const idx = Math.floor(limit);
            const extra = limit - idx;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);

            // Use smooth quadratic curves instead of straight lines
            for (let i = 1; i <= idx; i++) {
                const prev = points[i - 1];
                const curr = points[i];
                // Control point at midpoint for smooth curve
                const cpX = (prev.x + curr.x) / 2;
                const cpY = (prev.y + curr.y) / 2;

                if (i === 1) {
                    // First segment: line to first midpoint, then curve
                    ctx.quadraticCurveTo(prev.x, prev.y, cpX, cpY);
                } else {
                    // Middle segments: curve through control point
                    ctx.quadraticCurveTo(prev.x, prev.y, cpX, cpY);
                }
            }

            let tipX = points[idx].x, tipY = points[idx].y;

            if (idx < points.length - 1) {
                const pA = points[idx], pB = points[idx + 1];
                tipX = pA.x + (pB.x - pA.x) * extra;
                tipY = pA.y + (pB.y - pA.y) * extra;

                // Smooth curve to the animated tip
                const cpX = (pA.x + tipX) / 2;
                const cpY = (pA.y + tipY) / 2;
                ctx.quadraticCurveTo(pA.x, pA.y, tipX, tipY);
            } else if (idx > 0) {
                // End at the last point smoothly
                ctx.quadraticCurveTo(points[idx].x, points[idx].y, tipX, tipY);
            }

            ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.lineWidth = 3;
            ctx.strokeStyle = color; ctx.shadowBlur = 10; ctx.shadowColor = color;
            ctx.stroke(); ctx.shadowBlur = 0; ctx.lineWidth = 1;

            if (fill) {
                // Area fill needs to close path to ground
                ctx.lineTo(tipX, groundY);
                ctx.lineTo(points[0].x, groundY);
                ctx.closePath();
                const g = ctx.createLinearGradient(0, 0, 0, groundY);
                g.addColorStop(0, color.replace('rgb', 'rgba').replace(')', ',0.4)'));
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g; ctx.fill();
            }
        }

        drawStar(ctx, x, y, color) {
            ctx.save(); ctx.translate(x, y); ctx.rotate(performance.now() / 200);
            ctx.fillStyle = '#fff'; ctx.shadowBlur = 15; ctx.shadowColor = '#fff';
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * 6, Math.sin((18 + i * 72) / 180 * Math.PI) * 6);
                ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * 2, Math.sin((54 + i * 72) / 180 * Math.PI) * 2);
            }
            ctx.fill(); ctx.restore();
        }

        drawTrend(ctx, t) {
            let sP = 0, eP = 0;
            // Logic: Draw (0->1), Erase (Tail comes 0->1)
            // State Draw: Tail 0, Head Progress
            if (t.state === 'draw') { sP = 0; eP = t.progress; }
            // State Erase: Tail Progress, Head 1. But t.progress goes 1->0 in update logic above?
            // Let's check update: t.progress-=dt. So prog goes 1->0.
            // If we want Erase Left->Right, Tail needs to go 0->1.
            // So Tail = 1 - t.progress. Head = 1.
            else if (t.state === 'erase') { sP = 1 - t.progress; eP = 1; }
            else if (t.state === 'wait1') { sP = 0; eP = 1; }

            if (sP >= eP) return;

            const p1 = t.p1, p2 = t.p2;
            const sX = p1.x + (p2.x - p1.x) * sP; const sY = p1.y + (p2.y - p1.y) * sP;
            const eX = p1.x + (p2.x - p1.x) * eP; const eY = p1.y + (p2.y - p1.y) * eP;

            ctx.beginPath();
            ctx.setLineDash([8, 8]);
            ctx.moveTo(sX, sY); ctx.lineTo(eX, eY);
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke(); ctx.setLineDash([]);
        }

        getPoint(points, prog) {
            const limit = (points.length - 1) * prog;
            const idx = Math.floor(limit);
            const extra = limit - idx;
            if (idx >= points.length - 1) return points[points.length - 1];
            const pA = points[idx], pB = points[idx + 1];
            return { x: pA.x + (pB.x - pA.x) * extra, y: pA.y + (pB.y - pA.y) * extra };
        }
    }

    // Auto-initialization: works for both direct include and HTMX swap
    (function initVisuals() {
        // Check if ECharts is loaded
        if (typeof echarts === 'undefined') {
            // ECharts not loaded yet, retry after short delay
            setTimeout(initVisuals, 100);
            return;
        }

        // Check if DOM elements exist
        const sfxCanvas = document.getElementById('sfx-canvas');
        const echartsDom = document.getElementById('echarts-dom');

        if (!sfxCanvas || !echartsDom) {
            // DOM not ready, retry
            setTimeout(initVisuals, 100);
            return;
        }

        // Initialize app
        if (window.app && !window.app._initialized) {
            window.app._initialized = true;
            window.app.init();
            console.log('[Visuals] Chart auto-initialized');
        }
    })();
</script>