# 工程强制规则 (Engineering Rules)

> **状态**: 所有工程师必须遵守。违反 CRITICAL 规则 = 自动驳回。
> **来源**: ECC v1.5.0 Rules + 项目实践提炼
> **⚠️ 按需加载: 根据下方路由表跳到需要的 section, 不要全部阅读。**

## 路由表

| 关键词 | 跳转 |
|--------|------|
| `代码风格`, `命名`, `不可变` | → §1 代码风格 |
| `Git`, `commit`, `分支`, `conventional` | → §2 Git 纪律 + §2.1 Conventional Commits |
| `验证`, `测试`, `编译`, `lint` | → §5 验证循环 (集成测试门禁) |
| `影响分析`, `消费者`, `共享模块` | → §6 跨文件影响分析 + 共享模块追溯 |
| `React`, `Next.js`, `组件` | → §7 React/Next.js 规则 |
| `Spring`, `后端` | → §8 后端规则 |
| `拆分`, `复用`, `300行`, `新建文件` | → §9 代码拆分与复用 |
| `死循环`, `卡死`, `timeout`, `重试` | → §10 反死循环与终端安全执行 |
| `hooks`, `PreToolUse`, `PostToolUse`, `Stop`, `拦截` | → §10.4 Hooks 执行拦截 |
| `重构`, `迁移`, `等价`, `像素级审计` | → §11 重构保真门禁 |
| `Think`, `推理`, `停下来想`, `行动前`, `链式思考` | → §12 Think Discipline |
| `Token`, `编排`, `脚本处理`, `大数据`, `中间结果` | → §13 Token-Efficient Execution |
| `复盘`, `错误记录`, `ERROR-BOOK`, `交叉检查` | → §14 问题复盘铁律 |
| `性能`, `复杂度`, `O(n)`, `内存`, `分页` | → §15 性能意识 |
| `设计模式`, `Factory`, `DI`, `AOP`, `DTO` | → §16 设计模式优先 |

## 0. 变更边界铁律（scope-discipline）

### CRITICAL — 违反即驳回

| 规则 | 标准 |
|------|------|
| Strict Scope Rule | 仅修改用户明确提出范围；未提及内容禁止改动 |
| Minimal Change Rule | 仅做满足需求的最小变更；禁止顺手优化/重构 |
| Ask-First Rule | 若必须扩范围，先说明原因与文件清单并获批 |
| Unauthorized Extra Changes | 未获批超范围修改 = Block |

## 1. 代码风格 (coding-style)

### CRITICAL — 违反即驳回

| 规则 | 禁止 | 正确 |
|------|------|------|
| **不可变性** | `modify(original, field, value)` (原地修改) | `update(original, field, value)` (返回新副本) |
| **硬编码凭据** | 代码中写 API key/密码/token | 环境变量/配置文件 |
| **静默吞错** | `catch(e) {}` 空 catch | 记录详细上下文 + 友好消息 |
| **SQL 注入** | 字符串拼接 SQL | 参数化查询 / ORM |
| **日志泄密** | `console.log(password)` | 敏感字段脱敏 |

### HIGH — 必须修复后合并

| 规则 | 标准 |
|------|------|
| 文件行数 | 单文件 200-400 行 (典型), **≤600 行** (CRITICAL: >600 行必须拆分) |
| 函数行数 | 单函数 **≤50 行** |
| 嵌套深度 | **≤4 层**, 超过用早返回 |
| 输入验证 | 所有外部输入在**边界**验证 (Zod/class-validator) |
| 错误处理 | 每层显式处理, UI 给友好消息, 服务端记录详细上下文 |
| 死代码 | 注释代码/未用 import → **合并前删除** |
| Console.log | 调试用的 → **合并前删除** |

### 组织原则

```
✅ 按功能/领域组织, 非按类型
✅ 从大模块提取工具函数
✅ 高内聚低耦合
✅ 命名清晰: 变量描述内容, 函数描述动作
```

---

## 2. Git 工作流 (git-workflow)

| 规则 | 标准 |
|------|------|
| Commit 格式 | **Conventional Commits** — `type(scope): description` |
| Commit 粒度 | 一个逻辑变更 = 一个 commit |
| 分支策略 | feature/ → develop → main |
| 合并前 | 必须通过验证循环 6 阶段 |

### 2.1 Conventional Commits 类型

| type | 用途 |
|------|------|
| `feat` | 新功能 |
| `fix` | Bug 修复 |
| `docs` | 文档变更 |
| `style` | 格式调整（不影响逻辑） |
| `refactor` | 重构（不改功能、不修 Bug） |
| `test` | 测试相关 |
| `chore` | 构建/CI/依赖等杂务 |
| `perf` | 性能优化 |

格式：`type(scope): 简短描述`，scope 可选。示例：`feat(product): add barcode generation API`

---

## 3. 测试 (testing)

| 规则 | 标准 |
|------|------|
| 最低覆盖率 | **80%** |
| 三种测试 | Unit (单函数) + Integration (API/DB) + E2E (关键流) |

### TDD 强制流程

```
1. 写测试 (RED) → 应该失败
2. 写最小实现 (GREEN) → 应该通过
3. 重构 (IMPROVE) → 代码更好
4. 验证覆盖率 (80%+)
```

---

## 4. 安全 (security)

| 检查项 | 标准 |
|--------|------|
| XSS | 未转义用户输入 → 禁止渲染到 HTML |
| CSRF | 状态变更端点必须有 CSRF 保护 |
| 路径穿越 | 用户控制的文件路径必须清理 |
| 认证绕过 | 受保护路由必须有 Auth Guard |
| 不安全依赖 | 依赖安全检查（见 CONTEXT.md §5 安全命令）高危即修 |
| CORS | 必须配置白名单, 禁止 `*` |
| 限流 | 公开端点必须有 throttle |

---

## 5. 验证循环 (6 阶段 — 每次提交前必须完成)

| 阶段 | 命令（见 CONTEXT.md §5.2）| 通过标准 | 失败 |
|------|--------------------------|---------|------|
| 1. 编译 | `{build_cmd}` | BUILD SUCCESSFUL | **STOP** |
| 2. 类型 | `{typecheck_cmd}` | 零错误 | 修复 |
| 3. Lint | `{lint_cmd}` | 零错误 | 修复 |
| 4. 测试 | `{test_cmd}` | 全通过 | 修复 |
| 5. 覆盖率 | `{coverage_cmd}` | ≥80% | 补测试 |
| 6. 安全 | `{security_audit_cmd}` | 无高危 | 修复 |

**关键: 阶段 1 失败 = 后续全部 STOP, 不继续。**
**🔴 铁律: 集成测试 (阶段 4) 不通过 = 禁止提交完工报告, 发回工程师重做。(详见 `{project}/reference/iron-laws.md` §4)**

> **Token-Efficient (§13)**: 6 阶段验证应优先使用 `core/scripts/qa-gate.sh` 一次性编排, 避免逐阶段回到 Agent 浪费 Token。大型测试输出用脚本预处理后返回摘要。

### 验证失败重试协议

```
1. 修复失败的阶段
2. 从失败阶段开始重跑 (不需要全部重跑)
3. 最多重试 3 次/阶段
4. 3 次仍失败 → 停下来, 向用户报告:
   "ℹ️ 编译/测试遇到困难, 需要你的帮助:
    • 错误: {具体错误信息}
    • 已尝试: {3 次修复方案}
    • 建议: {Agent 的建议}"
```

### 5.2 循环触发规则（何时必须重跑验证循环）

| 触发条件 | 必须重跑的范围 |
|---------|-------------|
| 完成一个 Spec §4 步骤 | 从阶段 1 开始全量 |
| 任何文件被修改（不论大小） | 至少阶段 1-4 |
| 合并 / PR 提交前 | 全量（阶段 1-6） |
| 测试 PASS 后发现遗漏 | 全量 |

### 5.3 集成测试规则

| 规则 | 标准 |
|------|------|
| **新代码必须有新测试** | 新增功能 ≥ 1 个对应测试用例 |
| **改动范围内旧测试全通过** | 不允许"先合并后补测试" |
| **验收矩阵驱动测试** | Spec §7 验收矩阵中每行 = 至少 1 个测试场景 |
| **禁止注释测试来过关** | 注释掉的测试 = 未完成，不算通过 |

### 5.4 宣布 PASS 条件（明确退出条件）

```
✅ 宣布通过（同时满足）:
   - 验证循环 6 阶段全 ✅
   - Spec §7 验收矩阵全行 PASS
   - 零 CRITICAL 问题（ROOT CAUSE CLASSIFIER 无类型 A/B 未解决）

❌ 禁止宣布通过（任一）:
   - 存在未解决的 CRITICAL 问题
   - 测试覆盖率 < 80%
   - 验收矩阵有未验证的行

⚠️ HIGH 问题处理:
   - 有修复计划（记录在 Spec §5 风险与陷阱）才允许合并
   - 当前 Phase 不得解锁下一 Phase，直到 HIGH 问题有修复时间表
```

---

## 6. 跨文件影响分析 (每次变更后必做)

```bash
# 1. 向下追踪: 谁消费了我修改的文件?
grep -r "import.*{FileName}" --include="*.kt" --include="*.tsx" --include="*.ts" .

# 2. 接口对齐: 后端 Controller 变了 → 前端 API Client 呢?
# DTO 变了 → 消费方都更新了吗?

# 3. 旧引用清理: 确认零残留
grep -r "旧模块名" --include="*.kt" --include="*.ts" .
# 标准: 零匹配

# 4. 🔴 共享模块追溯 (新增)
# 修改了 shared/utils, shared/types, common/ 等共享代码时:
# → 必须 grep 搜索所有消费者
# → 逐一验证不受影响 → 受影响的必须一并更新
# → 未涉及的消费者也要检查是否因接口变更而隐式破坏
grep -r "{SharedModuleName}" --include="*.kt" --include="*.ts" --include="*.tsx" .
# 每个匹配都要打开确认
```

> **🔴 铁律: 修改共享模块后, 必须追溯所有消费者并验证。遗漏 = 回归 Bug。**

---

## 7. React/Next.js 特定规则

| 规则 | 标准 |
|------|------|
| useEffect 依赖 | 依赖数组必须完整 |
| render 中 setState | 🔴 禁止 (无限循环) |
| 列表 key | 禁止用 index, 必须用唯一 ID |
| Prop 穿透 | >3 层 → 用 Context |
| 三态处理 | 每个数据页面必须有 Loading/Error/Empty |
| Server Component | 禁止使用 useState/useEffect |

---

## 8. 后端特定规则（框架通用，具体配置见 CONTEXT.md §3）

| 规则 | 标准 |
|------|------|
| 输入验证 | 请求体必须有 Schema/DTO 校验 |
| N+1 查询 | 禁止循环中查关联数据 → 用 JOIN/批量 |
| 无界查询 | SELECT * 必须有 LIMIT |
| 外部调用 | HTTP 调用必须有 timeout |
| 错误响应 | 内部错误不暴露给客户端 |
| 迁移脚本 | 新字段必须有默认值 or 允许 NULL |

---

---

## 9. 代码拆分与复用 (🔴 强制)

### 9.1 拆分规则

| 规则 | 标准 | 违反后果 |
|------|------|----------|
| **单文件上限** | ≤400 行 (典型), ≤600 行 (硬上限, 与 §1 一致) | 超出 → 必须按功能拆分 |
| **单函数上限** | 50 行 | 超出 → 提取子函数 |
| **单组件职责** | 一个组件 = 一个职责 | 多职责 → 拆分 |
| **接口/实现分离** | DTO/Interface 独立文件 | 混写 → 拆分 |

### 9.2 复用检查 (新建文件前必做)

新建前：① grep 搜索相似功能是否已有实现；② 检查 `shared/utils` `common/` 是否有可复用工具函数。
找到 → 导入使用，不重新实现；确无 → 通用逻辑放 `shared/`，不放模块私有目录。

### 9.3 复用追溯 (修改共享代码时)

与 §6 跨文件影响分析相同流程 → `→ §6`。**特别注意**: 工具函数返回值类型/参数顺序变更编译器可能不报错（any/unknown），但运行时崩。

---

## 10. 反死循环与终端安全执行 (🔴 强制)

### 10.1 认知死循环防护

| 规则 | 标准 | 违反后果 |
|------|------|----------|
| 同策略重试上限 | 同一“策略指纹”(方法+目标+关键参数) 最多尝试 **2 次** | 第 3 次禁止，必须换思路 |
| 连续失败熔断 | 连续失败 **3 次** 或 **10 分钟**无净进展 | 触发 `LOOP_BREAK` |
| 止损预算 | 每子任务最大 6 次尝试 / 25 分钟 | 超预算必须上报阻塞 |

`LOOP_BREAK` 最小输出：
1. 已证伪方案列表  
2. 最小可复现  
3. 三个新路径（含风险）  
4. 下一步选择理由

### 10.2 终端执行防卡死

**写任何 terminal 命令前，必须先做预检（防范于未然）：**
1. 这个命令是否有范围边界？（路径/文件类型/limit）
2. 这个命令是否有超时边界？（total + idle）
3. 这个命令是否会重复已失败策略？（同策略 ≤2 次）
4. 这个命令是否可并行或可降级为更小范围？

> 任一项不满足：禁止直接执行，先改命令再运行。

| 规则 | 标准 |
|------|------|
| 默认超时 | 短命令 30-90s；重命令 300-900s（需显式） |
| 无输出看门狗 | 30-60s 无输出视为疑似卡死，终止并降级策略 |
| 无界命令禁止 | `rg/find` 必须限制范围；日志必须 `head/tail/limit` |
| 同命令重试 | 同参数失败 2 次后，必须改参数/改工具/改路径 |

### 10.3 执行入口

- 推荐统一包装器：`core/scripts/safe-exec.sh`
- 所有高风险命令优先用包装器执行，确保 timeout 与输出边界生效。
- 大数据量操作同时遵守 §13 Token-Efficient Execution (脚本编排, 中间结果不进 context)。

### 10.4 Hooks 执行拦截

**机制原理**：Hooks 是 Claude Code 的**真实系统级拦截**，由 `.claude/settings.json` 中 `hooks` 字段配置。它们是 shell 脚本，在工具调用前后由宿主进程自动执行——不是 Agent 自己调用的，而是**系统强制注入的**。

| 生命周期 | 触发时机 | 脚本 |
|---------|---------|------|
| PreToolUse | 工具调用**执行前**，系统自动拦截 | `core/scripts/hook-pretool.sh` |
| PostToolUse | 写操作**执行后**，系统自动检查 | `core/scripts/hook-posttool.sh` |
| Stop | Agent 任务**结束前**，系统自动收尾 | `core/scripts/hook-stop.sh` |

**关键认知**：
- Hook 返回非零退出码 → 工具调用被**系统阻止**，不是 Agent 的选择
- 被 Hook 拦截时：读取 Hook 输出的错误信息，按提示修正后重试，不要猜测原因
- 任一 Hook 失败 → 不得宣称任务完成
- Hook 的判断是确定性的（基于 shell 逻辑），不存在"绕过"或"忽略"的可能

---

## 11. 重构保真门禁（🔴 强制）

### 11.1 基本原则
- 重构 = 架构转换；业务语义、功能行为、边界副作用必须保持一致。
- 禁止猜测/臆测/杜撰；未确认项一律标记 `UNKNOWN` 并回源验证。

### 11.2 重构前置条件
1. 像素级审计原实现（入口/分支/异常/状态变化/隐式约束）
2. 形成等价性矩阵（旧实现 vs 新实现）
3. 形成执行计划并切片（每片可独立验证）

### 11.3 执行与验证
- 每片改动后立即执行增量验证（Build/Type/Lint/Test）
- 完成后执行等价性验证：输入、输出、副作用、错误语义
- 必做跨文件消费者追溯，防止隐式破坏

### 11.4 收尾规则
- 任务级计划文件在迁移结束后删除
- 保留审计结论与来源证据
- 归档分账本：错误进 ERROR-BOOK；可复用需求进 PROJECT-MEMORY

### 11.5 标准清单
- `core/reference/refactor-fidelity-checklist.md`

---

## 12. Think Discipline — 行动前链式推理（🔴 关键决策点强制）

> **来源**: Anthropic "The Think Tool" — 复杂顺序决策前停下来想, 一致性提升 54%。
> **原理**: 错误在顺序决策中会累积; 行动前显式推理能打断盲目执行链。

### 12.1 何时必须 Think

| 触发点 | 角色 | Think 内容 |
|--------|------|-----------|
| 任务分解前 | CTO | 需求是否清晰? 依赖关系? 域边界? 哪些假设需要验证? |
| 工具结果返回后 | 工程师 | 结果是否符合预期? 是否需要追加操作? 是否触发了新风险? |
| 审计判定前 | CTO/QA | 收集的证据是否充分? 有没有遗漏的维度? 置信度是否 >80%? |
| Bug 修复前 | 工程师 | 根因确认了吗? 修的是症状还是根因? 有同类代码吗? |
| 破坏性操作前 | 任何人 | R0 三问: 会丢数据吗? 可逆吗? 影响现有记录吗? |

### 12.2 Think 输出格式 (内部推理, 不输出给用户)

```
THINK:
  已知: [收集到的事实/工具结果]
  约束: [适用的规则/铁律/Spec 要求]
  选项: [可能的方案 A/B/C]
  风险: [每个方案的风险]
  决定: [选择方案 X, 因为...]
  下一步: [具体行动]
```

### 12.3 Think vs 直接执行

| 场景 | 做法 |
|------|------|
| 简单顺序操作 (创建文件/运行测试) | 直接执行, 不需要 Think |
| 复杂策略决策 (分解任务/选方案) | **必须 Think** |
| 多步工具链 (>3 步依赖) | **必须在关键分支点 Think** |
| 错误诊断 | **必须先 Think 再改代码** (与 root-cause-classifier 联动) |

> **衡量标准**: 用 pass^k (k 次全部通过) 衡量一致性, 非 pass@k。

---

## 13. Token-Efficient Execution — 代码编排优先（大数据操作强制）

> **来源**: Anthropic "Code Execution with MCP" — 代码编排比顺序工具调用节省 98.7% Token。
> **原理**: 中间数据在沙箱/脚本中处理, 只将最终结果返回 context, 避免 Token 膨胀。

### 13.1 何时使用代码编排

| 场景 | Token 影响 | 做法 |
|------|-----------|------|
| 处理大数据集 (>100 行结果) | 全量进 context = 膨胀 | 用脚本过滤/聚合, 只返回摘要 |
| 3+ 依赖工具调用链 | 每步中间结果累积 | 写脚本一次性编排 |
| 批量操作 (N 个文件/记录) | N 次调用 = N 倍 Token | `for` 循环在脚本中, 一次返回结果 |
| 搜索 + 过滤 + 转换 | 每步都进 context | 管道在脚本中, 最终结果进 context |

### 13.2 实现模式

```bash
# 反模式: 每步都回到 Agent
grep ... → Agent 看结果 → wc ... → Agent 看结果 → sort ... → Agent 看结果

# 正确模式: 一次脚本编排
grep ... | wc -l | sort > /tmp/summary.txt && cat /tmp/summary.txt
# Agent 只看最终摘要
```

### 13.3 文件系统作为中间缓冲

大型工具输出 → 写入临时文件 → 用脚本处理 → 只将关键结果读入 context。

```
大数据流: 工具 → /tmp/raw.json → jq 过滤 → /tmp/filtered.json → 读取摘要
```

### 13.4 与现有机制的关系

| 机制 | 用途 | 联动 |
|------|------|------|
| `core/scripts/qa-gate.sh` | 6 阶段验证一次运行 | 已符合代码编排模式 |
| `core/scripts/safe-exec.sh` | 安全执行包装器 | 可与编排脚本结合 |
| §10.2 终端执行防卡死 | 超时/边界控制 | 编排脚本同样需遵守 |

> **铁律**: 处理 >100 行工具输出时, 禁止全量返回 context; 必须在脚本中预处理后返回摘要。

---

## 14. 问题复盘铁律（🔴 强制 — 每次错误修复后必做）

> **真相源**: 所有工作流（build/guard/ship）中的「问题复盘铁律」均指向本节。

1. **记录** → `.claude/projects/{project}/data/errors/ERROR-BOOK.md`
   - 格式见 `memory.md §3.2`：错误标题 / 触发条件 / 根因 / 修复方案 / 关键词索引
2. **交叉检查** → 抽象错误模式 → grep 同类代码 → 逐一核查 → 批量修复
   - 流程见 `memory.md §3.5`
3. **确认** → 零同类残留

> 不执行复盘 = 不完整修复 = 驳回。

---

## 15. 性能意识 (performance-awareness)

> **原则**: 代码不仅要正确，还要高效。时间/空间复杂度和 token 消耗都是一等约束。

| 维度 | 规则 |
|------|------|
| **算法复杂度** | 选择数据结构和算法时必须考虑时间/空间复杂度；O(n²) 以上需注释说明为何不可避免 |
| **查询性能** | 禁止 N+1 查询（§8）；大数据集必须分页；索引覆盖关键查询路径 |
| **前端渲染** | 长列表用虚拟滚动；避免不必要的 re-render；大计算移到 Web Worker |
| **Token 预算** | 遵守 §13；中间结果不进 context；批量操作用脚本编排 |
| **内存意识** | 流式处理优于全量加载；及时释放大对象引用 |

---

## 16. 设计模式优先 (design-pattern-first)

> **原则**: 优先采用语言/框架内置的通用设计模式，避免自造轮子。

| 场景 | 优先模式 |
|------|---------|
| 对象创建 | Factory / Builder（Kotlin `data class` + `copy()`） |
| 依赖管理 | Spring DI（`@Service` / `@Component`），禁止手动 `new` 服务类 |
| 横切关注 | AOP（`@Aspect`）用于日志/审计/权限，不侵入业务代码 |
| 状态管理 | React Context / Zustand，禁止 prop drilling >3 层（§7） |
| 异步流程 | Kotlin Coroutines / React Suspense，禁止回调地狱 |
| 数据转换 | DTO ↔ Entity 用 Mapper 层（`toDto()` / `toEntity()`），禁止直接暴露 Entity |

**决策规则**：写新逻辑前先问——框架有没有内置方案？社区有没有标准模式？只有都没有才自己写。

---

*Version: 2.3.0 — 新增 §2.1 Conventional Commits + §10.4 Hook 机制说明 + §15 性能意识 + §16 设计模式优先*
*Created: 2026-02-15 | Updated: 2026-02-20*
