谷歌工程师团队 正在以AI AGENT CODING的方式测试AI AGENT是否能满足工作需要
现在领导发来了需求清单, 工程师们需要讨论prompt的写法, 能够让AI AGENT高效工作
深入理解项目要求和完成指标




需要使用的数据库表格
数据库表 in_po
字段为
date: YYYY-MM-DD
supplier_code: 供应商代码
po_num: 订单号
sku: SKU
qty: 数量
unit_price: 单价
currency: USD/RMB 
usd_rmb: 汇率 记录当天汇率买入价
by: 操作人

数据库表 in_po_strategy
字段为
date: YYYY-MM-DD
po_num: 订单号
cur_currency: USD/RMB
cur_float: 1/0 bool
cur_ex_float: 百分比数
cur_deposit: 1/0 bool
cur_deposit_par: 百分比数
cur_usd_rmb: 汇率
note:备注
by: 操作人
seq: V##  #代表数字0-9



现在加入新功能 采购板块->新建采购订单
需要在采购板块建立子路由 new_po
该板块首先要收到 用户管理权限-用户列表-配置权限 的约束, 该约束决定了用户是否可以访问该页面
页面UI和风格采用同 采购板块->新增供应商向导 一致的UI设计, APPLE UI风格设计
整体需要 采用 公有类里的 global-wizard向导页, gloal-modal弹窗密码验证, i18n多语言, global-file-uploader文件上传组件 苹果按钮开关(ui-toggle) 等组件
保持页面的连贯的UI风格, 注意每个用户可以交互要求输入和点击的框体,菜单(除开每个流程中前往下一个流程的按钮)都需要tooltips提示
注意提示先去查看项目文件夹backend/static/里面的公有页面查找一切可用的组件在贯穿整个流程 能用的共有的不要新建
每一步都须有有一个返回上一步的按钮能让用户回到上一步骤操作
需要通过下面的流程和说明完成前后端配套设计

流程上分为以下步骤:
订单准备说明->录入合同参数->检验参数数据->录入商品信息->检验商品数据->录入前预览->完成订单

每个流程界面和说明如下:
[流程1] 订单准备说明
此页为一个操作说明页面, 说明内容为告诉用户这个流程是操作过程
大致的流程(你需要早操作须知里润色描述)就是先下载excel模版, 填写内容
填入该订单的明细和订单合同策略,上传填好的excel文件,订单就完成了
上传的excel不会作为最终PO, 最终PO会由系统生成并提供下载
也需要告知用户 若果需要新增供应商或者新增sku需要先去指定页面完成,本页面不具备这些功能
在页面中有一个下载按钮, 需要提示用户点击这个下载按钮下载采购订单模板的excel文件填写后上传
这个文件放在项目目录下 data/templates/in_po_upload.xlsx
也提示用户订单页可以手动填写, 但是推荐下载填写表格后上传

[流程2] 录入合同参数
进入页面会有2个选项,一个为选择的订单日期, 一个为选择的供应商, 右下方会显示下一步的按钮,但是是灰色无法交互
供应商选择一个选项列表. 点开是个下拉菜单,列表需要显示来自in_supplier表的supplier_code, supplier_name 例如: XX,某某工厂表
当用户选取一个供应商和日期之后
该供应商的策略信息会以列表的样式展示在下方
要展示的策略信息内容和来源如下 (是展示信息,不可以被用户交互)
显示的信息都需要根据用户选取的supplier_code内容, 读取in_supplier_strategy表匹配的supplier_code中所有行的数据
再根据用户选择日期, 选择effective_date列<=用户选择日期 中 最近那一天的行数据进行入下方数据显示

结算货币(tooltip提示:供应商结算货币): currency列信息
结算汇率(tooltip提示:供应商结算汇率): 根据用户输入的日期,查询当日的USD/RMB汇率的买入价 只写入数据(非查询软件表格,而是查询网络数据,若查询不到,需要使用global-modal弹窗要用户录入, 提示用户必须自己填入)
价格浮动(tooltip提示:供应商是否要求价格跟随汇率浮动): float_currency列信息
价格浮动阈值(tooltip提示:若供应商要求价格跟随汇率浮动, 汇率浮动阈值): float_threshold列信息
定金要求(tooltip提示:供应商是否要求订单要提前支付定金):depository列信息
定金百分比(tooltip提示:供应商要求提前支付定金百分比):deposit_par列信息

在该名片策略信息下方会出现两个选项按钮, 一个为: 使用原策略(tooltip提示:使用原有供应商合同策略), 一个为: 采用新策略(tooltip提示:为该订单采用特殊自定义策略,不会修改原有供应商合同策略, 也不会影响其他订单)
当用户选择 使用原策略 时, 下一步按钮会被点亮, 并可以被交互进入下一步
用户后续流程使用的数据就是提交的数据 即为 当前的表显数据

当用户选择 采用新策略 时 原有的表格数据下面会多出一个确认修改按钮 (该确认修改按钮必须在用户至少有修改一处数据且录入数据和之前有所不同才会点亮能被点击,否则是灰色的不可交互状态)
同时之前的显示 供应商策略 列表里的每个数据右侧都会出现一个按钮 (名为修改该策略) 点击在按钮旁边 就是弹出交互框(若用户没修改,则不会出现交互框)
传递信息规则为, 用户没有选择修改的会按照原有数据传递, 若用户选择修改并确认的,会按照用户录入信息overwrite原有数据 (录入前后一摸一样的数据不算修改)

交互框如下:
结算货币(tooltip提示:自定义当前订单供应商结算货币): 这是个两个选项 RMB/USD 2选1
结算汇率(tooltip提示:自定义当前订单供应商结算汇率): 这个是输入框
价格浮动(tooltip提示:自定义当前订单供应商是否要求价格跟随汇率浮动): 这个是个开关按钮
价格浮动阈值(tooltip提示:若自定义当前订单供应商要求价格跟随汇率浮动, 汇率浮动阈值): 这是一个拉动的条 拉动条可以选择0-10
定金要求(tooltip提示:自定义当前订单供应商是否要求订单要提前支付定金):这个是个开关按钮
定金百分比(tooltip提示:自定义当前订单供应商要求提前支付定金百分比,100%意味着需要预期支付全部货款):这是一个拉动的条 拉动条可以选择0-100

当用户点击确认修改之后, 下一步按钮会被点亮 并可以被交互进入下一步

[流程3] 检验参数数据
若前一步用户选择 使用原策略, 则会跳过这一步, 使用流程2的数据直接传入下个个流程
若前一步用户选择 采用新策略, 则这一步会验证用户录入的数据是否合法
验证中 虽然会截取上一步传递过来的全部信息, 但是仅会截取用户上一步中点了修改按钮选择修改的数据进行验证, 未修改的不进行验证
显示页面样式为名片样式展示内容
供应商(tooltip提示:供应商名字): 第2流程用户确定的供应商名称
供应商代码(tooltip提示:供应商代码): 第2流程用户确定的供应商代码
供应商名称(tooltip提示:供应商名字): 第2流程用户确定的供应商名称
订单日期(tooltip提示:订单生成日期): 第2流程用户确定的订单日期
结算货币(tooltip提示:订单结算货币): 第2流程用户确定的供应商结算货币
结算汇率(tooltip提示:用户确定订单日USD/RMB汇率买入价): 第2流程用户确定的汇率买入价
价格浮动开关(tooltip提示:订单是否要求价格跟随汇率浮动): 第2流程用户确定的价格浮动开关
价格浮动阈值(tooltip提示:若订单要求价格跟随汇率浮动, 汇率浮动阈值): 第2流程用户确定的价格浮动阈值
定金要求开关(tooltip提示:订单是否要求提前支付定金): 第2流程用户确定的定金要求开关
定金百分比(tooltip提示:若订单要求提前支付定金,定金百分比): 第2流程用户确定的定金百分比
注意在显示中, 为用户后面自定义的(修改过的)数据需要在此数据上注明 为订单级策略

验证标准为(若一下数据非用户在上一步流程中选择验证的,则完全无需验证, 仅验证用户点击了修改按钮选择修改的数据)
供应商(tooltip提示:供应商名字): 无需验证
供应商代码(tooltip提示:供应商代码): 无需验证
供应商名称(tooltip提示:供应商名字): 无需验证
订单日期(tooltip提示:订单生成日期): 无需验证
结算货币(tooltip提示:订单结算货币): 必须是RMB或者USD
结算汇率(tooltip提示:用户确定订单日USD/RMB汇率买入价): 必须是数字,且不为小于1的数字
价格浮动开关(tooltip提示:订单是否要求价格跟随汇率浮动): 必须是开关代表输出的0(关)或1(开)
价格浮动阈值(tooltip提示:若订单要求价格跟随汇率浮动, 汇率浮动阈值): 若浮动开关为开,必须大于0且小于等于10, 若浮动开关为0,则必须为空或0
定金要求开关(tooltip提示:订单是否要求提前支付定金): 必须是开关代表输出的0(关)或1(开)
定金百分比(tooltip提示:若订单要求提前支付定金,定金百分比): 若定金要求开关为开,必须大于0且小于等于100, 若定金要求开关为0,则必须为空或0

注意在显示中, 为用户后面自定义的(修改过的)数据需要在此数据上注明 为订单级策略

验证不通过,需要在显示信息名片框体下面多一个框体显示错误内容, 提示用户返回修改,下一步的按钮是灰色且不可交互
验证通过, 下一步的按钮 点亮且可以交互进入下一流程

[流程4] 录入商品信息
页面会出现一个选项
一个为上传填好的excel文件, 一个为手动填写
当用户选择上传excel文件时, 下方会出现一个上传文件框体, 该框体必须采用 公有类的 global-file-uploader文件上传组件
用户上传文件必须是excel文件, 否则要求重新上传,且下一步按钮变成灰色不可交互

当用户选择手动填写
会在选项下方出现一个类似 产品板块-外包装条形码 第一个流程中的页面(表格样式, 录入方式, 添加行的按钮等)
第一列: 保留SKU列的设计(只能从表Data_COGS中SKU列选择)
第二列: 每盒个数 (QTY/BOX) 改为 商品数量  提示不变
第三列: 每箱盒数 (BOX/CTN) 改为 产品单价  提示从输入数量变成 输入价格
注意第三列的每行数据输入框(即便用户添加行,每行都必须有)前面都必须加入价格单位, 该单位为上一步的结算货币决定

当至少有一个行数据完整时, 下一步的按钮 会被点亮 可交互, 否则按钮是灰色且不可交互

[流程5] 检验商品数据
此流程为验证流程4的数据是否合规
不论用户选择什么输入方式, 都需要把内容作为列表展示, 注意展示框体高度不能超额,需要有滚动条
在遇到错误的地方除了高亮标记该colomn, 此外还需要在在下方框体展示错误内容明细,且下一步按钮变成灰色不可交互

若用户是手动录入,只读取完整行的数据, 若某行有数据缺失或为空, 则不会读取该行数据
验证内容为 
录入的 商品数量 必须为 正整数 (不接受其他值)
录入的 产品单价 必须为 0或者大于0的float(2位小数)

若用户是上传文件
则需要根据步骤检查如下内容
1. 表格B1格内容为Eaglestar Purchase Order Form (若不匹配,则提示文件错误让用户重新上传)
2. 表格C2的内容匹配用户在流程2选择的supplier_code 表格E2的内容匹配用户在流程2中选择的日期 (注意表格内的E2的内容需要你转化为YYYY-MM-DD格式再去匹配 如果用户录入非常规的日期格式) 若不匹配 则提示用户上传文件不匹配 让用户重新上传
3. 表格从B列第5行开始(包含第5行)往下都是SKU内容, 而其对行的C列为商品数量 E列为产品单价
     SKU必须满足Data_COGS表中的SKU
     商品数量必须为0或者正整数
     产品单价必须为0或者大于0的float(2位小数)
     
只有通过验证,下一步按钮会被点亮,可进入下一流程

[流程6] 录入前预览
读取 [流程3] 检验参数数据 里的的列表 和 [流程5] 检验商品数据 里的的列表
把两个列表合并成为一个新的表格 将 [流程3] 检验参数数据 里的的列表 放在 [流程5] 检验商品数据 里的的列表 的上方
展示给用户查看 (注意不要把两个列表放在不同的框体里, 要合并成为一个框体, 注意限高, 能让用户用滚轮查看)

这里的确认按钮点击后会触发global-modal组件的密码功能让用户输入密码确认, 注意这里的密码由 用户权限管理-密码策略 决定
当密码验证没有通过时, 不会执行数据库写入, 也不会执行文件写入, 而直接跳转[流程7]

当密码验证通过时, 会执行数据库写入, 也会执行文件写入, 而直接跳转[流程7]

数据写入对应如下表

数据库表 in_po
字段为
date: 写入第2流程中用户选择的日期, 注意格式为 YYYY-MM-DD
supplier_code: 写入第2流程中用户选择的供应商代码 (确认是2个字母且来资源in_supplier表中用户选取的)
po_num: 写入第2流程中用户选择的供应商代码+用户选择的日期+-S##   其中##是数字 若用户输入的日期中该供应商代码已经存在了订单,则##需要递增, 例如原来是02 现在就得是03, 若用户选的 供应商代码为XX, 日期为2025-12-01, 那么 写入 XX20251201-S03 
sku: 写入流程5中检验过的用户输入的KU
qty: 写入流程5中检验过的用户输入的商品数量
unit_price: 写入流程5中检验过的用户输入的产品单价
currency: 写入流程3中传入的currency
usd_rmb: 写入流程3中传入的结算汇率
by: 写入当前操作这个页面登录用户的用户名

数据库表 in_po_strategy
字段为
date: 使用刚写入的in_po表的date
po_num: 使用刚写入的in_po表的po_num
cur_currency: 使用流程3完成后传入流程4的结算货币 (只能是RMB或USD)
cur_float: 使用流程3完成后传入流程4的价格浮动开关 (只能是1/0)
cur_ex_float: 使用流程3完成后传入流程4的价格浮动阈值 是一个 (0-10]的数字 不可为0
cur_deposit: 使用流程3完成后传入流程4的定金要求开关 (只能是1/0)
cur_deposit_par: 使用流程3完成后传入流程4的定金百分比 
cur_usd_rmb: 使用流程3完成后传入流程4的结算汇率 是一个 (0-100]的数字 不可为0
note: 写入字符串 原始订单   
by: 写入当前操作这个页面登录用户的用户名
seq: V##  #代表数字0-9 该字段为自增字段, 若在本表中,po_num为primary key, seq为其第几次操作记录, 例如第一次V01, 第二次V02 以此类推 

[流程7] 完成订单
该页面如同其他板块的采用 公有向导组件 global-wizard 中的完成页面
显示用户操作是否成功, 还是错误
分别写入了多少数据 (无需告知用户写入了什么表)
成功时提示成功写入了 订单号..... 数据 总共....条记录
失败时提示失败写入了 操作失败, 是因为什么原因

若操作成功需要同时生成一个excel文件,
该文件需要提取 项目目录下 data/templates/in_po_upload.xlsx 然后写入内容, 注意不要覆盖原文件
写入好的文件 需要放在 项目目录下 backups/in_pos/厂商代码/     文件夹中(厂商代码为实际的厂商代码, 例如XX)
命名为 po_num+seq.xlsx  po_num 为该xlsx中记录的 订单号(单元格C4) seq为该xlsx中记录的订单版本(单元格F4)
该excel的写入标准为
单元格C2: 写入流程6中写入in_po表的supplier_code
单元格F2: 写入流程6中写入in_po表的date
单元格C4: 写入流程6中写入in_po表的po_num
单元格F4: 写入流程6中写入in_po_strategy表的seq
单元格C6: 写入流程6中写入in_po_strategy表的cur_currency
单元格F6: 写入流程6中写入in_po_strategy表的cur_usd_rmb
单元格C8: 写入流程6中写入in_po_strategy表的cur_float
单元格F8: 写入流程6中写入in_po_strategy表的cur_ex_float
单元格C10: 写入流程6中写入in_po_strategy表的cur_deposit
单元格F10: 写入流程6中写入in_po_strategy表的cur_deposit_par
单元格C12: 写入流程6中写入in_po_strategy表的by
单元格F12: 写入流程6中写入in_po_strategy表的note

B列从15行开始写入流程6中写入in_po表的sku
F列从15行开始写入流程6中写入in_po表的qty
H列从15行开始写入流程6中写入in_po表的unit_price

这个表格完成后在流程7也需要提示

单元格	写入内容	数据来源	变量名
C4	供应商代码	用户在流程2选择的供应商	supplier_code
F4	订单日期	用户在流程2选择的日期 (YYYY-MM-DD)	po_date
C6	订单号	系统自动生成 {供应商代码}{YYYYMMDD}-S{序号}	po_num
F8	版本号	系统自动生成 V01	strategy_seq
C10  操作人    当前登录用户    operator
F10  修订日期    用户在流程2选择的日期 (YYYY-MM-DD)	po_date
C12  备注	固定值 "原始订单"	note
C14	结算货币	来自供应商策略 (USD/RMB)	currency
F14	结算汇率	自动获取或用户手动输入	exchange_rate
C16	价格浮动开关	来自策略或用户自定义 (0/1)	cur_float
F16	价格浮动阈值	来自策略或用户自定义 (百分比)	cur_ex_float
C18	定金要求开关	来自策略或用户自定义 (0/1)	cur_deposit
F18	定金百分比	来自策略或用户自定义 (百分比)	cur_deposit_par
F20  策略版本 写入 L01
C22	操作人	当前登录用户	operator
F22  修订日期  用户在流程2选择的日期 (YYYY-MM-DD)	po_date
C24  备注	固定值 "原始订单"	note
C26  总价 计算整个订单的总价 也就是流程6里统计过的总价

商品明细区域 (从第29行开始)
列	列号	写入内容	数据来源
B列	column=2	SKU	用户录入/Excel上传的SKU
C列	column=3	数量	用户录入/Excel上传的qty
D列	column=4	货币	用户之前选择RMB或者USD
E列	column=5	单价	用户录入/Excel上传的unit_price
F列	column=6	总价	数量*单价

模板文件
模板路径: 
data/templates_csv/in_po_output.xlsx
输出路径: backups/in_pos/{supplier_code}/{po_num}_current.xlsx


同时也有重新开始一轮按钮, 点击后需要跳转到流程1



需要使用的数据库表格
数据库表 in_po
字段为
date: YYYY-MM-DD
supplier_code: 供应商代码
po_num: 订单号
sku: SKU
qty: 数量
unit_price: 单价
currency: USD/RMB 
usd_rmb: 汇率 记录当天汇率买入价
action: new/delete/adjust
note:备注
by: 操作人
seq: L##  #代表数字0-9

数据库表 in_po_strategy
字段为
date: YYYY-MM-DD
po_num: 订单号
cur_currency: USD/RMB
cur_float: 1/0 bool
cur_ex_float: 百分比数
cur_deposit: 1/0 bool
cur_deposit_par: 百分比数
cur_usd_rmb: 汇率
note:备注
by: 操作人
seq: V##  #代表数字0-9

现在加入新功能 采购板块->订单管理
需要在采购板块建立子路由 po_mgmt
该板块首先要收到 用户管理权限-用户列表-配置权限 的约束, 该约束决定了用户是否可以访问该页面
页面UI和风格采用同 采购板块->新增供应商向导 一致的UI设计, APPLE UI风格设计
整体需要 采用 公有类里的 global-wizard向导页, gloal-modal弹窗密码验证, i18n多语言, global-file-uploader文件上传组件 苹果按钮开关(ui-toggle) 等组件
保持页面的连贯的UI风格, 注意每个用户可以交互要求输入和点击的框体,菜单(除开每个流程中前往下一个流程的按钮)都需要tooltips提示
注意提示先去查看项目文件夹backend/static/里面的公有页面查找一切可用的组件在贯穿整个流程 能用的共有的不要新建
每一步都须有有一个返回上一步的按钮能让用户回到上一步骤操作
需要通过下面的流程和说明完成前后端配套设计

此功能点开时的页面参考 采购板块->策略管理
不过展示的表格内容要做改变
下面的列名和对应的展示内容
1. 订单号: 来自于in_po表的所有唯一的po_num
2. 供应商代码: 在in_po表中根据订单号的po_num对应的supplier_code
3. 订单日期: 在in_po表中根据订单号的po_num对应的date, 选择列action数据为new的日期
4. 最新订单策略日期: 在in_po_strategy表中根据订单号的po_num对应的date, 选择离今天最近的日期
5. 最新订单策略版本: 在in_po_strategy表中根据订单号的po_num对应的seq, 根据最新订单策略日期选择其对应的seq
6. 最新订单明细日期: 在in_po表中根据订单号的po_num对应的date, 选择离今天最近的日期
7. 最新订单明细版本: 在in_po表中根据订单号的po_num对应的seq, 根据最新订单明细日期选择其对应的seq
8. 查看当前订单 (是个按钮, 有页面跳转, 这个页面为查看该订单明细, 需要一个新的Html文件管理, 但是非新路由)
9. 修改当前订单 (是个按钮, 有页面跳转, 这个页面为修改该订单明细, 需要一个新的Html文件管理, 但是非新路由)
10. 历史修订记录 (是个按钮, 有页面跳转, 这个页面为查看该订单明细的修订记录, 需要一个新的Html文件管理, 但是非新路由)
11. 删除当前订单 (是个按钮, 有页面跳转, 这个页面为删除该订单明细, 需要一个新的Html文件管理, 但是非新路由)

在订单列表中
若在表in_po表中找到任何一行该订单下列action为delete且该行数据中SKU为空时, 则该订单已经被删除, 需要在列表中打上一个高亮的 该订单已被删除的tag
同时
在表in_po中找到po_num的中,我们需要首先对action列为new的行且seq为L01作为初始数据
然后继续in_po中找到同po_num的行,但是action列为adjust的行,选取每个sku的对初始数据中满足的sku的行进行替换
注意, 这个替换流程必须遵seq行的L##中##的顺序, 需要从小的替换到大的 例如先替换L02, 然后L03....依次类推(L01为初始数据)
然后需要将action列为add但是seq为不L01的行的数据加入初始数据末端
然后需要将action列为delete且sku不为空的, 匹配初始数据中的sku,若匹配成功, 则从初始数据中删除
若完成全部比对之后, 初始数据为空, 则也判定该订单被删除, 需要在列表中打上一个高亮的 该订单已被删除的tag


同时需要顶上有filter框体, 支持按照 供应商代码 去筛选显示的内容 供应商代码来自于in_supplier表的supplier_code
同时1-3表头支持点击表头进行重新排序

以下为每个页面明细, 每个页面都需要返回按钮返回订单管理, 若存在向导的页面 也需要返回按钮返回上一步
[页面1] 查看当前订单
该页面打开为展示页面, 展示当前订单的全部最新信息, 信息来自于in_po表和in_po_strategy表
展示的方式可以参考data/templates_csv/in_po_output.xlsx这个文件模版
展示框体1(名片形式), 订单基础信息, 内容如下
供应商: 来自该选取订单的in_po表中对应的supplier_code
订货日期: 来自该选取订单的in_po表中对应的date,选择列action数据为new的日期
订单号: 来自该选取订单的in_po表中对应的po_num
展示框体2(名片形式), 订单策略信息, 内容如下
最新策略版本: 来自该选取订单的in_po_strategy表中对应的seq,选择离今天最近的日期
操作人: 来自该选取订单的in_po_strategy表中对应的by, 根据最新策略版本的选择,选择其对应的by
修订日期: 来自该选取订单的in_po_strategy表中对应的date, 根据最新策略版本的选择,选择其对应的date
备注: 来自该选取订单的in_po_strategy表中对应的note, 根据最新策略版本的选择,选择其对应的note
货币: 来自该选取订单的in_po_strategy表中对应的cur_currency, 根据最新策略版本的选择,选择其对应的cur_currency
结算汇率: 来自该选取订单的in_po_strategy表中对应的cur_usd_rmb, 根据最新策略版本的选择,选择其对应的cur_usd_rmb
价格浮动开关: 来自该选取订单的in_po_strategy表中对应的cur_float, 根据最新策略版本的选择,选择其对应的cur_float
价格浮动阈值: 来自该选取订单的in_po_strategy表中对应的cur_ex_float, 根据最新策略版本的选择,选择其对应的cur_ex_float
定金要求开关: 来自该选取订单的in_po_strategy表中对应的cur_deposit, 根据最新策略版本的选择,选择其对应的cur_deposit
定金百分比: 来自该选取订单的in_po_strategy表中对应的cur_deposit_par, 根据最新策略版本的选择,选择其对应的cur_deposit_par

展示框体3(表格形式), 订单明细信息, 内容如下
修订版本: 来自该选取订单的in_po表中对应的seq,选择离今天最近的日期
操作人: 来自该选取订单的in_po表中对应的by, 根据最新明细版本的选择,选择其对应的by
修订日期: 来自该选取订单的in_po表中对应的date, 根据最新明细版本的选择,选择其对应的date
备注: 来自该选取订单的in_po表中对应的note, 根据最新明细版本的选择,选择其对应的note
总价: 来自下面列表中每一行的小计的和
列表(SKU, 数量, 货币, 单价, 小计)
SKU,数量,单价是一个对应组, 对应in_po表中一行数据内的信息, 货币源于上面最新策略版本中的货币, 小计对应 该行的单价乘以数量的取值
所以在这个列表中SKU为选取项目的根本逻辑, 后面的4列都是根据前面这个选择来显示的
在列表生成的时候, 
在表in_po中找到po_num的中,我们需要首先对action列为new的行且seq为L01作为初始数据
然后继续in_po中找到同po_num的行,但是action列为adjust的行,选取每个sku的对初始数据中满足的sku的行进行替换
注意, 这个替换流程必须遵seq行的L##中##的顺序, 需要从小的替换到大的 例如先替换L02, 然后L03....依次类推(L01为初始数据)
然后需要将action列为add但是seq为不L01的行的数据加入初始数据末端
然后需要将action列为delete且sku不为空的, 匹配初始数据中的sku,若匹配成功, 则从初始数据中删除
若完成全部比对之后, 初始数据为空, 则也判定该订单被删除, 需要在列表中打上一个高亮的 该订单已被删除的tag
同时若action列为delete, 且SKU为空值, 则该po_num的订单整体被删除, 那这个po_num的订单信息在这个框体中需要显示整体被删除的高亮和tag提示

该页面中还有以下按钮
下载按钮, 点击后会触发下载, 下载的文件为excel文件
该功能会先读取data/templates_csv/in_po_output.xlsx这个文件模版
然后把上面我们的数据写入这个文件中对应位置,生成新的excel文件,命名为{supplier_code}/{po_num}_current.xlsx供用户下载
注意当发现订单被删除的时候, 下面的订单明细SKU 价格这些列中为空
需要在订单文件顶端 加入一行, 红字写入 订单被删除 删除日期 YYYY-MM-DD

修改当前订单按钮, 点击后会跳转到页面2 修改当前订单
删除当前订单按钮, 点击后会跳转到页面4 删除当前订单
查看历史修订记录按钮, 点击后会跳转到页面3 历史修订记录
特别注意, 当以上展示框体展示内容读取时, 发现in_po表中的action为delete时, 则需要特别高亮提示用户该订单已被删除


[页面2] 修改当前订单
此页面点开后 会根据用户选择的po_num读取in_po表和in_po_strategy表中的数据
此页面需要采用 向导页面的公有页 global-wizard 来做
流程分为6个
流程1: 修改订单策略信息
此流程打开后会显示当前选取订单的信息
类似于 产品模块-新建采购订单 第2流程在采用新策略时的显示方式,修改方式也一样
只不过读取的内容需要修改一下来源
结算货币: 读取in_po_strategy表中的cur_currency, 选取seq V## 中##数字最大的数据
结算汇率: 读取in_po_strategy表中的cur_usd_rmb, 选取seq V## 中##数字最大的数据
价格浮动: 读取in_po_strategy表中的cur_float, 选取seq V## 中##数字最大的数据
浮动阈值: 读取in_po_strategy表中的cur_ex_float, 选取seq V## 中##数字最大的数据
定金要求: 读取in_po_strategy表中的cur_deposit, 选取seq V## 中##数字最大的数据
定金比例: 读取in_po_strategy表中的cur_deposit_par, 选取seq V## 中##数字最大的数据
备注[新增]: 读取in_po_strategy表中的note, 选取seq V## 中##数字最大的数据 (在用户修改中是必填的)

点击下一步按钮, 点击会进入流程2
点击跳过修改订单策略按钮, 会跳过流程1 流程2, 直接进入流程3

流程2: 验证参数
这个流程和 产品模块-新建采购订单 第3流程显示和每个数据的验证方式一致
对于备注,要求是必填项目, 不能为空
完成验证后 可以点击下一步, 会进入流程3, 否则下一步按钮是灰色 无法交互

流程3: 修改订单明细信息
这个流程会从in_po表中读取属于这个po_num雷同于页面1中的订单明细列表(SKU, 数量, 货币, 单价, 小计)
且如同产品模块-新建采购订单 第2流程在采用新策略时的显示修改的方式,在原有的数据框体右侧显示修改框体
但是这里仅有列数量,单价可以修改,其他列不可修改, 小计会根据用户的修改实时刷新结果
在列表最下方也需要一个按钮 新增SKU, 用户点击时会在原有的列表最下面新增一行, 要求用户录入一行新数据
此时 SKU选项为下拉菜单, 读取Data_COGS表中所有SKU为列表, 用户可以输入 单价 和 数量 , 小计自动计算 实时刷新
原有的数据行最后面也有删除按钮, 点击后会删除该行记录, 但是点击删除后需要用户确认 这里要用到global-modal弹窗确认, 确认后此行数据消失
点击下一步, 会进入流程4
在把内容传递到下一步之前, 需要确定仅传递用户修改了内容的行
也就是用户点击删除, 点击新增后增加的行, 和在原有数据框体右侧显示修改框体中实际产生了修改(修改的数值和原值不同)的行 传递给下一步
用户也可以点击跳过修改订单明细信息按钮, 会跳过流程3 流程4, 直接进入流程5

流程4: 验证商品
流程4的验证商品页面 页面设计 和 验证原理 和 产品模块-新建采购订单 第5流程一致
完成验证后 可以点击下一步, 会进入流程5, 否则下一步按钮是灰色 无法交互

流程5: 修改预览
流程5中修改预览与 产品模块-新建采购订单 第6流程类似
展示上述流程2和流程3修改后最终的数据
用户点击确认修改按钮, 会触发global-modal的密码验证
密码验证的key需要先设置好 这个你可以参考相关内容去做好先 验证通过进入流程6

流程6: 完成
流程6和 产品模块-新建采购订单 第7流程UI设计一致 内容也一直 但是要做上传内容的修改
若用户在流程1中对 订单策略进行了修改
则需要把全部数据上传到in_po_strategy表中 date为当前日期 seq的写入需要在现有该po_num的seq的最大值的 V##中##数字计数+1

若用户对订单明细进行了修改
注意此处我们仅把流程3中传递给流程4检验的内容 上传到in_po表中 date为当前日期 seq的写入需要在现有该po_num的seq的最大值的 L##中##数字计数+1
注意这些上传的内容的行 若是修改原有数据的action列要写入adjust, 若是删除原有数据的行 action列要写入delete 若是新增数据 action列要写入add

[页面3] 历史修订记录
此页面打开后会显示所有该po_num的修订记录
数据源头为in_po表和in_po_strategy表
要分为两个主板块显示, 左边是策略修订记录, 右边是明细修订记录 一个占用一半的界面位置 且有自己的标题和框体
整体框体要限高 需要鼠标滚轮查看

1. 策略修订记录
读取in_po_strategy表中po_num为当前po_num的全部数据
根据seq的unique的取值数量 定位多少次修改
V01通常为初始数据, 需要显示在最上方
后续的V##需要按照seq的L##中##的顺序从小到大排序
每个版本的信息需要对比之前版本信息,找出不同之处
在框体中展示修改内容
每个版本的备注也需要展示
注意每个版本的修订都需要放在每个版本的框体中,这些框体都必须在大的策略修订记录框体中
每个小版本的框体 中 修改日期date, 修改人by, 修改备注note,修改版本号seq,必须以高亮的形式放在框体内的最上方 你要去设计这个UI 类似于一个header的框体

除了初始记录是以名片形式展示
后续修订只需要展示 把什么内容修改什么内容 无需名片展示

2. 明细修订记录
读取in_po表中po_num为当前po_num的全部数据
根据seq的unique的取值数量 定位多少次修改
L01通常为初始数据, 需要显示在最上方
后续的L##需要按照seq的L##中##的顺序从小到大排序
每个版本的信息需要对比之前版本信息,找出不同之处
在框体中展示修改内容
每个版本的备注也需要展示
注意每个版本的修订都需要放在每个版本的框体中,这些框体都必须在大的明细修订记录框体中
每个小版本的框体 中 修改日期date, 修改人by, 修改备注note,修改版本号seq,必须以高亮的形式放在框体内的最上方 你要去设计这个UI 类似于一个header的框体
除了初始记录是以名片形式展示
后续修订只需要展示 把什么内容修改什么内容 无需名片展示
若出现删除订单信息时,也就是在某seq的action为delete时,sku为空时,显示操作位 删除订单
若出现删除订单后面还有更新的seq的时候, 删除订单版本号seq+1的显示为 恢复删除订单






[页面4] 删除当前订单
此页面点开后 会根据用户选择的po_num读取in_po表和in_po_strategy表中的数据
此页面需要采用 向导页面的公有页 global-wizard 来做
流程上分为以下步骤:
订单预览->完成删除
订单预览会展示 产品模块-订单管理 查看订单详情 中的信息展示
下方有确认删除按钮, 点击后会触发global-modal的密码验证,这个需要你根据相关模块去实现
通过验证后该订单会被删除
上传in_po表 po_num的行, action列要写入delete, seq列要写入当前po_num的seq的最大值+1 且sku为空, 就一行

注意要提示成功 失败




回到 采购订单管理 的 查看订单明细
这里的内容并没有更新我们做的修改
可能是逻辑问题
在订单明细信息框中

在表in_po中找到po_num的中,我们需要首先对action列为new的行且seq为L01作为初始数据
然后继续in_po中找到同po_num的行,但是action列为adjust的行,选取每个sku的对初始数据中满足的sku的行进行替换
注意, 这个替换流程必须遵seq行的L##中##的顺序, 需要从小的替换到大的 例如先替换L02, 然后L03....依次类推(L01为初始数据)
然后需要将action列为add但是seq为不L01的行的数据加入初始数据末端
然后需要将action列为delete且sku不为空的, 匹配初始数据中的sku,若匹配成功, 则从初始数据中删除
若完成全部比对之后, 初始数据为空, 则也判定该订单被删除, 需要在显示订单的顶端显示 该订单已被删除的tag
同时若action列为delete, 且SKU为空值, 则该po_num的订单整体被删除, 那这个po_num的订单信息在这个框体中需要显示整体被删除的高亮和tag提示
这个经过上述流程的初始数据, 就是最终显示的订单明细数据


同时我查看数据库记录显示 action列 备注列 
注意此处我们仅把流程3中传递给流程4检验的内容 上传到in_po表中 date为当前日期 seq的写入需要在现有该po_num的seq的最大值的 L##中##数字计数+1
注意这些上传的内容的行 若是修改原有数据的action列要写入adjust, 若是删除原有数据的行 action列要写入delete 若是新增数据 action列要写入add

此外 在流程3中 修改明细 少了一个备注要求用户录入(必须录入)
流程4中 需要验证这个备注 不能为 原始订单

同时流程6中上传时写入 note的 是这个用户必须写的备注

新建数据库表 in_po_final
po_date: YYYY-MM-DD 订单日期
po_update_date: YYYY-MM-DD 订单信息更新日期
po_num: 订单号
po_sku: 商品sku
po_quantity: 数量
po_price: 单价
po_note: 操作备注
po_seq: L## ##为数字
po_by: 操作人

现在需要在采购板块-新建采购订单向导 流程7 在现有上传数据库表的功能中新增上传表项目,原有上传项目不变,这里只是新增
上传数据库表 in_po_final
po_date: 传入上传in_po表的date YYYY-MM-DD
po_update_date: 传入操作当天日期 YYYY-MM-DD
po_num: 传入上传in_po表的po_num
po_sku: 传入上传in_po表的sku
po_quantity: 传入上传in_po表的qty
po_price: 传入上传in_po表的unit_price
po_note: 传入上传in_po表的note
po_seq: 传入上传in_po表的seq
po_by: 传入上传in_po表的by

现在需要在采购板块-订单管理-修改订单向导 流程6 在现有上传数据库表的功能中新增上传表项目,原有上传项目不变,这里只是新增
上传数据库表 in_po_final
上传逻辑为只上传明细6里的明细信息里的数据
也就是针对在这里在in_po表中action列为add/adjust/delete的记录时 同时上传in_po_final表
当action列为add时,该行对于in_po_final表的上传逻辑为 写入这行数据
po_date: 传入上传in_po表的date YYYY-MM-DD
po_update_date: 传入操作当天日期 YYYY-MM-DD
po_num: 传入上传in_po表的po_num
po_sku: 传入上传in_po表的sku
po_quantity: 传入上传in_po表的qty
po_price: 传入上传in_po表的unit_price
po_note: 传入上传in_po表的note
po_seq: 传入上传in_po表的seq, 注意除了此行之外,需要将同po_num下所有行的seq都改为这个seq
po_by: 传入上传in_po表的by

当action列为adjust时,该行对于in_po_final表的上传逻辑为 在原有数据行更新
首先要找到该记录上传时对应的修改项目针对于in_po表原内容的对照
这个可以通过在 订单修改向导的 第三流程里提交的信息找到匹配
然后通过这里的SKU, 原数量, 原单价,去定位到in_po_final表中对应的行
然后更新涉及的行, 也就是需要用新记录覆盖原有的行
po_date: 传入原上传in_po表的date YYYY-MM-DD
po_update_date: 传入操作当天日期 YYYY-MM-DD
po_num: 传入原上传in_po表的po_num
po_sku: 传入原上传in_po表的sku
po_quantity: 传入本次上传in_po表的qty
po_price: 传入本次上传in_po表的unit_price
po_note: 传入本次上传in_po表的note
po_seq: 传入本次上传in_po表的seq
po_by: 传入本次上传in_po表的by

当action为delete,sku不为空值时,该行对于in_po_final表的上传逻辑为 删除这行数据
首先要找到该记录上传时对应的删除项目针对于in_po表原内容的对照
这个可以通过在 订单修改向导的 第三流程里提交的信息找到匹配
然后通过这里的SKU, 原数量, 原单价,去定位到in_po_final表中对应的行
然后删除涉及的行

当action列为delete, 且SKU为空值
对于in_po_final表来说, 该po_num的订单整体被删除
所以需要删除in_po_final表中该po_num下所有行

新建数据库表 in_send_final
sent_date: YYYY-MM-DD 发货日期
sent_update_date: YYYY-MM-DD 发货信息更新日期
sent_logistic_num: 物流单号
po_num: 订单号
po_sku: 商品sku
sent_quantity: 数量
po_price: 单价
sent_note: 操作备注
sent_seq: L## ##为数字
sent_by: 操作人






新建数据库表 in_send
date_sent: YYYY-MM-DD 发货日期 用户录入
logistic_num: 物流单号 用户录入
price_kg: 每公斤价格 用户录入
total_weight: 总重量(KG) 用户录入
total_price: 总价格 用户录入
date_eta: YYYY-MM-DD 预计到达日期 用户录入
pallets: 托盘数 用户录入
usd_rmb: 结算汇率 自动获取或用户手动输入
payment: 是否已付款 N/Y
note: 操作备注 用户录入
seq: V## ##为数字


新建数据库表 in_send_list
date: YYYY-MM-DD 记录操作日期 
logistic_num: 物流单号
po_num: 订单号
sku: 商品sku
quantity: 数量
action: 操作类型 new/add/adjust/delete
note: 操作备注
seq: L## ##为数字


现在加入新功能 采购板块->新建发货单
需要在采购板块建立子路由 new_send
该板块首先要收到 用户管理权限-用户列表-配置权限 的约束, 该约束决定了用户是否可以访问该页面 你需要去严格审计 用户管理权限-用户列表-配置权限 的约束来实现这个管制
页面UI和风格采用同 采购板块->新增采购订单向导 一致的UI设计, APPLE UI风格设计
整体需要 采用 公有类里的 global-wizard向导页, gloal-modal弹窗密码验证, i18n多语言, global-file-uploader文件上传组件 苹果按钮开关(ui-toggle) 等组件
保持页面的连贯的UI风格, 注意每个用户可以交互要求输入和点击的框体,菜单(除开每个流程中前往下一个流程的按钮)都需要tooltips提示
以及每一个用户可交互的流程都需要 操作须知 且 tooltips提示
注意提示先去查看项目文件夹backend/static/里面的公有页面查找一切可用的组件在贯穿整个流程 能用的共有的不要新建
每一步都须有有一个返回上一步的按钮能让用户回到上一步骤操作,注意按钮需要右对齐
需要通过下面的流程和说明完成前后端配套设计
每个流程都要采用自己的html文件(非新建路由)

流程上分为以下步骤:
发货单说明->录入物流参数->检验物流数据->录入发货信息->检验货物数据->录入前预览->完成订单

每个流程界面和说明如下:
[流程1] 发货单说明
此页为一个操作说明页面, 说明内容为告诉用户这个流程是操作过程
大致的流程(你需要在操作须知里润色描述)就是填写物流信息, 然后验证物流信息, 然后填写发货信息, 然后验证发货信息, 查看最终物流整体单据预览信息, 验证并完成发货单
流程可以通过使用excel的文件上传功能,或者手动填写来完成
若选择用本地修改excel文件, 那么需要先下载excel模版, 该模板中会根据当前最新订单情况给与最新订单信息
用户可以选择下载后 在excel文件中有操作说明 需要按照操作说明填写
注意填写前仔细查验订单号, SKU, 发货数量是否正确, 仔细确认是否需要规整同步订货数量(这个很重要)
用户不得随意修改表格中的格式样式和输入内容框体以外的内容
可输入的框体以绿色高亮, 需要录入内容的列名以 红色, 橘色高亮, 其他地方严格禁止篡改
规整订货数量指 订货时一般采用整数订货, 但是根据实际的包装情况,会存在余数的超额或不足, 那么这样的情况下,发货时可能会超过或者不足订货数量, 此时规整指是否才需要更改订单,让这里的数量同步
用户填写完毕后, 在流程中点击上传按钮上传填好的excel文件,发货单就完成了
采用excel的方式会是一个非常快的流程过程,过程中不需要手动填写
上传的excel不会作为最终发货单, 最终发货单会由系统生成并提供下载
也需要告知用户 若果需要额外修改原始订单内容,本页面不具备这些功能, 要去 订单管理页面完成才能回来完成
在页面中有一个下载按钮, 需要提示用户点击这个下载按钮下载发货订单模板的excel文件填写后上传
若需要手动填写, 则只需要跟着流程走即可

在用户下载excel文件时, 系统需要先读取文件, 进行编辑, 然后提供下载
这个excel模版放在项目目录下 data/templates_csv/in_send_upload.xlsx
系统提取文件后,编辑完成后,文件重命名为 shipping_form_uptodate.xlsx
具体对于模版文件写入为
C2写入用户下载日期 YYYY-MM-DD

需要去读数据库in_po_final和in_send_final这两个表
首先读取in_po_final表的信息, 每一行数据以 po_num, po_sku二列为key
然后读取in_send_final表的信息, 每一行数据以 po_num, po_sku二列为key
两个表的key值相同时 我们算作一对, 我们需要用匹配行表in_po_final的po_quantity减去send_quantity 得到的值作为 这个key的未发量, 若未发量为0,则这个key在写入excel文件时被忽略
从excel模版的第9行开始
B列写入根据上述key里的po_num查询in_po_final表的po_date
C列写入上述key里的po_num
D列写入上述key里的po_sku
E列写入上述key里的po_quantity
F列写入根据上述key里的po_num,po_sku查询in_send_final表的send_quantity
G列写入上述key里的未发量
J列写入为空(默认值)
注意, 若未发量为0,则这个key在写入excel文件时被忽略,不会执行数据库写入
注意, 若在寻找配对key时,发现in_send_final表中没有配对key,则这个key在写入excel文件时
则同样要写入B,C,D,E列,但是F列写入0, G列写入po_quantity
若一个po_sku在一个po_num下有多次记录, 则需要根据其po_price的数值大小, 根据从高到低排序,在J列写入 价格位列# 例如价格位列1,价格位列2,价格位列3, 这里价格位列1是最高价的, 价格位列3是最低价的 


需要加入一个约束
若在流程中发现, in_po_final表为空
则需要在下载框体提示错误信息,并提示用户无有效订单, 请新增订单后才能发货, 且下一步的确认并开始按钮变灰色 无法交互
若在流程中发现, 所有Key计算的未发量都为0
则需要在下载框体提示错误信息,并提示用户当前订单已全部发货, 请新增发货单后才能继续发货, 且下一步的确认并开始按钮变灰色 无法交互

用户确认后点击进入下一步

[流程2] 模式选择
该页面需要有操作须知
该页面有2个选项按钮, 一个为: 手动输入(tooltip提示:手动输入发货信息), 一个为: Excel文件输入(tooltip提示:填写Excel文件导入发货信息) 
当用户不做选择时, 下一步按钮是灰色 无法交互
若用户选择上传填写好的Excel文件, 下方会显示一个文件上传框体, 用户点击上传按钮后, 会读取文件
该上传文件框体必须采用global-file-upload组件, 提示用户上传
读取文件后要检测该上传文件
1.C4,F4,I4,C6,F6,I6 有填写内容
2.H列和I列 从第9行开始, 只要B列那行有内容 就不能为空
3.除开上述情况, 任何地方不得和刚才第一流程中 下载给用户的excel文件内容有所不同 (仅限对应格子内的内容,第一流程内的excel下载文件中, 格子数据为空的不参与比较)
则为上传成功, 下一步按钮点亮 可以点击
否则提示错误信息,并提示用户上传的文件和下载的文件内容有所不同, 请重新上传, 下一步按钮变灰色 无法交互

若用户选择手动输入, 则不会出现文件上传框体,则下一步按钮点亮可以交互


流程2中 需要做一定修改
当用户在流程2中选择手动输入时, 流程3不变
若用户在流程2中选择excel文件输入, 则流程3中
需要读取通过流程2检测过的excel文件中的内容 写入流程3的对应框体中, 对应关系如下
excel文件中的 I4 写入流程3的 发货日期
excel文件中的 I6 写入流程3的 预计到达日期
excel文件中的 C4 写入流程3的 物流单号
excel文件中的 F4 写入流程3的 托盘数
excel文件中的 F6 写入流程3的 发货总重量
excel文件中的 C6 写入流程3的 物流单价

注意此处这些通过excel文件获取的数据, 是自动作为默认值填充进入原有手动录入的框体内, 但是用户可以修改

物流总价 保持和手动录入的规则不变
结算汇率 保持和手动录入的规则不变

同时需要在这个物流参数这个框体下, 多一个框体 告知用户次物流参数由上传excel文件获取,但是用户也可以点击框体编辑



[流程3] 录入物流参数
进入页面是一个名片式的框体, 会展示需要用户录入的物流参数
发货日期(tooltip提示:请选择发货日期): YYYY-MM-DD 
预计到达日期(tooltip提示:请选择预计到达日期): YYYY-MM-DD 用户选择
物流单号(tooltip提示:请输入物流定单号): 用户输入
托盘数(tooltip提示:请输入发货托盘总数,散货请填0): 用户输入, 只接受整数数字 且 要求大于等于0 
发货总重量(KG)(tooltip提示:请输入发货总重量,单位为公斤KG): 用户输入, 只接受数字 且 要求大于0, 会把用户录入的数字进一法取整
物流单价(RMB/公斤)(tooltip提示:请输入物流单价,单位为元RMB/公斤KG): 用户输入 必须是数字 要求大于0
物流总价格(RMB)(tooltip提示:物流总价格,单位为元RMB): 自动计算, 为发货总重量(KG)*物流单价(RMB/公斤) 当用户修改发货重量和单价的时候需要立刻刷新更新这个数字
结算汇率(tooltip提示:根据用户输入的发货日期,查询当日的USD/RMB汇率的买入价, 若无法查询会强制手动填写): 这一步你可以参考 采购板块->新建采购订单向导->流程2里的结算汇率的方式,写法,和要求 是一样的): 根据用户输入的发货日期,查询当日的USD/RMB汇率的买入价 只写入数据(非查询软件表格,而是查询网络数据,若查询不到,需要使用global-modal弹窗要用户录入, 提示用户必须自己填入) 这一步你可以参考 采购板块->新建采购订单向导->流程2里的结算汇率的方式,写法,和要求 是一样的
然后点击下一步进行检验

[流程4] 检验物流参数
发货日期: 需要验证这个日期必须比流程1中生成的内存中文件的明细信息中所有订单日期(也就是B列的第9行开始的所有存在的日期中最晚的日期)都要晚或者同天
预计到达日期: 需要验证这个日期比发货日期晚或者同天
物流单号: 需要读取in_send表的logistic_num去对比,确保输入的物流单号没有和旧数据重复,否则验证不通过
托盘数: 要求大于等于0 必须是整数
发货总重量(KG): 只接受数字 且 要求大于0, 会把用户录入的数字进一法取整
物流单价(RMB/公斤): 必须是数字 且大于0 (会把用户输入转化为float类型 四舍五入多余小数位数)
物流总价格(RMB): 自动计算, 无需验证
结算汇率: 如果是自动获取 无需验证 如果是用户录入, 必须是数字且大于1
验证不通过,需要在显示信息名片框体下面多一个框体显示错误内容, 提示用户返回修改,下一步的按钮是灰色且不可交互
验证通过, 下一步的按钮 点亮且可以交互进入下一流程

[流程5] 录入发货信息
需要展示一个列表框体
这个列表需要有下面的列, 和其数据说明
订单日期(tooltip提示: 该订单生成的日期): 系统生成,不可交互
订单号(tooltip提示: 该订单的订单号): 系统生成,不可交互
SKU(tooltip提示: 该订单中的SKU的最新版本): 系统生成,不可交互
订货量(tooltip提示: 该SKU的最新版订货量总计): 系统生成,不可交互
已发量(tooltip提示: 该SKU的最新版已发量总计): 系统生成,不可交互
未发量(tooltip提示: 该SKU的最新版未发量总计): 系统生成,不可交互
发货量(tooltip提示: 该SKU的当前运单发货量): (这个需要输入框给用户输入,只能接受数字,且不为负数和0) 需要用户录入
是否规整订货量(tooltip提示: 是否在系统中修改订货量,使其未发量为0,便于结算): (这个开关按钮, 采用公有组件的ui-toggle) 需要用户点击选择
SKU备注(tooltip提示: 该SKU的备注,若一个SKU在单个订单中存在多个价格版本,会被拆开, 在同订单同sku情况下,这里的价格等级数字越小,代表价格越高): (系统生成,不可交互)

该页面也需要详细的错做须知告知用户如何操作(你需要润色文案)
这页面的初始数据是根据系统数据实时生成
所有待发订单 都是最新数据
若用户之前选择的是手动录入,则需要仔细核对发货量
若用户之前选择的是excel上传,则表格中数据已经默认载入表格, 如果需要也可以在框体中继续修改
发货量需要根据实际填写, 如果某个产品不发货请留空不要填入0
规整订货量指因为包装的原因实际发货数量和当前订单数量造成差距很小的时候, 是否要修正订单数据, 让其数字匹配实际发货量方便结算, 开关打开就是需要修正, 关闭就是不修正
当规整订货开关被打开的时候, 此行的订货数数据会在系统中被自动修改, 使其待发量为0.

当第2流程中用户选取手动录入时
这写系统生成的数据列,和生成templateData的时候, 是一个逻辑

订单日期: 同templateData一个逻辑
订单号: 同templateData一个逻辑
SKU: 同templateData一个逻辑
订货量: 同templateData一个逻辑
已发量: 同templateData一个逻辑
未发量: 同templateData一个逻辑, 但是当用户输入发货量数据的时候必须实时刷新这个数
发货量: (这个需要输入框给用户输入,只能接受数字,且不为负数和0) 需要用户输入
是否规整订货量: (这个开关按钮, 采用公有组件的ui-toggle) 需要用户点击选择
SKU备注: 同templateData一个逻辑

当第2流程中用户选择excel上传数据的时候
会从把通过流程4验证的数据读取
订单日期: 同templateData一个逻辑
订单号: 同templateData一个逻辑
SKU: 同templateData一个逻辑
订货量: 同templateData一个逻辑
已发量: 同templateData一个逻辑
未发量: 同templateData一个逻辑, 但是当用户输入发货量数据的时候必须实时刷新这个数
发货量: (这个需要输入框给用户输入,只能接受数字,且不为负数和0) 默认值变成了 用户在上传文件通过流程4验证的该行的发货量, 用户也可以继续点击修改
是否规整订货量: (这个开关按钮, 采用公有组件的ui-toggle) 默认值变成了 用户在上传文件通过流程4验证的该行的是否规整订货量, 用户也可以继续点击修改
SKU备注: 同templateData一个逻辑

记得若是用户选择excel上传,则也需要一个提示框体提示用户, 上传数据已经默认载入表格, 如果需要也可以在框体中继续修改, 如同流程

当至少有一个行数据完整时(不考虑发货量列), 下一步的按钮 会被点亮 可交互, 否则按钮是灰色且不可交互
验证通过, 下一步的按钮 点亮且可以交互进入下一流程

[流程6] 检验发货数据
此流程为验证流程的数据是否合规
不论用户选择什么输入方式, 都需要把内容作为列表展示, 注意展示框体高度不能超额,需要有滚动条
在遇到错误的地方除了高亮标记该colomn, 此外还需要在在下方框体展示错误内容明细,且下一步按钮变成灰色不可交互

验证内容为 

发货量 必须为 正整数或者0 不接受其他值

若发货量大于其未发量 或者 
输入的发货量后 更新的后的未发量 小于发货量的20% 且 规整开关未打开 需要提示用户是否忘记规整订货量 注意这里不是报错 仅为提醒

若是流程2是用户选择excel上传, 若在流程5中用户对数据进行了修改(就是和上传数据不同) 组需要提示用户原有上传数据被修改, 哪些地方被修改 这也不是报错 仅为提醒

只有通过验证,下一步按钮会被点亮,可进入下一流程

[流程7] 录入前预览
读取 [流程4] 检验物流参数 里的名片显示栏 和 [流程6] 检验发货数据 里的的列表
把两个合并成为一个新的版本 将 [流程4] 检验物流参数 里的的列表 放在 [流程6] 检验发货数据 里的的列表 的上方
展示给用户查看 (注意不要把两个列表放在不同的框体里, 要合并成为一个框体, 注意限高, 能让用户用滚轮查看)

这里的确认按钮点击后会触发global-modal组件的密码功能让用户输入密码确认, 注意这里的密码由 用户权限管理-密码策略 决定 你需要设计相关功能获取正确的使用方式
当密码验证没有通过时, 不会执行数据库写入, 也不会执行文件写入, 而直接跳转[流程7]

当密码验证通过时, 会执行数据库写入, 也会执行文件写入, 而直接跳转[流程8] 这写写入功能会在流程8里解释

[流程8] 完成
这个页面用户提示用户操作完成或者失败, 且有返回按钮, 点击返回按钮后跳转到[流程1]
注意这个页面的设计需要和 新建采购订单 流程最后一步 UI设计保持一致

重点在于 数据库 和 文件的写入 请严格按照下面的规定和写入表的顺序执行

数据库表 in_send
date_sent: 写入流程3中通过验证的 发货日期
logistic_num: 写入流程3中通过验证的 物流单号
price_kg: 写入流程3中通过验证的 物流单价
total_weight: 写入流程3中通过验证的 发货总重量
total_price: 写入流程3中通过验证的 物流总价格
usd_rmb: 写入流程3中通过验证的 结算汇率
payment: 写入N
date_eta: 写入流程3中通过验证的 预计到达日期
pallets: 写入流程3中通过验证的 托盘数
note: 写字符串 原始发货单
by: 写入本次操作的用户名
seq: 写入 V01

数据库表in_send_list
在流程7中的明细列表 也就是 显示订单号 SKU, 发货量, 规整 这些数据的内容
这些数据有多少行 就需要上传入数据库表in_send_list多少行
上传对照为
date: 写入今天的日期 YYYY-MM-DD
logistic_num: 写入通过流程7验证物流信息的 物流单号
po_num: 写入通过流程7验证该行的 订单号
sku: 写入通过流程7验证该行的 SKU
quantity: 写入通过流程7验证该行的 发货量
price: 根据po_num,sku 去数据库表in_po_final中查询po_price,若出现多个 价格, 则需要通过流程5中的备注中的价位位列来定位价格 这个逻辑在流程5里有详细说明
action: 写入new
note: 写入字符串 原始发货单
by: 写入本次操作用户名
po_change: 写入通过流程7验证该行的 规整参数, 若打钩则写入 Y, 否则写入 N
seq: 写入 L01


数据库表in_send_final
在流程7中的明细列表 也就是 显示订单号 SKU, 发货量, 规整 这些数据的内容
这些数据有多少行 就需要上传入数据库表in_send_final多少行
注意 若流程7中某行的发货量为0, 则忽略不上传

sent_date: 写入流程7中的 发货日期 YYYY-MM-DD
send_update_date: 写入今天的日期 YYYY-MM-DD
sent_logistic_num: 写入流程7中的 物流单号
po_num: 写入通过流程7验证该行的 订单号
po_sku: 写入通过流程7验证该行的 SKU
sent_quantity: 写入通过流程7验证该行的 发货量
po_price: 根据po_num,po_sku 去数据库表in_po_final中查询po_price,若出现多个 价格, 则需要通过流程5中的备注中的价位位列来定位价格 这个逻辑在流程5里有详细说明
sent_note: 写入字符串 原始发货单
sent_seq: 写入 L01
sent_by: 写入本次操作用户名

数据库表in_po
当录入in_send_list时发现行 po_change写入Y时 需要做以下操作, 满足po_change为Y的行要逐一进行下列操作
步骤1,需要通过该行的po_num, sku, price去数据库表in_po中匹配 po_num,sku,unit_price 定位到数据行
步骤2,继续通过该行的po_num, sku, price去数据库表in_send_final中匹配 po_num,po_sku, po_price 定位到所有满足的数据行,在这些数据行读取sent_quantity的数据 并相加求和
步骤3,用步骤2的和取值 作为diff
步骤4,写入in_po表
date: 写入今天日期 YYYY-MM-DD
supplier_code: 写入步骤1定位到的数据行的 supplier_code
po_num: 写入步骤1定位到的数据行的 po_num
sku: 写入步骤1的sku
qty: 写入步骤3的diff
unit_price: 写入步骤1的price
currency: 写入步骤1的currency
usd_rmb: 写入步骤1的usd_rmb
by: 写入本次操作用户名
action: 写入adjust
note: 写入字符串 物流单据规整操作_{物流单号}
seq: 需要根据当前in_po表中的该po_num下的最大的seq号+1 例如之前最大的号是L03 现在写入L04

数据库表in_po_final
当数据写入in_po表后, 每写入一行 都需要更新一次in_po_final表
通过刚才写入in_po表的po_num, sku, unit_price去数据库表in_po_final中匹配 po_num,po_sku,po_price 定位到数据行
更新涉及的行, 也就是需要用新记录覆盖原有的行
po_date: 传入上面上传in_po表的date YYYY-MM-DD
po_update_date: 传入操作当天日期 YYYY-MM-DD
po_num: 传入上面上传in_po表的po_num
po_sku: 传入上面上传in_po表的sku
po_quantity: 传入上面上传in_po表的qty
po_price: 传入上面上传in_po表的unit_price
po_note: 传入上面上传in_po表的note
po_seq: 传入上面上传in_po表的seq
po_by: 传入上面上传in_po表的by


采购板块-发货单管理
列表页面 需要更换所有显示内容从 订单管理 为 发货单管理
操作须知先不动

列表显示信息需要改变
订单号 改为物流单号
供应商 去掉
订单日期 改为 发货日期
[新增] 预计到达
[新增] 托盘数
策略版本 改为 物流参数版本
明细版本 改为 货物明细版本
总额 改为 物流费用
[新增] 货物价值
文件不变
操作不变

列表信息来源需要改变
物流单号: 来自于所有的in_send表中的logistic_num 去重后的结果
发货日期: 来自于in_send表中上面logistic_num对应的date_sent
预计到达: 来自于in_send表中上面logistic_num对应的date_eta, 若有多个对应日期, 则选择seq列数字最大的日期, seq格式为L## ##是数字
托盘数: 来自于in_send表中上面logistic_num对应的pallets, 若有多个对应托盘数, 则选择seq列数字最大的托盘数, seq格式为L## ##是数字
物流参数版本: 来自于in_send表中上面logistic_num对应的seq, seq格式为L## ##是数字, 选取最大的数字的seq
货物明细版本: 来自于in_send_list表中上面logistic_num对应的seq, seq格式为L## ##是数字, 选取最大的数字的seq
物流费用:来自于in_send表中上面logistic_num对应的total_price, 若有多个对应物流费用, 则选择seq列数字最大的物流费用, seq格式为L## ##是数字
货物价值: 来自于上面logistic_num对应的in_send_final表中sent_logistic_num下 所有po_sku 行的 po_price * sent_quantity 的和
文件: 查看文件的路径为项目路径的 data/logistic/{物流单号}_invoice_Ver## 这里##代表版本号, 文件可能是各种格式 图片 DOC, excel,pdf等等
当用户上传新文件时, 也会存入data/logistic/{物流单号}_invoice_Ver##, 此时##会根据当时最大的号+1
操作: 暂时不变



采购板块-发货单管理 列表界面
眼睛按钮背后的逻辑修改
现有逻辑是完全从 采购板块-采购订单管理 里相同功能里复制过来的
所以要根据 发货单管理的 页面需求调整, 我们仅修改显示的内容和来源,保持原有的设计样式
1. 订单基础信息 修改为 物流单基础信息
供应商 修改为 物流单号 数据源于选择行的 物流单号
订货日期 修改为 发货日期 数据源于选择行的 发货日期
订单号 删除

2. 订单策略信息 修改为 物流单详细信息
第一行
预计到货日期: 数据源于上面信息中的 物流单号(logistic_num)去表in_send中获取date_sent的取值, 若存在多行, 选取seq列数字最大的date_sent, seq格式为 一个字母+## ##为数字
托盘数: 数据源于上面信息中的 物流单号(logistic_num)去表in_send中获取pallets的取值, 若存在多行, 选取seq列数字最大的pallets, seq格式为 一个字母+## ##为数字
发货总重量(KG)): 数据源于上面信息中的 物流单号(logistic_num)去表in_send中获取total_weight的取值, 若存在多行, 选取seq列数字最大的total_weight, seq格式为 一个字母+## ##为数字
第二行
物流单价(KG/RMB):数据源于上面信息中的 物流单号(logistic_num)去表in_send中获取price_kg的取值, 若存在多行, 选取seq列数字最大的price_kg, seq格式为 一个字母+## ##为数字
物流总价(RMB): 数据源于上面信息中的 物流单号(logistic_num)去表in_send中获取total_price的取值, 若存在多行, 选取seq列数字最大的total_price, seq格式为 一个字母+## ##为数字
结算汇率: 数据源于上面信息中的 物流单号(logistic_num)去表in_send中获取usd_rmb的取值, 若存在多行, 选取seq列数字最大的usd_rmb, seq格式为 一个字母+## ##为数字 汇率获取方式需要额外一个tag显示 数据源于上面信息中的 物流单号(logistic_num)去表in_send中获取mode的取值, 若存在多行, 选取seq列数字最大的mode, seq格式为 一个字母+## ##为数字
若取值为A tag写入自动获取, 若取值为M, tag写入手动填写
第三行
最新物流单明细版本:数据源于上面信息中的 物流单号(logistic_num)去表in_send中选取seq列数字最大的seg, seq格式为 一个字母+## ##为数字
操作人:数据源于上面信息中的 物流单号(logistic_num)去表in_send中获取by的取值, 若存在多行, 选取seq列数字最大的by, seq格式为 一个字母+## ##为数字
修订日期: 数据源于上面信息中的 物流单号(logistic_num)去表in_send中获取date_record的取值, 若存在多行, 选取seq列数字最大的date_record, seq格式为 一个字母+## ##为数字
第四行
备注 :数据源于上面信息中的 物流单号(logistic_num)去表in_send中获取note的取值, 若存在多行, 选取seq列数字最大的note, seq格式为 一个字母+## ##为数字


3. 订单明细信息 修改为 物流单货物信息
修订版本:  标题不变, 数据源于上面信息中的 物流单号(logistic_num)去表in_send_list中获取seq的取值, 若存在多行, 选取seq列数字最大的seq, seq格式为 一个字母+## ##为数字
操作人: 标题不变,数据源于上面信息中的 物流单号(logistic_num)去表in_send_list中获取by的取值, 若存在多行, 选取seq列数字最大的date_send, seq格式为 一个字母+## ##为数字
修订日期: 标题不变,数据源于上面信息中的 物流单号(logistic_num)去表in_send_list中获取date的取值, 若存在多行, 选取seq列数字最大的date, seq格式为 一个字母+## ##为数字
备注: 标题不变,数据源于上面信息中的 物流单号(logistic_num)去表in_send_list中获取note的取值, 若存在多行, 选取seq列数字最大的note, seq格式为 一个字母+## ##为数字
总价 修改为 货物价值 数据源于上面信息中的 物流单号(logistic_num)去表in_send_final中匹配sent_logistic_num获取该sent_logistic_num下所有行的 po_num * po_price的值相加的和



按钮设置
下载发货单(管理部门用)
系统读取模版文件 路径为项目目录下 data/templates_csv/in_send_output_mgmt.xlsx
表格对应写入如下 需要先了解下载按钮的页面信息来源

C4 写入 当前页的 物流单号 (logistic_num)
J4 写入 当前页的 发货日期 
J6 写入 当前页的 最新物流单明细版本
C8 写入 当前页的 物流单详细信息里的 操作人
J8 写入 当前页的 物流单详细信息里的 修订日期
C10 写入 当前页的 物流单详细信息里的 备注
C12 写入 当前页的 预计到货日期
F12 写入 当前页的 托盘数
J12 写入 当前页的 发货总重量(KG)
C14 写入 当前页的 物流单价(RMB/KG)
F14 写入 当前页的 物流总价(RMB)
J14 写入 当前页的 结算汇率
J16 写入 当前页的 修订版本
C18 写入 当前页的 物流单货物信息里的 操作人
J18 写入 当前页的 物流单货物信息里的 修订日期
C20 写入 当前页的 物流单货物信息里的 备注列

从第23行开始的数据列中
物流单货物信息下面的列表中, 每有一行就需要写入一行
在写入下列数据之前 要有先决条件
1. 根据订单号(po_num)去in_po_final中定位其旗下所有的数据, 以每行的po_sku,po_quantity,po_price为key
2. 同时去这个订单号(po_num)去in_send_final中定位其旗下所有数据, 先把同po_num, 同po_sku, 同po_price下的sent_quantity相加 合并得到以 po_sku, sent_quantity总和(前面相加后), po_price为key的行
3. 用in_po_final中的key下面的po_quantity 减去 in_send_final中的key的 sent_quantity总和 得到一个差值
若当前po_num下所有行的差值相加为0, 那么该po_num下所有的数据下列列表中统计计算时 都会被忽略 不论来自于什么表

订单日期(B列), 通过 当前行的 订单号(po_num) 去表 in_po_final中去匹配表中的po_num得到po_date, 这个数据在该po_num下取值是唯一的 无论有多少行
订单号(C列), 写入 当前行的 订单号
SKU(D列), 写入 当前行的 SKU
单价(E列), 写入 当前行的 单价 
订货量(F列), 通过 当前行的 SKU, 去in_po_final表中找到其对应po_sku的所有行po_quantity相加 
已发量(G列), 通过 当前行的 SKU, 去in_send_final表中找到其对应po_sku的所有行sent_quantity相加
发货量(H列), 写入 当前行的 发货数量 
未发量(I列), 上面的 订货量 减去 已发量 减去 发货量 的值
是否规整订货量(J列), 通过 当前行的 订单号(po_num),单价(po_price), SKU(po_sku), 去in_po_final表中找到其对应的note列, 若出现 物流单据规整操作_{订单号} 这个备注 且订单号满足匹配po_num 这里写入 是, 否则写入 否

下载文件命名为 {物流单号}_{发货日期}_current.xlsx



下载发货单(物流部门用)
系统读取模版文件 路径为项目目录下 data/templates_csv/in_send_output_warehouse.xlsx
表格对应写入如下 需要先了解下载按钮的页面信息来源

C4 写入 当前页的 物流单号 (logistic_num)
F4 写入 当前页的 发货日期 
F6 写入 当前页的 最新物流单明细版本
C8 写入 当前页的 预计到货日期
F8 写入 当前页的 托盘数
F10 写入 当前页的 物流单货物信息里的 修订版本


从第23行开始的数据列中
物流单货物信息下面的列表中, 每有一行就需要写入一行
在写入下列数据之前 要有先决条件
1. 根据订单号(po_num)去in_po_final中定位其旗下所有的数据, 以每行的po_sku,po_quantity,po_price为key
2. 同时去这个订单号(po_num)去in_send_final中定位其旗下所有数据, 先把同po_num, 同po_sku, 同po_price下的sent_quantity相加 合并得到以 po_sku, sent_quantity总和(前面相加后), po_price为key的行
3. 用in_po_final中的key下面的po_quantity 减去 in_send_final中的key的 sent_quantity总和 得到一个差值
若当前po_num下所有行的差值相加为0, 那么该po_num下所有的数据下列列表中统计计算时 都会被忽略 不论来自于什么表

[忽略] 订单日期(B列), 通过 当前行的 订单号(po_num) 去表 in_po_final中去匹配表中的po_num得到po_date, 这个数据在该po_num下取值是唯一的 无论有多少行
[忽略] 订单号(C列), 写入 当前行的 订单号
SKU(B列), 写入 当前行的 SKU
[忽略] 单价(E列), 写入 当前行的 单价 
订货量(C列), 通过 当前行的 SKU, 去in_po_final表中找到其对应po_sku的所有行po_quantity相加 
已发量(D列), 通过 当前行的 SKU, 去in_send_final表中找到其对应po_sku的所有行sent_quantity相加
发货量(E列), 写入 当前行的 发货数量 
未发量(F列), 上面的 订货量 减去 已发量 减去 发货量 的值
[忽略]是否规整订货量(J列), 通过 当前行的 订单号(po_num),单价(po_price), SKU(po_sku), 去in_po_final表中找到其对应的note列, 若出现 物流单据规整操作_{订单号} 这个备注 且订单号满足匹配po_num 这里写入 是, 否则写入 否

下载文件命名为 {物流单号}_{发货日期}_warehouse_current.xlsx





新增数据库表 po_status
字段如下
po_num:
po_date:
po_status:
po_currency:
po_price:
po_


in_po_final表和in_po表都需要新增两列在by列之前
status_send列 备注为 货物状态 只接受三个值, Y,N,W
payment_status列 备注为 付款状态 只接受三个值, P,U,D
在in_po表中在update_date列之前 新增列 po_date 备注 为订单日期 接受YYYY-MM-DD格式的日期录入

新增上传逻辑
在新建采购订单向导 的 流程7 上传数据库中 额外增加 写入in_po 和 in_po_final表的status_send 列 上传值为N(默认值), payment_status 列 上传值为U(默认值)
在in_po表上传逻辑中新增po_date列数据 录入为 用户在 新建采购订单向导中 第2流程中选择的 订单日期 注意需要格式化订单日期为 YYYY-MM-DD再上传

在修改订单向导中 对于status_send 列 和 payment_status 列 的值保持不变 使用默认值, po_date值也保持不变 采用原有订单日期

在新建采购订单向导 列表页面中
需要在订单号后面加一个tag
这个tag机制如下
1. 根据订单号(po_num)去in_po_final中定位其旗下所有的数据, 以每行的po_sku,po_quantity,po_price为key
2. 同时去这个订单号(po_num)去in_send_final中定位其旗下所有数据, 先把同po_num, 同po_sku, 同po_price下的sent_quantity相加 合并得到以 po_sku, sent_quantity总和(前面相加后), po_price为key的行
3. 用in_po_final中的key下面的po_quantity 减去 in_send_final中的key的 sent_quantity总和 得到一个差值
若当前po_num下所有行的差值相加为0, 则tag为 全部已发货
若当前po_num下所有行的差值相加 等于 用in_po_final中的key下面的po_quantity的总和 则tag为 在产未发货
其余情况, tag为 部分已发货



我们之前有完整复制 采购板块-订单管理-修改订单向导 到 采购板块-发货单管理-修改发货单向导
但是我们仅复制了内容, 并没有按照这把的实际功能进行修改,注意要尽可能保持页面UI不变和一致性,我们仅修改背后逻辑
现在需要对其内容进行修改 让这个功能能在这个 发货单管理 里面的可用

修改订单向导 更名为 修改发货单向导
[流程1]修改策略 更名为 修改物流
修改订单策略信息 更名为 修改物流单详细信息
第一排
预计到货日期: 原数据来源于 该发货单号(logistic_num) 在 in_send表 date_eta的取值, 若存在多行, 选取seq列数字最大的date_eta, seq格式为 一个字母+## ##为数字 修改选项为日期选择框
托盘数:原数据来源于 该发货单号(logistic_num) 在 in_send表pallets的取值, 若存在多行, 选取seq列数字最大的pallets, seq格式为 一个字母+## ##为数字 修改选项为输入框, 仅接受数字
第二排
物流单价(RMB/KG): 原数据来源于 该发货单号(logistic_num) 在 in_send表 price_kg的取值, 若存在多行, 选取seq列数字最大的price_kg, seq格式为 一个字母+## ##为数字 修改选项为输入框, 仅接受数字
发货总重量(KG):原数据来源于 该发货单号(logistic_num) 在 in_send表 total_weight的取值, 若存在多行, 选取seq列数字最大的total_weight, seq格式为 一个字母+## ##为数字 修改选项为输入框,仅接受数字
第三排
物流总价(RMB):原数据来源于 该发货单号(logistic_num) 在 in_send表 total_price的取值, 若存在多行, 选取seq列数字最大的total_price, seq格式为 一个字母+## ##为数字  这个依然为自动计算 等于上面的 物流单价 * 发货总重量
结算汇率:原数据来源于 该发货单号(logistic_num) 在 in_send表 usd_rmb的取值, 若存在多行, 选取seq列数字最大的usd_rmb, seq格式为 一个字母+## ##为数字  修改选项为输入框,仅接受数字

下方跳过策略小改 更名为 跳过物流修改

[流程2] 验证策略 更名为 验证物流
也就同样UI, 把流程1的传入数据放入 进行数据验证
预计到货日期: 不得早于该订单的订单日期, 可以通过
托盘数: 流程1传入过来的数据转化为整数, 只接受0或者大于0的整数
物流单价(RMB/KG): 只接受0以上的正数 记得需要格式化数字,去掉小数点末尾的0
发货总重量(KG): 只接受0以上的正数 记得需要格式化数字,去掉小数点末尾的0
物流总价(RMB):只接受0以上的正数 记得需要格式化数字,去掉小数点末尾的0
结算汇率:只接受0以上的正数 记得需要格式化数字,去掉小数点末尾的0


[流程3] 修改明细
修改订单明细 更名为 修改物流单货物明细
后面的版本号来源 需要 去读取 当前选择的物流单号(logistic_num) 在 in_send表 seq列的取值, 若存在多行, 选取seq列数字最大的seq, seq格式为 一个字母+## ##为数字

列表页面需要变为 下面的列名和对应的展示内容, 读取和内容逻辑 与 按钮 下载发货单(管理部门用) 中的货物明细那个列表一致
订单日期:
SKU: 
单价: 
订货量
已发量
发货量
未发量
是否规整订单

注意: 可给用户修改列为 发货量 和 是否规整订单 这2个列也需要有对应的修改列 是给用户修改的
新发货量 是 输入框
是否规整订单调整 是 ui_toggle 开关 打开就是修正 否则就是不修正

在最后一列也需要一个操作按钮, 可以删除发货 在这里的原理和之前保持一致 就是删除此行数据, 并且弹modal确认
删除后后的UI显示 Tag显示都不变,
删除后 删除按钮变成了回复按钮 点击可以恢复 这些都不变

右上角的按钮 新增SKU 更名为 新增发货 
功能也要调整
用户点开后 会新增一行在列表的最后, 要求必须输入完整新增行数据后才能继续新增行
在新增行按钮点击 新增行后
所有列都没有数据, 只有订单号有个下拉菜单
下拉菜单中会显示所有可用的订单号, 逻辑如下
1  在in_po_final表中的po_num列中获取所有unique的订单号
2. 根据订单号(po_num)去in_po_final中定位其旗下所有的数据, 以每行的po_sku,po_quantity,po_price为key
3. 同时去这个订单号(po_num)去in_send_final中定位其旗下所有数据, 先把同po_num, 同po_sku, 同po_price下的sent_quantity相加 合并得到以 po_sku, sent_quantity总和(前面相加后), po_price为key的行
4. 用in_po_final中的key下面的po_quantity 减去 in_send_final中的key的 sent_quantity总和 得到一个差值
5. 若当前po_num下所有行的差值相加为0, 那么这个订单号就不会再这个列表中被展示给用户选择
6. 除此之外, 我们也需要加入一个实时更新的逻辑, 也就是在新增入的行上面的所有用户已经有的行数据需要实时更新
7. 逻辑为, 除开之前已经排除掉的po_num, 还需要把当前页面中新增入的行之上 所有行的 未发量 为0的 和 是否规整订货量 开关被打开的 行做记录
这个记录需要采取 将其 订单号(po_num),SKU(po_sku),价格(po_price) 作为key, 差值作为0, 还原在流程5 的计算中去, 替换掉原有的对应的key的差值
重新验证该po_num是否所有行的差值相加为0, 若为0, 那么这个订单号在后续就不会再这个列表中被展示给用户选择
8. 这是个动态逻辑 所以需要当用户修改一个数量 或者修改规整订货量, 新增行并输入完整行数据后 立刻刷新显示
当用户选择 订单号 之后, 订单日期列会立刻写入该订单日期的数据, SKU列会出现一个下拉菜单, 下拉菜单中会根据该订单号(po_num)在in_po_final表中获取所有unique的SKU做为原始的SKU列表
但是这个列表需要有筛选逻辑
1. 根据订单号(po_num)去in_po_final中定位其旗下所有的数据, 以每行的po_sku,po_quantity,po_price为key 
2. 在同po_num, 同po_sku, 同po_price下的sent_quantity相加 合并得到以 po_sku, sent_quantity总和(前面相加后), po_price为key的行
3. 用in_po_final中的key下面的po_quantity 减去 in_send_final中的key的 sent_quantity总和 得到一个差值
4. 若该行差值为0, 则过滤掉这个 sku
当SKU列用户选择之后,若有多个价格(po_price), 那么价格列也会出现一个下拉菜单让用户选择
若当前SKU在同po_num下只有一个价格, 那么价格列的下拉菜单不会出现, 而是自动填入唯一的价格值
此时, 订货量, 已发量, 也会自动根据之前规则生成并补齐
订货量: 根据之前动态原则, 去掉所有的已经发货完成的po_num之后,从in_po_final中以当前选择的SKU(po_sku),单价(po_price)为key, 为统计这个表里列sent_quantity的总和
已发量: 根据之前动态原则, 去掉所有的已经发货完成的po_num之后,从in_po_sent中以当前选择的SKU(po_sku),单价(po_price)为key, 为统计这个表里列sent_quantity的总和
若当前SKU在同po_num下有多个价格(po_price), 价格列出现的所有unique的价格列表作为原始列表
但是该列表有筛选机制
1. 根据订单号(po_num)去in_po_final中定位其旗下所有的数据, 以每行的po_sku,po_quantity,po_price为key 
2. 在同po_num, 同po_sku, 同po_price下的sent_quantity相加 合并得到以 po_sku, sent_quantity总和(前面相加后), po_price为key的行
3. 用in_po_final中的key下面的po_quantity 减去 in_send_final中的key的 sent_quantity总和 得到一个差值
4. 若该行差值为0, 则过滤掉这个 价格
当用户选择一个价格后 也会根据机制刷新出订货量 已发量(上面有详细说明)

发货量需要用户填入(用户只能填写不为0整数数字), 未发量会被自动计算吗, 当未发量为负的时候 会发橙色光
若用户在后面的是否规整订货量 的开关打开了, 那么这一行的 po_num,SKU(po_sku),单价(po_price)为key 的差值也记作0, 记住在动态机制中要采用


修改备注 把描述中 原始订单 替换成 原始发货单




回到 采购板块-修改发货单向导-流程6
这个页面的设计 和 采购板块-修改订单向导 的流程6类似


上传数据库逻辑很多 如下

数据库表in_send
若流程5中 物流参数 板块有修改,则需要上传, 若没有修改, 则不上传
下列参数中, 若有被修改的,需要上传修改后的值, 若没有修改的, 则上传原有的值
date_sent: 和原有的date_sent一致 (这个项目是不可修改的)
logistic_num: 和原有的logistic_num一致 (这个项目是不可修改的)
price_kg: 传入流程5中通过验证的 物流参数 板块的 物流单价
total_weight: 传入流程5中通过验证的 物流参数 板块的 物流总重
total_price:传入流程5中通过验证的 物流参数 板块的 物流总价
usd_rmb: 传入流程5中通过验证的 物流参数 板块的 结算汇率
mode: 传入流程5中通过验证的 物流参数 板块的 结算汇率获取方式 若是自动获取 写入A, 否则 写入M
payment: 和原有payment一致(这个项目是不可修改的)
date_eat:传入流程5中通过验证的 物流参数 板块的 预计到货日期 YYYY-MM-DD
note: 传入流程5中通过验证的 物流参数 板块的 备注
date_record: 传入今日日期 YYYY-MM-DD
by: 传入登录操作的用户名
seq: 在in_send的该logistic_num下找到最大的seq, 然后+1 seq的值结构为V## ##是数字

数据库表in_send_list
若流程5中 修改物流单货物明细 板块有内容,则需要上传, 若没有内容, 则不上传,每有一行信息就需要上传一行, 注意写入时有新数据时要写入新数据的值 不写入老数据的值
date: 写入当天日期 YYYY-MM-DD
logistic_num: 和原有的logistic_num一致 (这个项目是不可修改的)
po_num: 写入当前行的po_num
sku: 写入当前行的sku
price: 写入当前行的单价
quantity: 写入当前行的发货量
action: 若为用户新增行, 则写入add, 若用户修改当前行内容则写入adjust, 若用户删除行则写入delete
note: 写入修改物流单货物明细 板块的 修改备注 框里的内容
by: 写入当前登录操作的用户名
seq: 在in_send_list的该logistic_num下找到最大的seq, 然后+1 seq的值结构为L## ##是数字
po_change: 若当前行的规整订单量开关打开, 则写入Y, 否则写入N

数据表in_send_final
若有数据写入in_send_list,写入完成后需要立刻更新in_send_final 逻辑如下
根据写入in_send_list的logistic_num, po_num, sku, price为key, 去in_send_final以sent_logistic_num, po_num, po_sku, po_price为key, 两key匹配则作为配对
下面三种情况要判定结束后一起写入, 也就是先判定全部再一起写入
情况1:
若写入in_send_list的action为add, 则需要在in_send_final中新增一行数据
send_date: 写入该logistic_num的发货时间
send_update_date: 写入今天的日期 YYYY-MM-DD
sent_logistic_num: 写入该行在in_send_list的logistic_num
po_num: 写入该行在in_send_list的po_num
po_sku: 写入该行在in_send_list的sku
sent_quantity: 写入该行在in_send_list的quantity
po_price: 写入该行在in_send_list的price
sent_note: 写入该行在in_send_list的修改备注
sent_seq: 在in_send_list的该logistic_num下找到最大的seq, 然后+1 seq的值结构为L## ##是数字
sent_by: 写入当前登录操作的用户名
情况2:
若写入in_send_list的action为adjust, 则需要在in_send_final中更新一行数据, 也就是完全覆盖那行旧数据
通过上述描述的两个key配对, 通过in_send_list的key 找到in_send_final中key对应的行, 然后更新该行
send_date: 写入该logistic_num的发货时间
send_update_date: 写入今天的日期 YYYY-MM-DD
sent_logistic_num: 写入该行在in_send_list的logistic_num
po_num: 写入该行在in_send_list的po_num
po_sku: 写入该行在in_send_list的sku
sent_quantity: 写入该行在in_send_list的quantity
po_price: 写入该行在in_send_list的price
sent_note: 写入该行在in_send_list的修改备注
sent_seq: 在in_send_list的该logistic_num下找到最大的seq, 然后+1 seq的值结构为L## ##是数字
sent_by: 写入当前登录操作的用户名
情况3:
若写入in_send_list的action为delete, 则需要在in_send_final中删除一行数据
通过上述描述的两个key配对, 通过in_send_list的key 找到in_send_final中key对应的行, 然后删除该行

在上述操作完成后,若在写入in_send_list的行中po_change为Y的行也要做数据写入的操作 这个也是需要全部判定结束 一起写入 逻辑如下
在某行中发现po_change为Y
则需要在in_send_list中以该行的po_num,sku,price为key, 去in_po表中以po_num,po_sku,po_price为key做匹配, 筛选数据后, 选择seq 尾号2位数字最大的行, 获取该行的po_quantity
然后用在in_send_list中key行的quantity作为diff, 用diff替换po_quantity
此操作在数据表in_po表进行, 写入为
update_date: 写入今天日期 YYYY-MM-DD
supplier_code: 写入原来的数据
po_num: 写入原来的数据
po_sku: 写入原来的数据
po_quantity: 写入我们刚才描述用于更新的diff
po_price: 写入原来的数据
currency: 写入原来的数据
usd_rmb: 写入原来的数据
by: 写入当前登录操作的用户名
action: 写入adjust
note: 写入 物流单据规整操作_{物流单号}
seq: 在in_po的该po_num下找到最大的seq, 然后+1 seq的值结构为P## ##是数字

写入in_po完成之后
要更新in_po_final表
通过刚才写入in_po表的po_num, po_sku, po_price去数据库表in_po_final中匹配 po_num,po_sku,po_price 定位到数据行
更新涉及的行, 也就是需要用新记录覆盖原有的行
po_date: 保持不变
po_update_date: 传入操作当天日期 YYYY-MM-DD
po_num: 保持不变
po_sku: 保持不变
po_quantity: 传入刚才上传in_po表的po_quantity
po_price: 保持不变
po_note: 传入刚才上传in_po表的note
po_seq: 传入刚才上传in_po表的seq
po_by: 传入刚才上传in_po表的by

注意 若po_quantity 为0, 则需要删除此行



发货订单管理-查看发货单详情-删除发货单 功能
用户点击后 进入删除 向导页面 你先恢复他的功能 我们的之前的删除页面来自有 订单管理-删除订单 你要适配到发货订单管理-查看发货单详情-删除发货单 功能
所以要做API指向修改
此外 第一流程的 订单基础信息 更名为 发货单基本信息
内容显示的是该发货单的 查看发货单详情 里物流单基础信息
订单策略 更名为 物流单详细信息
内容显得是该发货单的 查看发货单详情 里物流单详细信息
订单明细 更名为 物流单货物信息
内容显得是该发货单的 查看发货单详情 里物流单货物信息
用户点击 确认删除 按钮后 会触发global-modal管理的密码输入 这个密码收到 用户权限管理-密码策略 的 管理 你需要审计这个功能 获得背后逻辑 去完善才能使用 
密码输入正确后 会进入流程2

第二流程
会上传数据库文件 并显示结果
上传数据库文件逻辑如下
数据库表 in_send_list
先去in_send_final表中, 找到sent_logistic_num发货单号为该发货单号的所有行吗, 以po_num,po_sku,po_price, sent_seq为key
去in_send_list表中 匹配 po_num, sku, price, seq找到每一行对应行
复制这些行, 但是seq在原有基础上+1, note: 写入用户流程1的 删除备注
action: 写入adjust, quantity: 写入0, po_change写入N, 其他不变

同时, 在in_send_list中查到满足上面key匹配的某行po_change为Y的时候, 在上面操作的基础需要同步操作下面写入
需要根据该行的 po_num,sku,price为key 去 in_po表以po_num,po_sku,po_price为key匹配, 筛选数据后, 选择seq尾号2位数字最大的行
复制这些行, 但是seq在原有基础上+1, note: 写入用户流程1的删除备注
action: 写入adjust
po_quantity的写入特殊 要遵循以下要求
需要根据该行的 po_num,po_sku,po_price为key 重新筛选表in_po, 然后选取为当前seq数字-1的行的 po_quantity 写入, 其他不变

然后更新in_po_final表和in_send_final表
更新逻辑为
in_po_final
通过刚才写入in_po表的po_num, po_sku, po_price去数据库表in_po_final中匹配 po_num,po_sku,po_price 定位到数据行
更新涉及的行, 也就是需要用新记录覆盖原有的行
po_date: 保持不变
po_update_date: 传入操作当天日期 YYYY-MM-DD
po_num: 保持不变
po_sku: 保持不变
po_quantity: 传入刚才上传in_po表的po_quantity
po_price: 保持不变
po_note: 传入刚才上传in_po表的note
po_seq: 传入刚才上传in_po表的seq
po_by: 传入刚才上传in_po表的by

注意 若po_quantity 为0, 则需要删除此行


in_send_final
根据写入in_send_list的logistic_num, po_num, sku, price为key, 去in_send_final以sent_logistic_num, po_num, po_sku, po_price为key, 两key匹配则作为配对
若写入in_send_list的action为adjust, 则需要在in_send_final中更新一行数据, 也就是完全覆盖那行旧数据
通过上述描述的两个key配对, 通过in_send_list的key 找到in_send_final中key对应的行, 然后更新该行
send_date: 写入该logistic_num的发货时间
send_update_date: 写入今天的日期 YYYY-MM-DD
sent_logistic_num: 写入该行在in_send_list的logistic_num
po_num: 写入该行在in_send_list的po_num
po_sku: 写入该行在in_send_list的sku
sent_quantity: 写入该行在in_send_list的quantity
po_price: 写入该行在in_send_list的price
sent_note: 写入该行在in_send_list的修改备注
sent_seq: 在in_send_list的该logistic_num下找到最大的seq, 然后+1 seq的值结构为L## ##是数字
sent_by: 写入当前登录操作的用户名

注意 若sent_quantity 为0, 则需要删除此行



恢复删除订单按钮 逻辑修改

上传数据库文件逻辑如下
in_send_list表(写入不要逐行写入,是一起写入 判定也是同时进行)
步骤1: 使用被删除的发货单号 logistic_num, 在in_send_list中找到该 logistic_num下所有的行, 选取note列备注以 删除订单 这个字符串开头的行, 在这些行里选取seq列数字最大的这些行
在选择的这些行里, 记住此时的seq为当前版本号
步骤2: 使用步骤1最终选的这些行的logistic_num,po_num,sku,price为key, 逐行操作, 以步骤1的seq为当前版号, 在本表中去找seq列-1的行,的quantity列
当找到匹配行时, 记住这个quantity列的值, 复制该行所有信息 写入 in_send_list表中, 但是seq在当前seq基础上+1, note: 写入 恢复删除_{操作人}_{今天日期}
action: 写入adjust, quantity: 写入刚才记住的quantity, 其他不变, 若在匹配时seq-1找不到匹配行, 就继续-1, 直接到找到匹配行, 这个不用担心找不到 因为这个是表格的固有逻辑

in_po表(写入不要逐行写入,是一起写入 判定也是同时进行)
录入完in_send_list表后, 若发现在刚才新录入的行中有po_change为Y的行, 则需要立刻处理in_po表,这个也是需要全部判定结束 一起写入 逻辑如下
需要在in_send_list中以该行的po_num,sku,price为key, 去in_po表中以po_num,po_sku,po_price为key做匹配, 筛选数据后, 选择seq 尾号2位数字最大的行, 获取该行的po_quantity
然后用在in_send_list中key行的quantity作为diff, 用diff替换po_quantity
此操作在数据表in_po表进行, 写入为
update_date: 写入今天日期 YYYY-MM-DD
supplier_code: 写入原来的数据
po_num: 写入原来的数据
po_sku: 写入原来的数据
po_quantity: 写入我们刚才描述用于更新的diff
po_price: 写入原来的数据
currency: 写入原来的数据
usd_rmb: 写入原来的数据
by: 写入当前登录操作的用户名
action: 写入adjust
note: 写入 恢复删除发货单_恢复订单调整项_{操作人}_{今天日期}
seq: 在in_po的该po_num下找到最大的seq, 然后+1 seq的值结构为P## ##是数字

in_send_final
更新in_send_final 逻辑如下
根据写入in_send_list的logistic_num, po_num, sku, price为key, 去in_send_final以sent_logistic_num, po_num, po_sku, po_price为key, 两key匹配则作为配对
因为写入in_send_list的action为adjust, 所以需要在in_send_final中更新一行数据, 也就是完全覆盖那行旧数据
通过上述描述的两个key配对, 通过in_send_list的key 找到in_send_final中key对应的行, 然后更新该行
send_date: 写入该logistic_num的发货时间
send_update_date: 写入今天的日期 YYYY-MM-DD
sent_logistic_num: 写入该行在in_send_list的logistic_num
po_num: 写入该行在in_send_list的po_num
po_sku: 写入该行在in_send_list的sku
sent_quantity: 写入该行在in_send_list的quantity
po_price: 写入该行在in_send_list的price
sent_note: 写入该行在in_send_list的修改备注
sent_seq: 在in_send_list的该logistic_num下找到最大的seq, 然后+1 seq的值结构为L## ##是数字
sent_by: 写入当前登录操作的用户名
注意 若sent_quantity 为0, 则需要删除此行

in_po_final
更新逻辑为
通过刚才写入in_po表的po_num, po_sku, po_price去数据库表in_po_final中匹配 po_num,po_sku,po_price 定位到数据行
更新涉及的行, 也就是需要用新记录覆盖原有的行
po_date: 保持不变
po_update_date: 传入操作当天日期 YYYY-MM-DD
po_num: 保持不变
po_sku: 保持不变
po_quantity: 传入刚才上传in_po表的po_quantity
po_price: 保持不变
po_note: 传入刚才上传in_po表的note
po_seq: 传入刚才上传in_po表的seq
po_by: 传入刚才上传in_po表的by

注意 若po_quantity 为0, 则需要删除此行

in_send_list写入要先做 做完再去做in_po写入(若前面有po_change为Y的行写入)
然后做in_send_final和in_po_final(若需要)的更新
顺序不能变


现在修复 采购板块 发货单管理  历史记录
策略修订记录 更名为 物流单信息修订记录
需要更新为 对应 发货单管理的 的 参数版本


明细修订记录 更名为 物流单货物修订记录
需要更新为 对应 发货单管理的 的 明细版本



采购订单管理 列表页面中 总额 列 需要显示货币tag 在金额前面
且需要同时展示RMB和USD, 两者需要根据货物实际的计算方式 根据 该订单里的汇率得出 

查看发货详情 物流单货物信息
在单价列前面缺少 货币 列 
这个列的值需要根据 订单号 sku 单价 回到 in_po表的最新seq去获取每行的货币币种
在显示货物价值的时候 需要同时展示 RMB和USD 根据该订单所属的最新汇率策略算出
注意区分 这里的订单里的汇率 是跟随订单的汇率策略的 不是物流单

发货发货单管理 列表页面中,  物流费用, 货物价值 也需要显示货币tag 在金额前面 
物流费用
需要同时展示RMB和USD, USD需要由物流单的结算汇率算出
货物价值
也需要同时展示RMB和USD, 这个需要根据行货物返回


新建立 数据库表
in_receive
字段如下
sent_date: 记录发货日期 YYYY-MM-DD
eta_date_final:记录最新预计到达日期 YYYY-MM-DD
receive_date:记录实际到达日期 YYYY-MM-DD
update_date: 记录操作当天日期 YYYY-MM-DD
logistic_num:记录物流单号
po_num:记录采购订单号
po_sku:记录采购订单商品sku
sent_quantity:记录发货数量
receive_quantity:记录入库数量
po_price:记录采购订单商品单价
action:记录操作类型
note:记录操作备注
seq:记录版本号
by:记录操作人

新建立 数据库表(不要建立自增项index这种)
in_receive_final
字段如下
eta_date_final:记录最新预计到达日期 YYYY-MM-DD
receive_date:记录实际到达日期 YYYY-MM-DD
update_date: 记录操作当天日期 YYYY-MM-DD
logistic_num:记录物流单号
po_num:记录采购订单号
po_sku:记录采购订单商品sku
sent_quantity:记录发货数量
receive_quantity:记录入库数量
po_price:记录采购订单商品单价
note:记录操作备注
seq:记录版本号
by:记录操作人

in_diff
record_num: 记录号 自动生成 {logistic_num}_{receive_date}
logistic_num: 物流单号
po_num: 订单号
receive_date: 收货日期 YYYY-MM-DD
po_sku: 订单商品sku
po_quantity: 订单商品数量
sent_quantity: 发货数量
receive_quantity: 收货数量
diff_quantity: 差异数量
status: 解决状态 (pending/resolved)
action: 操作类型 (add/adjust)
note: 操作备注
seq: 版本号
by: 操作人


in_diff_final
record_num: 记录号 自动生成 {logistic_num}_{receive_date}
logistic_num: 物流单号
po_num: 订单号
receive_date: 收货日期 YYYY-MM-DD
po_sku: 订单商品sku
po_quantity: 订单商品数量
sent_quantity: 发货数量
receive_quantity: 收货数量
diff_quantity: 差异数量
status: 解决状态 (pending/resolved)
note: 操作备注
seq: 版本号
by: 操作人

新建立功能 货物入库 在采购板块
需要新建立路由(receive)在采购板块下作为子路由
该功能需要采用公有组件的 global-wizard来做
分为以下流程, 每个流程需要分开html管理(不是分路由)

流程为 
选择日期->入库选择->收货确认->验证数据->完成

流程先做好, 我们再添加各个流程逻辑


流程2



使用用户在流程1中选择的入库时间, 去in_send_final表中以sent_date为key
选取所有send_date早于或等于入库时间的行
得到满足行的sent_logistic_num的列表, 通过这些unique的sent_logistic_num, 获取每一个对应的sent_date 作为发货时间
通过这个sent_logistic_num和sent_seq去 匹配 in_send表中的logistic_num和seq, 获取最新的 date_eta 作为预计到达时间
通过这个sent_logistic_num和sent_seq去 匹配 in_send表中的logistic_num和seq, 获取最新的 pallets 作为 货板数

加入一个判定, 判断一个发货单是否已经被入库, 若入库, 那么在流程1用户选择日期后, 流程2在筛选发货单时,会被排除掉
查询表in_send_final表和in_receive_final表, 以用户流程1选择的日期为截止日期
从表in_send_final以此发货单号为send_logistic_num找到所有满足的行
以满足行的 po_num,po_sku,po_price为key 查询sent_quantity为发货数量
从表in_receive_final表中匹配同物流单号(logistic_num)下的行以po_num,po_sku,po_price为key查询receive_quantity为入库数量
1.若收货数量不为0,若每一行的发货数量和入库数量一致, 则排除这个发货单号下所有行
2.若收货数量不为0,若至少有一行的发货数量和入库数量不一致
  2.1 根据logistic_num去in_diff_final表中找到满足logistic_num的行,每一行都需要选取seq列(D##,##为数字)最大值下, 
  2.1.1 若所有行的status列 都是 resolved, 排除这个发货单号下所有行
  2.1.2 若所有行的status列 都是 pending, 排除这个发货单号下除了匹配行之外的所有行

3.若收货数量为0, 按照下面来操作
然后以满足的入库时间验证in_send_final表中的sent_logistic_num作为框体列表给用户选择
这个选择框体 有四个sub框体显示数据, 依次对应 发货单号,发货时间, 预计到达时间, 货板数
同时下方会出现一个列表框体,当用户选择上面的任何一个发货单号框体时会出现
框体中会显示根据该发货单号的所有货物明细,列表字段如下
SKU: 数据源于in_send_final表中的po_sku
发货数量: 数据源于in_send_final表中的po_sku对应的sent_quantity, 注意此处需要无视po_price, 合并po_sku对应的sent_quantity
入库数量: 用户录入 只能是数字 不能为负

列表顶端右侧有一个按钮 全选, 点击后会将所有货物的入库数量框体设置为发货数量数字
列表顶端右侧还有一个按钮, 确认, 点击后会记录这个表格去内存, 然后用户可以重新选择 上面框体中的其他发货单号
同时上面的发货单框体中 根据当前内存里记录,有被入库的 需要有tag显示, 若一个订货单被全部入库, 则tag为 全部入库, 若一个订货单被部分入库, 则tag为 部分入库, 若一个订货单全部未入库, 则tag为 发货中

这些被内存记录的数据会传递到下一个流程

流程3
此页是一个列表页 展示从流程2传入的数据
发货单号: 用户选择的发货单号
发货时间: 发货单号对应的发货时间 YYYY-MM-DD
预计到达: 发货单号对应的预计到达时间 YYYY-MM-DD
实际到达: 用户流程1选择的日期 YYYY-MM-DD
SKU:流程2传入的SKU
发货数量: 流程2传入的发货数量
入库数量: 流程2传入的入库数量
误差: 发货数量-入库数量 如果大于0 tag 收货数量不足发货量, 如果小于0, 收货数量大于发货量

让用户确认后

用户从流程3点击确认入库 进入流程4会触发global-modal弹出密码验证 该密码验证收到 用户权限管理-密码策略 控制
审计这个功能, 获取正确的使用方式, 让密码控制生效


流程4

数据库表上传逻辑
in_receive(每一行SKU收货都要写入一行或更多(根据情况))
根据用户流程3中传入流程4的数据
对于每行数据 先检验 需要写入多少行
步骤1, 首先需要用用户录入的logistic_num,po_num,po_sku去in_send_final表中匹配sent_logistic_num,po_num,po_sku 查看有多少行, 有多少行就需要写入多少条
步骤2, 若出现多行的情况, 只会出现在有误差的纯在的情况, 发现收到的货比理论多的情况, 记录多的数量加入进入po_price最高的项目, 保持低价格产品的数量匹配,若发现收货比理论少的情况, 记录差额去po_price最低的项目, 保持高价格产品的数量匹配

send_date: 根据logistic_num去in_send_final匹配sent_logistic_num, 然后获取sent_date
eta_date_final: 根据logistic_num去in_send_final匹配sent_logistic_num, 然后获取sent_seq. 然后通过sent_seq和sent_logistic_num去in_send匹配seq和logistic_num, 然后获取date_eta
receive_date:用户流程1选择的实际到达时间 YYYY-MM-DD
update_date: 写入今天日期 YYYY-MM-DD
logistic_num:用户流程2选择的发货单号
po_num:用户流程2选择的 订单号
po_sku:用户流程2选择的 SKU
sent_quantity: 根据用户流程2选择的发货单号, 订单号, SKU去in_send_final表中匹配sent_logistic_num,po_num,po_sku获取的send_quantity (判定调整项)
receive_quantity:用户流程2选择的入库数量
po_price:用根据用户流程2选择的发货单号, 订单号, SKU去in_send_final表中匹配sent_logistic_num,po_num,po_sku获取的po_price(判定写入多行项, 有几个写几行)
action: 写入new
note:用户写入 原始入库
seq:写入V01
by:写入当前操作的用户名

若在in_receive中处理到存在差异的行的数据, 则需要写入in_diff_final表
存在差异指流程2中 发货数量和实际数量不一致的项数据行
in_diff_final
record_num: 记录号 自动生成 {logistic_num}_{receive_date}
logistic_num: 存在差异的行所属的发货单号
po_num: 在差异的行所属订单号
receive_date: 存在差异的行的收货日期 YYYY-MM-DD
po_sku: 存在差异的行所属订单商品sku
po_quantity: 根据po_num,po_sku去in_po_final匹配po_num,po_sku获取的满足条件的行的po_quantity相加的和
sent_quantity: 存在差异的行所属发货数量
receive_quantity: 存在差异的行所属收货数量
diff_quantity: 存在差异的行所属的差异数量sent_quantity-receive_quantity
status: 写入pending
action: 写入new
note: 写入 原始入库差异
seq: 写入 D01
by: 写入当前操作的用户名

##
若有数据写入in_diff表 也需要把这些数据写入in_diff_final表(数据都一致)
record_num: 
logistic_num: 
po_num: 
receive_date: 
po_sku: 
po_quantity: 
sent_quantity:
receive_quantity: 
diff_quantity: 
status:
note:
seq:
by:


对于in_receive表写入的每一行,都需要写入in_receive_final表
in_receive_final表写入(内容都一致,特殊看备注)
eta_date_final:
receive_date:
update_date: 
logistic_num:
po_num:
po_sku:
sent_quantity:
receive_quantity:
po_price:
note:
seq:
by:


发货单管理 列表界面
物流单号 后面要新增tag
表in_send_final以此发货单号为send_logistic_num找到所有满足的行
以满足行的 po_num,po_sku,po_price为key 查询sent_quantity为发货数量
表in_receive_final表中匹配同物流单号(logistic_num)下的行以po_num,po_sku,po_price为key查询receive_quantity为入库数量

1.若收货数量不为0,若每一行的发货数量和入库数量一致, 则tag为 全部已入库 然后操作中不得修改和删除
2.若收货数量不为0,若至少有一行的发货数量和入库数量不一致, 操作中不得修改和删除
  2.1 根据logistic_num去in_diff_final表中找到满足logistic_num的行,每一行都需要选取seq列(D##,##为数字)最大值下, 
  2.1.1 若所有行的status列 都是 resolved, 则tag为 入库有差异:已解决
  2.1.2 若所有行的status列 都是 pending, 则tag为 入库有差异:未解决

3.若收货数量为0, 则tag为 货物在途中, 操作中可以修改和删除


新建立功能 入库管理(receive_mgmt)
这个是一个新的子路由 放在 采购板块
页面设计和逻辑照搬 发货单管理 的列表界面 其中涉及到的功能全部留白,日后补充

列表页需要显示的表头为
入库日期: 物流单号 对应用户选择的入库日期
入库物流单号: 读取in_receive_final表所有唯一的 物流单号
入库状态: 和 发货单管理-列表界面 物流单号后面的tag一致
入库明细版号: 读取in_receive_final表该物流单号下seq列(D##,##为数字)最大值, 日期为update_date
文件(2个按钮,逻辑后补,框架一样)
操作(4个按钮,逻辑后补,框架一样)


功能 查看入库单(眼睛按钮)

页面设计 和 查看发货单详情 完全一样 但是只有两个框 物流信息和入库货物明细
但是没有任何下载功能,也就是去掉两个下载按钮

物流信息
物流单号: 就是该入库单的物流单号
发货日期: 就是该入库单用户入库日期 in_receive_final表的该物流单号logistic_num下的receive_date (这个有多行也无所谓, 因为入库日期在同个物流单种不可修改) 
预计到货日期: in_receive_final表的该物流单号logistic_num下的eta_date_final (这个有多行也无所谓, 因为因为这个日期在final表中是唯一的) 
托盘数: in_receive_final表的该物流单号logistic_num去in_send表中匹配logistic_num的pallets列数值, 选取seq列(V##,##为数字)最大值下的pallets列数值
入库日期: in_receive_final表的该物流单号logistic_num下的receive_date
入库状态: 和 发货单管理-列表界面 物流单号后面的tag一致

入库货物明细
物流单明细版本: in_receive_final表该物流单号logistic_num去匹配in_send_final表该物流单号sent_logistic_num下seq列(L##,##为数字)的最大值时 
操作人: in_receive_final表该物流单号logistic_num去匹配in_send_final表该物流单号sent_logistic_num下seq列(L##,##为数字)的最大值时 sent_by列的值
修订日期: in_receive_final表该物流单号logistic_num去匹配in_send_final表该物流单号sent_logistic_num下seq列(L##,##为数字)的最大值时 send_update_date的值(这个值也是只能是唯一的 根据规则)
备注: in_receive_final表该物流单号logistic_num去匹配in_send_final表该物流单号sent_logistic_num下seq列(L##,##为数字)的最大值时 sent_note列的值(这个值也是只能是唯一的 根据规则)
入库明细版本: in_receive_final表该物流单号logistic_num下seq列(D##,##为数字)的最大值
操作人:in_receive_final表该物流单号logistic_num下seq列(D##,##为数字)的最大值 by列的值
修订日期: in_receive_final表该物流单号logistic_num下seq列(D##,##为数字)的最大值 update_date列的值 (这个值也是只能是唯一的 根据规则)
备注: in_receive_final表该物流单号logistic_num下seq列(D##,##为数字)的最大值 note列的值 (这个值也是只能是唯一的 根据规则)
货物列表为
注意每有这里在in_receive_final表中以物流单号logistic_num为预选条件, 然后以po_num,po_sku为key查询
每一个key为一行展示
订单号: 为该in_receive_final表该物流单号logistic_num下的po_num 
SKU: 为该po_num在in_receive_final表该物流单号下的po_sku, 
发货数量: 为上面订单号和SKU为key在in_send_final表中的sent_quantity的和
入库数量: 为上面订单号和SKU为key在in_receive_final表中的receive_quantity的和
入库状态: 以发货数量 减去 入库数量 为依据, 若为0, 则入库状态为 正常, 若不为0, 则入库状态为 异常 这里同 货物入库向导 里展示超收和少收的tag一致


修改按钮
点击修改按钮后, 会出现一个类似一个 发货单管理-修改发货单向导 的界面
设计的UI和风格样式必须完全一致
但是背后逻辑不同
我们慢慢补齐
流程为修改入库数据(对应修改明细)->修改预览(对应验证修改)->完成



流程2 
确认入库 的按钮 点击后会触发global-modal 弹出密码验证 通过验证后才能去到流程3
这个密码验证 需要 受到 用户权限管理-密码策略管理 你需要去适配 你可以通过 别的功能中入库密码验证的方式 来了解如何做


流程3
完成界面的提示 和 货物入库向导 的提示一致

根据流程2传入过来的修改行的数据

数据库表上传逻辑
in_receive(每一行修改都要写入一行或更多(根据情况))
根据用户流程2中传入流程3的数据
对于每行数据 先检验 需要写入多少行
步骤1, 首先需要用流程2传入的logistic_num,po_num,po_sku去in_send_final表中匹配sent_logistic_num,po_num,po_sku 查看有多少行, 有多少行就需要写入多少条
步骤2, 若出现多行的情况, 只会出现在有误差的纯在的情况, 发现收到的货比理论多的情况, 记录多的数量加入进入po_price最高的项目, 保持低价格产品的数量匹配,若发现收货比理论少的情况, 记录差额去po_price最低的项目, 保持高价格产品的数量匹配
send_date: 根据logistic_num去in_send_final匹配sent_logistic_num, 然后获取sent_date
eta_date_final: 根据logistic_num去in_send_final匹配sent_logistic_num, 然后获取sent_seq. 然后通过sent_seq和sent_logistic_num去in_send匹配seq和logistic_num, 然后获取date_eta
receive_date:原有的实际到达时间 YYYY-MM-DD (这个数据是不可变的)
update_date: 写入今天日期 YYYY-MM-DD
logistic_num: 同样的发货单号
po_num:用流程2传入的选择的 订单号
po_sku:用流程2传入的选择的 SKU
sent_quantity: 根据用户流程2传入的发货单号, 订单号, SKU去in_send_final表中匹配sent_logistic_num,po_num,po_sku获取的send_quantity (判定调整项)
receive_quantity:用户流程2传入的新入库数量
po_price:用根据用户流程2传入的发货单号, 订单号, SKU去in_send_final表中匹配sent_logistic_num,po_num,po_sku获取的po_price(判定写入多行项, 有几个写几行)
action: 写入adjust
note: 写入流程2里的备注
seq: 根据现有in_receive中该物流单号logistic_num下seq列(字母##,##为数字)的最大值+1
by:写入当前操作的用户名

若在in_receive中写入时遇到处理到存在差异的行的数据, 则需要写入in_diff表
存在差异指流程2中 发货数量和实际数量不一致的项数据行
in_diff
record_num: 记录号 自动生成 {logistic_num}_{receive_date}
logistic_num: 存在差异的行所属的发货单号
po_num: 在差异的行所属订单号
receive_date: 存在差异的行的收货日期 YYYY-MM-DD
po_sku: 存在差异的行所属订单商品sku
po_quantity: 根据po_num,po_sku去in_po_final匹配po_num,po_sku获取的满足条件的行的po_quantity相加的和
sent_quantity: 存在差异的行所属发货数量
receive_quantity: 存在差异的行所属收货数量
diff_quantity: 存在差异的行所属的差异数量sent_quantity-receive_quantity
status: 写入pending
action: 若以record_num,po_quantity,po_sku去in_diff匹配 发现有匹配的行 则写入adjust, 否则写入new
note: 写入 入库差异_{用户流程2中的备注}
seq: 在原有in_diff_final表该物流单号logistic_num下seq列(字母##,##为数字)的最大值+1
by: 写入当前操作的用户名


对于in_receive表写入的每一行,都需要更新in_receive_final表
以in_receive表的logistic_num为预选条件, 然后以po_num,po_sku,po_price为key
in_receive_final表中以相同logistic_num为预选条件,然后以po_num,po_sku,po_price为key
两者key相同,为匹配, 对于in_receive写入的行, 与in_receive_final表中匹配的行
需要用写入in_receive的行进行覆盖

in_receive_final表写入 (写入内容保持不变,找到匹配行之后, 用in_receive的匹配行进行覆盖, 除非有特别备注)
eta_date_final:
receive_date:
update_date: 
logistic_num:
po_num:
po_sku:
sent_quantity:
receive_quantity: 流程2中用户修改的入库数
po_price:
note: 用户流程2中的备注
seq: 在原有in_receive_final表该物流单号logistic_num下seq列(字母##,##为数字)的最大值+1
by:

若有数据写入in_diff表 也需要把这些数据写入in_diff_final表
我们以in_diff表中的 record_num, po_sku, po_quantity作为key
在in_diff_final表中以相同record_num, po_sku, po_quantity作为key
两者key相同,为匹配, 对于in_diff写入的行, 与in_diff_final表中匹配的行
需要用写入in_diff的行进行覆盖
若没有找到匹配的行, 则需要写入in_diff_final表作为新行

in_diff_final表写入 (写入内容保持不变,找到匹配行之后, 用in_diff的匹配行进行覆盖, 除非有特别备注, 若是新增行直接写入)
record_num: 
logistic_num: 
po_num: 
receive_date: 
po_sku: 
po_quantity: 
sent_quantity: 
receive_quantity: 
diff_quantity: 
status: 
note: 
seq: 
by: 


恢复逻辑为:
in_receive表
找到该logistic_num下, note含 删除订单 这个词的行, 且获取其seq列的最大值
把这个最大值-1, 
获取那个版本的行, 复制后新增进入表, note为 恢复删除_{用户名}_{当前时间} action为adjust
seq为原有+1

然后根据根据新写入的in_receive表 去更新in_receive_final表
通过是否满足写入in_diff表的逻辑写入in_diff表, 再根据in_diff表更新in_diff_final表

这些逻辑你可以从修改入库单向导 最后一个流程看到


在 货物入库向导 流程3 中 显示的列表的下面, 加一个上传框体 采用global-file-upload 提示用户上传入库文件, 这个不是必须传的
这个YYYYMMDD是入库日期
用户上传后会存入项目目录下路径 data/receiving/YYYY 文件内 命名为 YYYYMMDD_{物流单号}_Ver01  


同时在 修改入库单向导 流程2中 显示的列表的下面, 加一个上传框体 采用global-file-upload 提示用户上传入库文件, 这个不是必须传的
用户上传后会存入项目目录下路径 data/receiving/YYYY 文件内 命名为 YYYYMMDD_{物流单号}_Ver##  
这个YYYYMMDD是入库日期 
这个##会根据当前文件夹内同名文件的Ver##的最大值+1 若没有同名文件则为Ver01



新建数据库表: 

in_dynamic_tran

| 字段            | 类型/示例                             | 作用                                           |
| ------------- | --------------------------------- | -------------------------------------------- |
| record_id   | BIGINT PK AUTO_INCREMENT          | 每条流水唯一ID（必须），用于排序 & 增量处理                     |
| date_record | DATE / DATETIME                   | 记录写入时间                                  |
| po_num      | VARCHAR                           | PO单号                                   |
| sku         | VARCHAR                           | SKU                                    |
| price       | DECIMAL(10,4)                     | 售价                                    |
| quantity    | INT / DECIMAL                     | 数量                                      |
| action      | ENUM('in','out')                  | 进库 in/出库 out                                   |
| type        | ENUM('sale','inv', 'return', ...) | 用途标签（sale/inv），建议未来扩展 adjust/return 等        |
| note        | TEXT                              | 备注                                           |
| created_at  | DATETIME                          | 插入时间（可选但建议）                                  |



in_dynamic_fifo_layers

| 字段              | 类型/示例                                | 作用                                  |
| --------------- | ------------------------------------ | ----------------------------------- |
| layer_id      | BIGINT PK AUTO_INCREMENT             | 库存层主键                               |
| sku           | VARCHAR                              | SKU                                 |
| in_record_id  | BIGINT FK -> inventory_txn.record_id | 该层来自哪一笔入库流水                         |
| in_date       | DATE/DATETIME                        | 入库时间（一般取 inventory_txn.date_record） |
| po_num        | VARCHAR                              | 来自入库的 po_num（方便追溯）                  |
| unit_cost     | DECIMAL(10,4)                        | 该层的成本单价（取入库 price）                  |
| qty_in        | DECIMAL                              | 该层初始入库数量（取入库 quantity）              |
| qty_remaining | DECIMAL                              | 该层剩余可用数量（FIFO 消耗时扣减）                |
| created_at    | DATETIME                             | 生成层的时间                              |
| closed_at     | DATETIME NULL                        | 当 qty_remaining=0 关闭该层（可选）          |



in_dynamic_fifo_alloc

| 字段              | 类型/示例                                | 作用                                |
| --------------- | ------------------------------------ | --------------------------------- |
| alloc_id      | BIGINT PK AUTO_INCREMENT             | 分摊行主键                             |
| out_record_id | BIGINT FK -> inventory_txn.record_id | 对应哪一笔出库流水（销售）                     |
| sku           | VARCHAR                              | SKU（冗余存，方便查询）                     |
| out_date      | DATE/DATETIME                        | 出库时间（取 inventory_txn.date_record） |
| layer_id      | BIGINT FK -> fifo_layers.layer_id    | 从哪个入库层扣的                          |
| qty_alloc     | DECIMAL                              | 从该层扣掉的数量                          |
| unit_cost     | DECIMAL(10,4)                        | 该层的成本单价（通常冗余存，避免 join）            |
| cost_alloc    | DECIMAL(12,4)                        | qty_alloc * unit_cost             |
| created_at    | DATETIME                             | 写入时间                              |


现在读取数据库表Data_inventory
选取第一列作为SKU, 列名为 2024-12-31这一列作为库存数量 作为我们的初始库存写入我们的FIFO库存系列表
当写入in_dynamic_tran时
售价: 根据SKU从数据库表Data_COGS中选取cog列对应的价格
action: in
type: inv
note: 初始库存







新建功能 入库异常处理 
需要新加入一个路由 放在采购板块下面, 该路由为 abnormal

该功能点击进入后是一个列表展示, 列名和数据如下
数据来源于数据库表in_diff_final, 根据元组(logistic_num,receive_date)筛选
物流单号: logistic_num
入库日期: receive_date
状态: status 列数据 若是pending tag为 待处理, 若是done tag为 已处理
备注: note
操作: 3个按钮, 一个点击处理异常, 一个查看处理详情, 一个点击删除处理/恢复处理

先建立整体框架, 逻辑后补
保持一贯的UI风格




按钮处理异常
需要新建立一个Html页面管理(非路由)
采用global-wizard组件, 密码验证采用global-modal组件同时接入用户权限管理 密码策略管理输入的密码内容

流程分为
处理说明->选取方式->验证修改->完成

流程1:处理说明
这里是一个说明页面, 说明处理入库异常的流程, 以及需要用户注意的事项
需要说明首先什么是异常, 就是指收货数量和发货数量不一致,要进行合规处理
且异常处理是仓储部门已经严格核对之后确认发生的差异数值,非误判或者非仓储部门清点的人为错误
告知用户处理的方式有几种
1. 以入库数量为准,修正发货单里的数量,不修正其关联的订单数量 (通常用于异常差距小且订单产品存量多未发完的情况)
2. 以入库数量为准,修正发货单里的数量,同时同步修正其关联的订单数量 (通常用于异常差距小且订单产品存量已发完的情况)
3. 以发货数量为准,差异值新建立发货单,延迟入库(这种情况用于入库数量少于发货数量, 用于部分货物被延迟运达的情况), 会生成一个新的发货单,作为原发货单的子发货单存在
4. 以发货数量为准,差异值算作厂商错误,若是收得多,则这些产品0成本计入库, 若是发的多,则差异值值作为耗损出库

===============================
===============================
现在在库存板块新增功能 动态库存管理
这个需要一个路由, 作为库存板块的子路由存在, 该路由为 dynamic_inv
此页面是一个列表展示, 该列表可能会非常长 需要限高 数遍滚轮查看

顶上有一个选择日期的窗口, 数据会跟随选择的日期, 动态变动, 选择日期右侧有一个按钮 为 今天, 点击后会把今天设置为日期
选择日期和点击今天都不需要确定 数据自动变更
该页面为数据显示 不能交互
列表根据用户选的日期为截止日期显示下面列表数据
该列表的列名如下
SKU: 从Data_COGS表中获取全部SKU
当前实际库存数: 读取Data_inventory表中数据获取, 列名为日期 此外当用户选择某个日期的时候, 我们以离这个日期最近的上一个日期的库存数量作为当前实际库存数
当前理论库存数: 通过FIFO库存表根据上面的SKU列匹配去读取和计算
当前下订数:
2. 日期匹配逻辑 in_send_final表以sent_date列匹配, in_po_final表以po_date列匹配
1. 数量统计逻辑 {从in_po_final表po_sku列匹配上面的SKU列, 然后读取po_quantity列的和} - {从in_send_final表po_sku列匹配上面的SKU列, 然后读取send_quantity列的和}
当前在途数:
1. 日期匹配逻辑 in_send_final表以sent_date列匹配, in_receive_final表以receive_date列匹配
2. 数量统计逻辑 {从in_send_final表po_sku列匹配上面的SKU列, 然后读取sent_quantity列的和} - {从in_receive_final表po_sku列匹配上面的SKU列, 然后读取receive_quantity列的和}
当前库存价值: 从FIFO库存表中根据上面的SKU列匹配去读取和计算
当前下定价值: 先不做这个功能逻辑 先占位 日后更新
当前在途价值: 先不做这个功能逻辑 先占位 日后更新






===============================
===============================
财务板块
===============================
===============================
新建财务HUB
在HUB中建立新功能 物流财务管理 该功能为物流费用管理 这个功能需要新建路由(logistic)在财务板块下面
用户点开该页面后
会出现一个如同 采购板块-发货单管理 的列表展示页面 你可以完全复刻
这里的列要要下面的

物流单号: 沿用之前的逻辑 根据in_send中这个logistic_num列最大的seq列下的payment列获取 tag状态 Y 为已付款 N 为未付款
发货日期: 沿用之前的逻辑
预计到达日期: 沿用之前的逻辑
实际入库日期: 采用该物流单号在in_receive_final表中的receive_date列 (这个值根据规则是唯一的)
托盘数: 沿用之前的逻辑
物流单价: 沿用之前的逻辑
结算汇率: 沿用之前的逻辑[]
总费用: 沿用之前的逻辑
物流费用: 沿用之前的逻辑

然后在物流单前面添加一个checkbox, 用于选择
右上角有按钮 付款 点击后会把check box打钩的数据

传入一个global-wizard组件做的 向导页面 这要个单独html管理 后续补充逻辑


批量付款 点击之后 会进入的页面由 global-wizard 组件管理 需要由一个分开的html管理
流程为
付款说明->预览费用->确认费用->付款完成

付款说明
这个流程需要说明用户需要对选择的所有物流单的运费进行付款
首先需要挨个确认物流单的与付款相关的内容是否正确
付款流程中, 只能修改汇率, 若其他物流信息不正确需要去到采购板块 发货单管理 里面修改
所有的合并付款的物流单,都确认无误后, 点击继续付款
你润色下这些内容

确认汇率 流程

操作须知还需要告知, 
用户需要选择结算汇率的日期 为订单创立日,还是结算日
汇率修改是按照整个付款下所有的单据一起整合修改的

此外列表中的结算汇率仅作为展示, 不可修改 只能通过列表上方框体统一管理

在列表上方有一个框体
里面叫做修改汇率,以下为框体内容
付款日期: 这个是需要用户选择的日期
结算汇率是否按照付款日结算: 这个是一个开关 采用 ui-togglez组件管理 
当用户选择是的时候, 下方会多一个输入框, 用于输入汇率
这是一个输入框体右侧也有一个按钮, 点击会自动获取汇率
这个功能类似 采购单管理 修改发货单向导 里的汇率获取按钮
汇率会根据选择付款日期这个日期 得到USD->RMB汇率的买入价
若获取时间超时5秒,或者是未来日期会提示用户
若用户选择否, 则不会弹出输入框
而是仅作为一个展示数据不可交互的显示告知当时的汇率

用户点击该框体中的保存按钮, 则户把修改应用到下方的框体中去 替代下面列表中所有结算汇率为这个数字, 若用户之前开关为否的则不需要替换了 因为是一样的


结算汇率 输入框体右侧也需要显示当时汇率获取的方式, 当用户修改了这个数字 也需要实时修改这个获取方式的tag


流程3 确认费用
去掉 流程向导下面的 图标和header
列表改为显示更新后的流程2的列表, 所有结算按照 金额显示 上方是USD金额下方是RMB金额 需要采用 货币符号tag显示
注意保持货币符号TAG的一致性 不要新设计

同时警告栏上面
会有一个文件上传框体 采用global-file-upload管理 接受 用户上传付款单回执 (非必须)
注意, 这个功能能支持的上传文件 和 采购板块-入库管理-上传替换入库文件 流程1 里的 上传框体一样 需要支持一样个格式

用户上传文件后, 该文件的保持路径为 data/records/logistic/YYYY/YYYYMMDD_payment_Ver01.{后缀}  注意只有在流程4完成后才会真的上传, YYYYMMDD如用户之前选择的付款日期


流程4 付款完成
流程3 点击确认付款 会出现 密码验证 由global-modal管理, 密码输入内容源于 用户权限管理 密码策略 里的管理 你可以参考其他版块这个功能运用去实现
用户验证通过进入流程4

流程4需要有完成UI设计你去设计

流程4会上传数据库 in_send
若之前用户在流程2中 打开了开关 选择 使用入款日汇率 打开
则需要写入in_send表, 否则不需要
写入操作为
选取当前物流单号 logistic_num作为key, 找到之前seq数值最大的那行
复制该行信息 写入 但是以下列信息需要更新
usd_rmb需要写入用户流程2中的选择的汇率
mode需要写入用户流程2中的选择的汇率的方式 自动A 手动M
note:运费付款_YYYY-MM-DD (YYYY-MM-DD为用户流程2中选择的付款日期)
seq: V## ##为数字 最大值+1
data_record: 写入今天日期
by: 写入当前用户

同时写入in_payment_logistic表
date_record:记录今天日期 YYYY-MM-DD
date_sent: 记录物流单发货日期 YYYY-MM-DD
logistic_num:记录物流单号logistic_num
logistic_paid:记录物流费用total_price
extra_paid:记录流程2中用户录入的额外费用 金额
extra_currency:记录流程2中用户选择的额外费用 币种 RMB/USD
extra_note:记录流程2中用户选择的额外费用 备注内容
payment_date:记录付款日期 YYYY-MM-DD
seq: 记录V01
by: 记录操作用户


新建立一个数据库表
in_payment_logistic
字段如下
date_record:记录付款日期 YYYY-MM-DD
date_sent: 记录物流单发货日期 YYYY-MM-DD
logistic_num:记录物流单号
logistic_paid:记录物流费用
extra_paid:记录额外费用
extra_currency:记录额外费用货币 RMB/USD
extra_note:记录额外费用说明
payment_date:记录付款日期 YYYY-MM-DD
seq: 版本号 V## ##为数字
by: 记录操作用户


流程2中若用户选择延迟入库, 则需要输入延迟日期, 所有的异常不论在不在一个订单号 新的预计延迟到货日期 都会一致

流程3里 需要根据流程2的选择 也按照订单为板块, 显示根据策略后的信息
若用户选择 仅修正发货单

那么该订单要显示更正后的发货量 也就是原发货量一个箭头指向新发货量
其他数据不变

若用户选择 同时同步修正其关联的订单数量

那么该订单要显示更正后的发货量 也就是原发货量一个箭头指向新发货量
也要更新 订单的订货数量 一个箭头指向新订货数量
其他数据不变

若用户选择 延迟入库

那么该订单的显示数据不变
在该订单下面新增一个sub框体
显示 
物流单号
预计到货日期
然后写入差异数量的货物清单(延迟到的) 这个列表如同 刚才的货物明细信息  

若用户选择 厂商错误

那么该订单, 入库数量需要显示与发货数量匹配的入库数量 也就是原入库数量一个箭头指向新入库数量
若是收大于发
需要然后复制该行, 注意 单价写入0, 订货数量写入差异值, 发货, 入库数量写入差异值 需要特别注明此行是新的 注明0产品成本入库
若是发大于收
需要然后复制该行, 注意 单价写入原单价, 订货数量写入负差异值, 发货, 入库数量写入负差异值 需要特别注明此行是新的 注明以原价成本出库耗损

其他数据不变

流程4 完成 

好了 你实现最终流程上传的时候 就是要求我们的用户选择的操作能正确在 其关联的记录表中被记录, 终态表会根据记录表被更新
你懂了么?
同时 有一个我需要说的是 在用户选择延迟发货的逻辑中

用户选择 延迟入库 的时候 要新建个一个发货单, 这个发货单的单号为 {logistic_num}_delay_V01 数字会递增 如果有后续的延迟入库
这个发货单的物流信息也就是 in_send表的内容,  单价 总重 都得是0, 因为之前支付过了 因为是子订单

用户选择 厂商错误 的内容
意味着多发的货会以单价为0入库了, 这些货你需要在采购,发货, 入库中都去新增, 以匹配需求
如果是少发的货会以原有的订货价入库, 你需要在采购,发货, 入库中都去新增, 以匹配需求, 
但是需要出库, 这个逻辑还没有写完 所以先留着 日后增加 你打个标签 提示我 日后我告诉你


总之这个差异的修改就是要按照原有的终态表修改流程去做, 通过修改涉及的明细表, 来更新终态表 这是基础
同时这些明细表中的note相关的 要写入 {差异校正修改}_{用户名}_{版本号}_{操作时间YYY-MM-DD}



新建一个功能 仓库货架码 shelf
这是一个新的路由 放在库存板块下面
同时在库存的hub页里新增一个入库卡片
进去之后就是一个页面展示当前仓库的构造的情况
每个仓库都是一个框体, 采用一行2个框体的形式去排列
这个展示列表上面有2个按钮
新增仓库, 下载全仓库码(这2个功能后面补齐)

这个功能的数据源于数据库表in_mgmt_barcode

现在先说下每个仓库框体
每个仓库的框体都是一个长方形模块 画出仓库的地图大概3D框体,你可以采用长方体代替, 这个框体的标题栏高亮这个仓库的仓库号wh_num
我们目前的仓库都长一个样 就是一个长方形地图
短边一侧为入库
货架排 只能排在左右两侧 各一排 中间标出走道 以入口进门方位判定 左侧是L 右侧是R
货架跨从内侧(也就是不是门那侧)开始计算号码 从1开始 若数据为3 则从内侧到门口 有三跨
在单个跨内,有货架层, 每个跨最多3层, 依次为G(最底层),M(中间层),T(顶层)
在单个层内,有库位, 左边是L, 右边是R 我们以在走道面朝货架的来区分左右
每个库位内,有格位, 左边是L, 右边是R 我们以在走道面朝货架的来区分左右

数据库表中 in_mgmt_barcode
每一行就是一个独立到最小单位的库存位置单元
假如库位数据为空, 那么意味着这个位置的最小计位单位是他的上一级 也就是库位 依次类推
当画图的时候 我们需要读取这个表 按次序判定最小计位单位进行制图
注意 我们最低必须要求按照 货架 层号为单位, 所以层号不能为空
而货架的每个跨的层数, 库位号(若存在)数量,格位号(若存在)数量, 在同货架排中 必须一致

用户创建新仓库 或者 修改当前的时候 会根据用户输入的数据进行调整
在用户输入数据的时候需要实时制图反馈 注意图中的长方块的堆叠和颜色区分 让用户有好的认知
用户会先输入仓库号, 然后建立地图
然后要求用确认 是否启用货架排左 然后确认 货架排 左(L) 的 跨数, 然后要用户确认每跨的 层数, 然后确认每层的库位数, 然后确认每库位的格位数
当选到确认到每层库位数和后续的时候, 可以跳过, 则后续都不需要再输入, 此时说明 这个位置不分后续的区分
然后要求用户确认 是否弃用货架排右, 同理于左侧的逻辑
当最后确认后就完成了一个仓库的规划

当用户点击确认后, 我们需要把这个数据写入数据库表in_mgmt_barcode
以用户选择的最低统计单位为准, 每个位置为一行, 写入下列数据, 当最低统计单位下没有内容时, 写入空值, 代表不区分这个单位的区分
wh_num: 代表了仓库号
asile: 货架排号 当前只有L, R 目前不需要限定值 考虑拓展性
bay: 货架跨号, 数字,1,2,3...
level: 货架层号 字母G,M,T
bin: 库位号 当前只有L, R 目前不需要限定值 考虑拓展性
slot: 格位号 当前只有L, R 目前不需要限定值 考虑拓展性



新建数据库表 仓库码管理 in_mgmt_barcode
wh_num: 仓库号
asile: 货架排号 当前只有L, R 目前不需要限定值 考虑拓展性
bay: 货架跨号, 数字,1,2,3...
level: 货架层号 字母G,M,T
bin: 库位号 当前只有L, R 目前不需要限定值 考虑拓展性
slot: 格位号 当前只有L, R 目前不需要限定值 考虑拓展性


在仓库货架码 的 新增仓库  下载全仓库码 后面新增一个按钮为 自定义下载库房码
此功能用新页面管理 (不要新路由) 数据来源为in_mgmt_barcode
该页面打开后
顶上会出现一个选项 一个选择仓库的选项, 会列出所有wh_num
用户选择之后
下方会出现这个仓库的3D图 这个3D图和我们之前的作图方式一模一样
然后用户可以和这个图交互
也就是我们需要把这个3D图里的实体按照他们实际所属的区块去切割, 当用户点击到对应位置的时候
会能正确捕捉到 该部分对应的数据库行的信息
显示在下方的信息栏里
当用户再次点击别的福门的时候 会刷新下面信息栏

有一个按钮 生成条形码,
先留空 逻辑后面添加



现在需要做生成条码功能按钮 逻辑功能

点击这个按钮后 会根据读取的数据行 生成一个pdf文件
注意pdf文件的格式必须是4x6
且每页PDF只能写入2行数据
也就是在这里只能写入一行数据 
PDF从中间切分为两边, 一边对应一行数据, 此功能中只有一行数据, 所以只需要写入一边即可

字段如下结合
location_{wh_num}_{aisle}_{bay}_{level}_{bin}_{slot}
若数据读取时字段为空(null这样的), 则该字段写入null
然后把这个字符串转化成为Data Matrix放在图中data matrix的地方

然后该PDF中对应的内容也需要写入
Warehouse: 写入该行的wh_num
Aisle: 写入该行的 aisle
Bay: 写入该行的bay
Level: 写入该行的level
Bin: 写入该行的bin
Slot: 写入该行的level
写入时注意字体的朝向要旋转90度 和模版一样
如果Bin, Slot为空值, 则写入N/A
然后下载给用户, 命名为 {wh_num}_{aisle}_{bay}_{level}_{bin}_{slot}.pdf
命名时若bin,slot为空则写入null

新建数据库表
in_payment_po
字段如下
pmt_num: 自动生成 {date_record}_S## 从01开始自增
date_record: 记录操作日期 YYYY-MM-DD
po_num: 记录采购订单号
po_sku: 记录该订单号下的SKU
po_price: 记录该SKU的价格
po_quantity: 记录入库数量

新建数据库表
in_pmt_dep
dep_num: 记录操作流水号 {supplier_code}_{tran_date 需要改成YYYYMMDD}_{tran_type}_## ##为数字 若前面遇到相同的就递增 从01开始
supplier_code: 记录厂商ID
tran_date: 记录厂商预付款账户流水日期 YYYY-MM-DD
tran_curr_req: 记录厂商要求的货币种类 USD/RMB
tran_curr_use: 记录操作的货币种类 USD/RMB
usd_rmb: 记录汇率操作当日的买入汇率
tran_amount: 记录操作金额
tran_type: 记录操作模式 in/out 存入和使用
tran_ops: 记录数据表操作模式 new/adjust new为记录新操作, adjust为更新老操作 (可以用于表in_pmt_prepay_final的触发器)
tran_seq: 记录版本号 T## ##为数字 从01 开始递增, 新数据为01
tran_by: 记录操作用户
tran_note: 记录操作备注


新建数据库表
in_pmt_prepay
tran_num: 记录操作流水号 {supplier_code}_{tran_date 需要改成YYYYMMDD}_{tran_type}_## ##为数字 若前面遇到相同的就递增 从01开始
supplier_code: 记录厂商ID
tran_date: 记录厂商预付款账户流水日期 YYYY-MM-DD
tran_curr_req: 记录厂商要求的货币种类 USD/RMB
tran_curr_use: 记录操作的货币种类 USD/RMB
usd_rmb: 记录汇率操作当日的买入汇率
tran_amount: 记录操作金额
tran_type: 记录操作模式 in/out 存入和使用
tran_ops: 记录数据表操作模式 new/adjust new为记录新操作, adjust为更新老操作 (可以用于表in_pmt_prepay_final的触发器, 触发时写入新行, 或者覆盖之前的老行)
tran_seq: 记录版本号 T## ##为数字 从01 开始递增, 新数据(新数据为同记录操作流水号内的新操作也就是需要触发ops的)为数字递增
tran_by: 记录操作用户
tran_note: 记录操作备注
tran_curr_type:


in_pmt_prepay_final 需要跟随in_pmt_prepay自动更新
tran_num: 记录每个唯一的in_pmt_prepay表的tran_num
supplier_code: 记录该tran_num下的
tran_date: 记录该tran_num厂商预付款账户流水日期 YYYY-MM-DD
tran_curr_req: 记录该tran_num最新的厂商要求的货币种类 USD/RMB
tran_curr_use: 记录该tran_num最新的操作的货币种类 USD/RMB
usd_rmb: 记录该tran_num最新的汇率操作当日的买入汇率
tran_amount: 记录该tran_num最新的操作金额
tran_type: 记录该tran_num的操作模式 in/out 存入和使用
tran_seq: 记录该tran_num最新的版本号 T## ##为数字
tran_by: 记录该tran_num最新的操作用户
tran_note: 记录该tran_num最新的操作备注


# 重启服务器
bash ops/stop_server.sh && bash ops/start_server.sh

# 仅本地开发 (不需要外网)
bash ops/stop_server.sh
source .venv/bin/activate && cd backend && python manage.py runserver 127.0.0.1:8000

新建功能 预付款 放在财务板块下面作为子理由 这需要一个新的路由prepay
该功能的页面UI设计需要和别的页面一样 保持一致的风格 苹果UI
也需要在 财务板块hub页中建立一个入口卡片

点击进入后 该页面是一个分栏列表页面,
左侧为供应商预付款balance,左侧的占比要很小每个卡牌需要纵向排列, 每个列只需要一个卡牌
内容如下
每个供应商都是以一个卡牌的形式显示
需要重点显示 预付款余额
供应商ID: 从in_supplier读取全部的supplier_code
供应商结算货币: 显示货币需要tag, 通过supplier_code去in_supplier_strategy里匹配supplier_code获取其 effective_date列为最新的日期的 currency列信息
预付款余额: 读取in_pmt_prepay_final该supplier_code下的所有行的tran_amount
每行的数据计算如下
tran_type为金额出如, in就需要加, out就需要减
tran_curr_use为此行操作金额的货币种类
若tran_curr_use 和 供应商结算货币 相同, 则不需要货币汇率计算
若tran_curr_use 和 供应时间结算货币不同, 需要用该行的usd_rmb 进行转换 后计入
然后算出这个金额 写入这列

然后点几上面的供应商后, 右面会出现该供应商的交易明细
明细右侧有一个按钮筛选, 可以选日期区间, 有预选为过去6个月, 过去1年, 过去2年
该表格读取in_pmt_prepay_final的表信息填入
这个列表列需要有下面的列 (且在这个列表header 要写入该选择供应商的 {supplier_code}和{supplier_name}, 同时写入标注该供应商的交易货币{tran_curr_req})
日期: 写入如该tran_num的tran_date
预付: 写入tran_type为in的tran_amount 注意需要在金额前面 用tag标注(tran_curr_use)货币
使用: 写入tran_type为out的tran_amount 注意需要在金额前面 用tag标注(tran_curr_use)货币
余额: 累计前面所有行的预付 减去 累计前面所有行的使用 注意需要在金额前面 用tag标注(tran_curr_req)货币
修改版本: 写入tran_seq
操作人: 写入tran_by
备注: 写入tran_note
流水号: 写入tran_num

注意在有筛选的情况
需要在标题栏下面写入 类似于会计 beginning balance金额的起始金额


供应商卡片 的右下角新增一个 按钮 作为新增预付款选项
点击后会进入一个global-wizard管理的预付款向导页面
需要一个单独的html管理 注意不要新路由
该流程分为
操作说明->付款明细->验证信息->完成

流程1 操作说明
操作须知框
就是解释什么是供应商预付款
解释这些款项用于什么(可以用于支付货款的定金和尾款)
解释下供应商要求的结算货币获取方式为供应商策略,需要修改需要对对应板块
解释下付款基准是什么(付款货币如和策略中货币不同, 会按照汇率进行转换, 确保货币一致性,如果是一样的则无需转化, 但是汇率会作为未来财务统计的统一USD的基准)
解释下汇率设定, 自动获取/手动填写
解释下, 付款完成后可以被修改, 历史记录不会被删除, 删除记录也会有
解释流程
注意措辞 让用户理解逻辑和整个流程

流程2 付款信息
操作须知 需要解释这个付款属性里的内容 通过你的理解
这个页面是用于用于 用户填写付款属性的
以一个名片的形式展示 给用户录入
供应商ID: 从用户点击的卡片获取 (不能交互)
供应商名字: 从用户点击的卡片获取 (不能交互)
供应商结算货币: 从用户点击的卡片获取 (不能交互)
预付款日期: 用户录入 YYYY-MM-DD
预付款货币: 选择 USD或者RMB
预付款金额: 用户录入金额 只能是数字,小数点只能有2个
设置汇率: 用户录入也可以点击获取预付款日汇率 这个自动获取汇率的方式和失败的怎么办的方式请参考 物流财务管理的 获取汇率的按钮
预付款备注: 用户必须填写

流程3: 验证信息
以名片的形式展示 流程2的录入
并且根据逻辑验证各个字段是否合法

流程4: 完成
把流程3中用户确认的数据上传进入流程4的数据上传数据库表


新增预付款向导
在现有显示内容下面 新增一个 文件上传页面
采用global-file-upload 管理
提示为 上传付款文件
这个不是必须的
文件储存位置参考 文件存储规范.md 根据规范设计

右侧的明细中 在流水号右侧新增一列 为 操作
文件管理参考 文件存储规范.md

这一列为按钮
删除/恢复 参考 采购订单管理 操作列的功能设计和UI
修改付款 参考 物流财务管理的已付款物流单卡片里的功能设计和UI
查看付款文件 参考 物流财务管理的已付款物流单卡片里的功能设计和UI
上传付款文件 参考 物流财务管理的已付款物流单卡片里的功能设计和UI
历史记录: 参考 物流财务管理的已付款物流单卡片里的功能设计和UI

注意参考的内容若是单独HTML管理的 这里也需要这样设计 只是根据这里的内容去修改


现在做删除/恢复删除订单按钮

删除时会在in_pmt_prepay表中找到该行数据
复制全部信息, 然后改tran_amout为0, 同时tran_ops变成 adjust,  tran_seq 数字+1, 
tran_note改为删除付款

恢复时会在in_pmt_prepay表中找到先前删除的行数据, 拿到 tran_seq数字, 这个数字-1 再通过tran_num去找到 删除前的数据
tran_ops改成adjust, tran_seq 为删除行的数字+1, tran_note改为 恢复删除


现在进入修改按钮功能
流程类似 新增预付款向导 但是去掉操作说明
只保留流程2 , 3,4 改为 修改付款明细->验证修改->完成
这里你需要重新做这个向导 沿用之前的大概率会带来很多问题 且不好维护
但是 修改付款明细 这个流程需要按照 修改发货单向导-流程1 在原有的基础上使用双栏显示, 一栏为之前的数据 一栏为修改框体

验证修改 也是在原有基础上  如同 修改发货单向导-流程5 的预览一样


在in_pmt_logistic 表内
新增3个字段 
usd_rmb: 用于记录汇率 替代之前的 in_send表中usd_rmb的读取和写入
mode: 用于记录汇率获取方式 替代之前的 in_send表中mode的读取和写入
log_ops: 用于记录数据写入的方式 只允许new/adjust

新建表: in_pmt_logistic_final, 这个表会跟随in_pmt_logistic 的 log_ops触发器, new时写入新行,adjust时替代老行以pmt_num为准)
字段
date_record:
date_sent:
logistic_num:
logistic_paid:
usd_rmb:
mode:
extra_paid:
extra_currency:
extra_note:
payment_date:
note:
seq:
by_user:
pmt_no: 


批量付款向导 
汇率的写入 要改到写入in_pmt_logistic 中的usd_rmb 写入的方式不变
汇率获取方式 要改到写入 in_pmt_logistic 中的mode 写入的方式不变
log_ops写入new
同时需要写入note 为原始发货单付款

已付款物流单
这个卡片读取的数据 需要改用 in_pmt_logistic_final的数据
需要去掉in_pmt_logistic和in_send获取数据的逻辑 

历史记录里
左侧物流单信息修订 不变 但是需要把结算汇率移动到 付款修订记录去
同时运费显示 需要修改为 运费(RMB) 后面的金额前面需要一个 货币的TAG (RMB)

右侧的付款修订记录, 需要读取in_pmt_logistic表获取, 包含汇率 汇率需要展示是自动还是手动

删除付款的功能
需要复制in_pmt_logistic的这一行, 然后把数据中的logistic_paid改成空, extra_paid改为空, extra_currency改为空, extra_note改为空, note改为 删除订单, seq数字在原有基础加1, log_ops 改为adjust  date_record改成今天
被删除后, 删除按钮变成恢复
功能为找到in_pmt_logistic中这次被删除的行, 找到其seg, 然后通过seq-1找到删除之前的行的数据
复制此行, 修改date_record为今天, seq为上面删除的行的seq+1, note为 恢复删除 ops改为adjust

新建

严格审计全部逻辑 做好修改
所有读取,写入, 逻辑判断都要迁移过来


新建数据库表 in_pmt_deposit
po_num: 用户选择的订单号
dep_date: 支付日期 用户选择 YYYY-DD-MM
dep_paid_cur: 定金支付金额汇率
dep_cur_mode: 定金汇率获取方式
dep_paid: 定金支付金额, 用户录入
dep_method: 是否用预付款付定金
dep_override: 用户选择是否覆盖
ops: 操作类型 new/adjust
seq: 当前记录版本号 D## ##为数字 01开始 递增
by: 当前操作的用户名
note: 操作备注

新建数据库表 in_pmt_deposit_final 这个表根据in_pmt_deposit的ops作为触发器, new时写入新行,adjust时替代老行以po_num为准
po_num: 
dep_date: 
dep_paid_cur: 
dep_cur_mode:
dep_paid: 
dep_method:
dep_override: 
seq: 
by: 
note: 

新建功能 定金付款管理 为新路由deposit 在财务板块下面 同时在Hub页新增卡片入口
此页面进入的页面和 物流财务管理 设计完全一样
批量付款也一样
列表修改一下

订货单号: in_po_final表里的每一个每个唯一的po_num, 但是要过滤掉in_po_strategy 里在该po_num下seq数值最大的那行 cur_deposit值为0的po_num, 这样子的不展示
订单日期: po_num中 AAYYYYMMDD-S## A为字母 ##为数字 拆解出来的YYYY-MM-DD
订单SKU数: 该po_num在in_po_final中所有unique的po_sku数量
订单总金额: 通过上面的po_num去in_po_final里po_num匹配到所有行, 取这些行的 列po_price 乘以 列po_quantity的 然后相加的和
结算货币: 通过上面的po_num去in_po_strategy获取cur_currency 需要选取seq数字最大的那个
结算汇率: 通过上面的po_num去in_po_strategy获取cur_usd_rmb 需要选取seq数字最大那个
定金比例和费用: (比例:通过上面的po_num去in_po_strategy获取cur_deposit_par 需要选取seq数字最大那个) (费用:用订单总金额乘以比例) 根据结算货币, 若是RMB需要额外根据上面的汇率得出USD
实际支付定金金额: 
in_pm_deposit_final表 该po_num下dep_paid的总和 注意在计算总和时 需要看每个满足的行的dep_cur, 若dep_cur和 结算货币是一个种类, 则不需要做汇率, 如果不是一个种类 需要通过汇率统一单位
定金待付: 定金费用-实际支付定金金额
尾款剩余: 订单总金额减去实际支付定金金额

============================

in_pmt_deposit
pmt_no: 传入 {po_num}_N01, 若存在则+1
po_num: 传入被付款的订单号, 每个订单号决定一行, 所以有几个订单号则需要传入几行
dep_date: 流程2中选择的付款日期
dep_paid_cur: 该po_num在 流程2中确定的汇率
dep_cur_mode: 该po_num在 流程2中确定的汇率的获取方式 如果是自动 写入A, 手动填写写入M
dep_cur: 该po_num在流程2传入流程3的 本次支付列 中选择的支付货币 如果用户原额 则是 根原订单一样 只能是RMB/USD 若用户选择 自定义, 则根据实际选择传递, 只能是RMB/USD
dep_paid: 流程2中传入流程3该po_num 本次支付列 的金额 注意使用需要使用dep_cur对应的货币金额
dep_prepay_amount: 流程3中明细表中 该po_num本次抵扣列的抵扣金额, 注意选择该抵扣金额使用的货币, 要传递这货币对应金额的数字, 而不是用汇率转换过的金额
dep_override: 流程2该po_num覆盖列的数据, 如果 开关被打开, 写入1, 如果开关为关闭 写入0
extra_note: 流程2中传入流程3 的 额外费用 块 写入的 费用内容, 若为空 则不写入信息
extra_amount: 流程2中传入流程3 的 额外费用 块 写入的 费用金额, 若为空 则不写入信息
extra_cur:流程2中传入流程3 的 额外费用 块 写入的 结算币种, 若为空 则不写入信息
ops:写入 new
seq: 写入 D01
by: 写入 操作用户名
note: 写入 原始定金支付

in_pmt_prepay (注意in_pmt_deposit中有写入且dep_prepay_amount有大于0的数据, in_pmt_prepay就需要写入,否则不需要写入)
tran_num: 写入操作流水号 {supplier_code}_{tran_date 需要改成YYYYMMDD}_{tran_type}_## ##为数字 若前面遇到相同的就递增 从01开始
supplier_code: 记录厂商ID 这里的厂商ID 可以从 写入in_pmt_deposit的po_num前两位字母获取
tran_date: 记录写入in_pmt_deposit的dep_date YYYY-MM-DD
tran_curr_req: 记录厂商要求的货币种类 USD/RMB  这个来自于in_supplier_strategy中该supplier_code中currency数据 但是主要要以tran_date为基础, 从effective_date中选择比tran_date早, 但是最近的一个日期
tran_curr_use: 记录流程2中对应的po_num中的订单结算货币 RMB/USD
usd_rmb: 记录写入in_pmt_deposit的dep_paid_cur的数据
tran_amount: 记录写入in_pmt_deposit的dep_prepay_amount的数据
tran_type: 写入out
tran_ops: 写入 new
tran_seq: 写入 T01
tran_note: 写入 Deposit_{pmt_no}_原始记录 pmt_no来自于in_pmt_deposit
tran_curr_type: 记录写入in_pmt_deposit的dep_cur_mode的数据
tran_by: 写入操作的用户名


==========================



厂商的余额
需要读取in_pmt_prepay_final表
获取该供应商 通过筛选该供应商 supplier_code 满足的行 获取
当前余额
具体方式为每行数据的 
tran_amout为金额, 
tran_curr_use为此行支付时采用的货币种类
usd_rmb为汇率
tran_curr_req为厂商要求的货币种类
tran_type若是in则为增加, out为减少
计算逻辑为, 首先比对 tran_curr_req和tran_curr_use, 若不一样 就需要用汇率换算金额
然后根据tran_type把每行的数字加减, 得到余额
这个余额需要在框体里面 并展示其货币tag, 同时若不是USD 需要换算, 展示USD金额

然后使用ui-toggle 用户如果打开
可以输入使用的金额 但是金额不得超过余额

注意货币, 金额的使用上若货币不同, 则需要用定金里的汇率去实时更新货币实际对应的金额

下方统计栏的本次支付中, 需要有两块, 一块是来自于预付款, 一块是来自于本次应付款, 本次应付款=本次支付-预付款
显示的方式不变

流程3中的统计 本次支付中也需要对应这个



我希望能合并本次支付和厂商预付款两列变成 本次支付
这里变成一个横向三栏的流程 (在列表的该行这个这一列的位置)
使用厂商预付款框->输入额外支付额框->本次支付总额框
使用厂商预付款
会展示当前厂商预付款余额(余额展示需要在余额前展示厂商余额的货币TAG)
两个按钮选项上下分布, 全部使用, 
若余额为0, 则此项目为灰不可交互

输入额外支付额
这个是可选项目, 用户可以点原额(自动补齐)或者自定义 
自定义也需要选择货币, 然后输入金额, 自动转化货币金额也得有

1. 本次支付总额 会自动更新
2. 当前待付也会根据每个流程输入自动更新
3. 修改汇率栏确认的汇率也会更新下面所有的数值, 若和厂商要求的的货币不匹配
4. 


使用原额 和 自定义的输入金额不变, 但是默认变成厂商该单的结算货币
然后用户可以看到 厂商预付款余额 
并且选择用预付款余额支付 原额 和 自定义金额
若不足, 用户可以选择支付 输入额外支付金额 这个输入的额外支付金额 



===============
定金付款管理
判定订单定金是否被支付

该订单的定金待付 金额<=0
或者
该订单号在po_num在in_pmt_deposit_final中的dep_override列取值为1


定金付款管理


保持未支付部门完全不变
定金已支付订单

这里 我们需要修改下页面显示
左侧是供应商选择, 右侧是该供应商旗下定金被支付的详细列表

左侧的供应商选择如 厂商预付款管理 左侧的列一样
不要+号支付按钮, 也不要显示任何金额

右侧用列表展示已支付定金的订单

此外, 当用户没有点击左侧供应商名片时 右侧则展示所有已支付的定金订单, 无视厂商
右侧的年份筛选会应用到所有这个已支付板块的时间筛选



当点击个已支付订单时, 会向下展开一个列表, 再点击该订单会被折叠回来
该列表会显示该订单相关全部订单支付信息
数据源于in_pmt_deposit_final, 以po_num为筛选, 有几行就需要几行显示
数据列如下
付款单号: pmt_no
厂商结算币种: in_po_strategy 该po_num下seq列最大的数字行中的cur_currency tag展示
支付日期: dep_date
定金支付汇率和获取方式: 汇率是dep_paid_cur, 获取方式用tag展示为 dep_cur_mode (A为自动获取, M为手动输入)
定金支付金额: dep_paid 需要在前面使用结算货币tag展示 来源是dep_cur
预付款抵扣金额: dep_prepay_amount 数字前面需要展示厂商结算币种
是否覆盖: dep_override, 如果是1 展示为 是 如果是0 展示为否
额外费用:extra_amount 数字前面需要加入 extra_cur作为货币tag







========
po_num: in_po_final表里的每一个每个唯一的po_num 这个表根据这个来
po_cost: 通过上面的po_num去in_po_final里po_num匹配到所有行, 取这些行的 列po_price 乘以 列po_quantity的 然后相加的和
po_currency: 通过上面的po_num去in_po_strategy获取cur_currency 需要选取seq数字最大的那个
dep_usd_rmb: 通过上面的po_num去in_po_strategy获取cur_usd_rmb 需要选取seq数字最大那个
dep_par: 通过上面的po_num去in_po_strategy获取cur_deposit_par 需要选取seq数字最大那个
========
dep_usd_mode: 通过上面的po_num去in_po_strategy获取cur_mode 需要选取seq数字最大那个



货单单号: 该po_num在in_send_final表中该po_num对应的sent_logistic_num (注意可能有子发货单号有个delay的,这个子单号要放在母单下面 不要单独成行)
发货日期: 该po_num在in_send_final表中send_date (该日期根据规则是唯一的)
预计到达: 该po_num在in_send_final表中该po_num对应的sent_logistic_num 去匹配 in_send里的logistic_num下的date_eta (注意可能有子发货单号有个delay的,这个子单号要放在母单下面 不要单独成行)




在aid/module目录下 新建一个 修改功能按钮.md
深度解析 采购板块 发货单管理 修改发货单向导 功能 的核心逻辑和实现方式
当前修改功能实际上是新建采购订单向导 一种变体
理解这个逻辑 和 修改界面的展示方式
强调公有组件的使用
注意在日后的使用中有很大的灵活性 但是重点就是在于当前修改实际上是新建 一种变体


目的是建立一个组件的工程文件描述, 这个功能在日后 项目的很多地方都会被复用 但是记住 在别的地方需要遵守别的地方的逻辑 这个只是个模版 懂了吧
我希望日后我让你读这个md的时候 就能很容易找到如何做
所以这个是用于给AI AGENT做reference的工程文件
详细的描述这个功能 使得AI立刻能理解
功能中如果涉及到的内容 例如密码策略, 数据库解读 等等 有很多可能
你可以参考我们现有的aid文件夹内的md文件 内容
但是你可以不用复述那些内容在这里 只是在涉及到的时候 提示AI AGENT那些内容去哪个MD里查看



新建数据库表 in_pmt_po 用于记录订单付款明细
需要下列字段
pmt_no: 自动生成的付款单号 PPMT_{[po_num]}_N## ##代表数字,01开始, 若前面有重复就+1 这是表中唯一的key
po_num: 记录该付款对应的订单号
pmt_date: YYYY-MM-DD 记录用户选择的付款日期
pmt_currency: 记录用户选择的付款货币种类 只能是RMB或USD
pmt_cash_amount: 记录用户本次付款的金额
pmt_fe_rate: 记录用户本次付款的结算汇率
pmt_fe_mode: 结算汇率的获取方式 M为手动输入, A为自动获取
pmt_prepay_amount: 记录使用供应商预付款支付货款的金额
pmt_override: 记录是否无视余额,将订单视为已支付完毕 1为是 0为否
extra_note: 记录额外付款项目名字
extra_amount: 记录额外付款金额
extra_currency: 记录额外付款货币种类 只能是RMB或USD
ops: 数据库表的驱动器列
seq: P## ##代表数字, 从01开始
by: 记录操作用户
note: 记录操作备注

新建数据库表 in_pmt_po_final 用于记录订单付款终态 由 in_pmt_po表的驱动列ops操作, 当ops为delete的时候删除以pmt_no查询的行, 当ops为adjust的时候 用该行覆盖终态表以pmt_no查询的行 当ops为new的时候写入新行
需要下列字段
pmt_no: 
pmt_date:
pmt_currency: 
pmt_cash_amount: 
pmt_fe_rate: 
pmt_fe_mode: 
pmt_prepay_amount: 
pmt_override: 
extra_note: 
extra_amount: 
extra_currency: 
seq: 
by: 
note: 

我给你一下这个板块中 主页面一些信息的数据来源 你深入理解一下 结合相应的数据库表
然后把你的理解写入aid/Logic 中的 订单支付.md里 然后我们更新 订单付款管理 在显示订单待付清单和订单已支付的逻辑

1. 订单总金额
在in_po_final表中
该订单号po_num下 所有po_sku的 po_quantity 乘以 po_price的和相加
但是这个po_price涉及到汇率转化问题

在in_po_strategy表中, 该订单号po_num下, seq列数字最大的行 里的 
cur_currency就是在下订单时约定好的货币种类
而该行中的cur_usd_rmb则是当时下订单时的结算汇率 而cur_mode则是该汇率是否自动获取(A) 还是 手动输入(M)的约定

我们在这个每个明细表中, 都会有一个类似于seq的版本列, 记录版本号, 版本号最大的就是最新版本

若一个厂商的订单结算货币是RMB 这是最简单的情况, 意味着不论汇率如何变化, 厂商只需要获得一个固定约定好的订单的RMB价格的支付即可, 我们作为支付方 不论汇率如何变化
始终会让厂商收到一个固定金额 所以汇率浮动对于支付货币是RMB的不产生任何变化

若一个厂商的订单结算货币是USD, 就有些许复杂, 在in_po_strategy里有一个cur_float (0/1) 和与之关联的 cur_ex_float 浮动百分比
这个意思就是说 结算日的汇率 对比 订单日汇率 若超过cur_ex_float, 也就是这个阈值, 那么对应的原来的价格是否也要跟随浮动 cur_float的1代表需要跟随浮动, 0则代表不浮动
例如价格是100, 汇率浮动阈值cur_ex_float厂商给的是2, 那就意味着 如果汇率浮动百分比超过了2% 那么对应的USD费用会提升或者降低相应的汇率浮动百分比再按照当前的汇率去交易
也就是汇率浮动超过阈值的时候, 价格会跟随变化, 因为我们付款时是按照付款日的汇率进行换算的, 所以汇率大额浮动会造成一定影响,采用阈值跟随可以抵消过大造成的损失或者盈利,使其一直保持在一个相对稳定的中间值上
若汇率浮动不超过2% 那就意味着不产生变化 按照原计划去支付

所以当一个厂商结算货币是USD时 而汇率浮动开关(cur_float)打开时, 订单总金额就会跟随浮动而浮动 所以是一个动态数值

2. 已付定金
已付定金涵盖了 用户在 定金功能中已经支付的定金, 定金通常是在订货时立刻就要支付, 所以不受到汇率浮动影响
而在 定金付款管理 中 所有定金已支付订单 表中(也就是点击可以展开看明细 使用按钮那里) 已付定金列 已经给出了一个十分好的计算方式

若一个订单在查询自身在in_po_strategy中 cur_deposit_par为0, 且且cur_deposit为关闭(读取为0)的情况下, 那么该订单是不需要被支付定金的
所以不会在定金板块中显示 也不能在那个版快中被支付

若一个订单在查询自身在in_po_stategy中 cur_deposit_par不为0, 且cur_deposit为打开(读取为1)的情况下, 那么该订单是必须先被支付定金的
必须首先满足定金的支付, 才能被支付尾款, 或者当dep_override被打开了 意味着厂商同意我们以不足量支付定金计入算作定金支付完毕, 或者我们支付比实际需求更多的定金
这两种开启都是是作为定金已被支付. 若是不足量支付定金 这个是可以用户灵活选择的 根据和厂商谈判, 而超付的情况 是一定会被标记为定金已支付的
但是根据实际运营来说, 没有支付定金直接支付尾款也是被允许的, 那么尾款就是订单金额了

关于定金 在定金页面中的功能是对于定金最好的描述和定义

3. 已付货款 (需要新增)
关于已付货款是需要查询in_pmt_final表的, 该数字为
所有满足的该po_num的行 所有行的付款金额pmt_cash_amount的和 与所有行的 抵付金额(pmt_prepay_amount)的和 相加
但是同理只要涉及到付款金额都会有一个货币和存在
汇率是按照付款日去获取的 或者用户手动录入合同规定的汇率
而货币也是用户选择, 所以当货币与厂商接受交易货币(上面有说)不同的时候, 是需要拿汇率来换算的
如果是相同的货币, 则不需要再去换算了 直接加即可
在支付里面 抵扣一定是预付款, 预付款 支持的货币是需要去in_po_strategy 里通过po_num去找的cur_currency
而用户支付的cash_amount就是除了抵扣外支付的基恩, 货币为前面的pmt_currency, 结算汇率为记录的付款当日的汇率pmt_fe_rate, 获取方式为pmt_fe_mod
若支付货币和订单结算部同意也需要用这个汇率去换算

和订单付费相关的款项会被记录在下面表格中

in_pmt_po 用于记录订单付款明细
字段为
pmt_no: 自动生成的付款单号 PPMT_{[po_num]}_N## ##代表数字,01开始, 若前面有重复就+1 这是表中唯一的key
po_num: 记录该付款对应的订单号
pmt_date: YYYY-MM-DD 记录用户选择的付款日期
pmt_currency: 记录用户选择的付款货币种类 只能是RMB或USD
pmt_cash_amount: 记录用户本次付款的金额
pmt_fe_rate: 记录用户本次付款的结算汇率
pmt_fe_mode: 结算汇率的获取方式 M为手动输入, A为自动获取
pmt_prepay_amount: 记录使用供应商预付款支付货款的金额
pmt_override: 记录是否无视余额,将订单视为已支付完毕 1为是 0为否
extra_note: 记录额外付款项目名字
extra_amount: 记录额外付款金额
extra_currency: 记录额外付款货币种类 只能是RMB或USD
ops: 数据库表的驱动器列
seq: P## ##代表数字, 从01开始
by: 记录操作用户
note: 记录操作备注

而其对应的终态表为 in_pmt_po_final 用于记录订单付款终态 由 in_pmt_po表的驱动列ops操作, 当ops为delete的时候删除以pmt_no查询的行, 当ops为adjust的时候 用该行覆盖终态表以pmt_no查询的行 当ops为new的时候写入新行
字段为
pmt_no: 
pmt_date:
pmt_currency: 
pmt_cash_amount: 
pmt_fe_rate: 
pmt_fe_mode: 
pmt_prepay_amount: 
pmt_override: 
extra_note: 
extra_amount: 
extra_currency: 
seq: 
by: 
note:

4. 尾款剩余
所以尾款的计算就应该是订单总金额 减 已付定金 减 已付货款 
因为我们在每个流程中都严格以厂商接受的货币种类换算过了 所以这里也是对齐的了
并且我们都按照支付点的时间点汇率结算了 所以也没有问题


那么我们怎么判断一个订单是否已经支付完成呢
那就是当尾款剩余 小于或者等于0的时候 我们就认为该订单已被完全支付了
还有一个情况就是 in_pmt_po_final 中该订单号下 出现了pmt_override为1的情况 这种情况通常用于供货商给予的某种减免不再追缴差值 视作交易完成





in_pmt_po 有多少个po_num就需要上传多少条进这个表
pmt_no: 自动生成的付款单号 PPMT_{[po_num]}_N## ##代表数字,01开始, 若前面有重复就+1 这是表中唯一的key
po_num: 记录该付款对应的订单号
pmt_date: YYYY-MM-DD 记录用户选择的付款日期
pmt_currency: 记录该po_bum用户选择的付款货币种类 只能是RMB或USD 如果是 原额 则采用流程2中 该行的订单结算货币
pmt_cash_amount: 记录该po_bum用户本次支付的金额
pmt_fe_rate: 记录用户本次付款的结算汇率
pmt_fe_mode: 结算汇率的获取方式 M为手动输入, A为自动获取
pmt_prepay_amount: 记录该po_bum使用供应商预付款支付货款的金额
pmt_override: 记录该po_bum是否无视余额,将订单视为已支付完毕(减免) 1为是 0为否
extra_note: 记录额外付款项目名字
extra_amount: 记录额外付款金额 该金额在每个po_num下均分 就是总额/po_num的个数
extra_currency: 记录额外付款货币种类 只能是RMB或USD
ops: 写入new
seq: P## ##代表数字, 从01开始
by: 记录操作用户
note: 写入 原始货款单


in_pmt_prepay (注意in_pmt_po中有写入且pmt_prepay_amount有大于0的数据, in_pmt_prepay就需要写入,否则不需要写入)
tran_num: 写入操作流水号 {supplier_code}_{tran_date 需要改成YYYYMMDD}_{tran_type}_## ##为数字 若前面遇到相同的就递增 从01开始
supplier_code: 记录厂商ID 这里的厂商ID 可以从 写入in_pmt_po的po_num前两位字母获取
tran_date: 记录写入in_pmt_po的pmt_date YYYY-MM-DD
tran_curr_req: 记录厂商要求的货币种类 USD/RMB  这个来自于in_supplier_strategy中该supplier_code中currency数据 但是主要要以pmt_date为基础, 从effective_date中选择比tran_date早, 但是最近的一个日期
tran_curr_use: 记录流程2中对应的po_num中的订单结算货币 RMB/USD
usd_rmb: 记录写入in_pmt_po的pmt_fe_rate的数据
tran_amount: 记录写入in_pmt_po的pmt_prepay_amount的数据
tran_type: 写入out
tran_ops: 写入 new
tran_seq: 写入 T01
tran_note: 写入 POPAY_{pmt_no}_原始记录 pmt_no来自于in_pmt_po
tran_curr_type: 记录写入in_pmt_po的pmt_fe_mode的数据
tran_by: 写入操作的用户名

然后你需要根据我们现有的文件上传的统一性 选择用户上传文件的路径
你可以参考一下 文件存储规范.md

还有什么不懂不清楚 不要猜 直接问我




删除按钮功能背后逻辑为


删除时会首先读取该行的 付款单号
拿着这个付款单号 去表im_pmt_po中查询一下, 其下面有多少个独一无二的po_num
然后根据这个pmt_no下每个独一无二的po_num, 找出每个po_num中seq数字最大的那行
复制这些行, 也就是在该pmt_no下有几个po_num就要写几行
把这些行的
ops:写入delete
seq: 在原有基础上+1
by: 记录操作用户
note: 写入 删除支付_{by}_{本日日期YYYYMMDD}
其他列写入信息不变


若在上一步找到的行中pmt_prepay_amount>0
则也需要去写入in_pmt_prepay
通过上面的表的pmt_no
然后去到in_pmt_prepay表中 找到 tran_note 以POPAY_{pmt_no}开头的行 找到tran_seq最大的数字那行
复制该行信息
tran_num: 写入操作流水号 {supplier_code}_{tran_date 需要改成YYYYMMDD}_{tran_type}_## ##为数字 若前面遇到相同的就递增 从01开始
tran_type: 写入in
tran_ops: 写入 new
tran_seq: 写入  原有基础+1
tran_note: 写入 删除PO付款_POPAY_{pmt_no}
tran_curr_type: 记录写入in_pmt_po的pmt_fe_mode的数据
tran_by: 写入操作的用户名

in_pmt_po 有多少个po_num就需要上传多少条进这个表
pmt_no: 自动生成的付款单号 PPMT_{[po_num]}_N## ##代表数字,01开始, 若前面有重复就+1 这是表中唯一的key
po_num: 记录该付款对应的订单号
pmt_date: YYYY-MM-DD 记录用户选择的付款日期
pmt_currency: 记录该po_bum用户选择的付款货币种类 只能是RMB或USD 如果是 原额 则采用流程2中 该行的订单结算货币
pmt_cash_amount: 记录该po_bum用户本次支付的金额
pmt_fe_rate: 记录用户本次付款的结算汇率
pmt_fe_mode: 结算汇率的获取方式 M为手动输入, A为自动获取
pmt_prepay_amount: 记录该po_bum使用供应商预付款支付货款的金额
pmt_override: 记录该po_bum是否无视余额,将订单视为已支付完毕(减免) 1为是 0为否
extra_note: 记录额外付款项目名字
extra_amount: 记录额外付款金额 该金额在每个po_num下均分 就是总额/po_num的个数
extra_currency: 记录额外付款货币种类 只能是RMB或USD
ops: 写入new
seq: P## ##代表数字, 从01开始
by: 记录操作用户
note: 写入 原始货款单



我们回到 订单付款管理
在待付清单这个部分
我们需要在订单总金额前面新增一列标题是 订单状态
此项内容是判定该订单在采购流程中的状态

首先我们要提取这个订单号po_num
当我们去到in_po_final表中 这个表记录了所有订单的订货最终状态
在这个表中该订单号po_num所对应的 po_sku, po_price, po_quantity就是该订单的明细信息

然后在in_send_final表中, 这个表记录了所有订单的发货最终状态
在这个表中该订单号po_num所对应的 po_sku, po_price, send_quantity就是该订单的发货状态, 但是要注意这里的send_quantity不一定和订单的po_quantity对应
这个理解就是说订单的货物没有全部发出, 可能迟发或者延迟发送

然后在in_receive_final表中, 这个表记录了所有订单的收货最终状态, 也就是入库了
在这个表中该订单号po_num所对应的 po_sku, po_price, receive_quantity就是该订单的实际收货状态, 但是要注意这里的receive_quantity反应的是实际收货数量
理解就是说当前收货的数量可能和实际发货数量有出入,可能多, 可能少

然后在in_diff_final表中, 这个表记录了所有订单的在收货与发货的差异最终状态
这个表在收货和发货的数量没有差异的时候是不会记录的
在这个表中该订单号po_num所对应的 po_sku, po_price, diff_quantity就是差异数, 若这个数不是0 则代表问题没有解决
需要先解决问题才能进行付款

所以 我们对于这整个流程来理解就是
po_num在in_po_final中开始 然后流程进入 in_send_final, 然后进入 in_receive_final, 最后差异会进入in_diff_final 如果存在的话
整个流程中 每个po_num下的 po_sku和po_price决定了每个po_num下的货物清单, 而每个流程中在上面描述的相关quantity则代表该流程中 货物清单的每一个的数量

这就形成了一个完成链条,那么这个链条对应的 财务板块中的付款是如何的呢
当in_po_final表中建立的时候, 货物订单和款项就被建立了
此时如果需要支付定金 那么费用的时间就是这个建立的时间了
那么根据我们通用规则来说 货物被发出的时候就支付货款的尾款或者说全额支付订单了
也就是当流程进行到 in_send_final的时候 就需要支付尾款了或者货物单了, 若没有则不需要支付

那么关于特殊情况的差异怎么算呢, 那么特殊差异情况产生时吗 那么in_diff_final中该订单号下的diff_quantity不为0
当这些差异被解决了, 根据规则 这个表的差异就会被覆盖为0
和付款的关系就是 差异的产生不会影响订单的建立和定金的支付, 但是会直接影响尾款或者货物款全款(在没有定金情况)下的数值
所以说当差异没有被解决的时候 是不可以支付尾款或者货物全款的

所以这个订单状态要设计一下 是用于告知用户当前的货物单情况的, 若我们上述说的内容差异存在且没有解决的情况 是不可以被选中付款的

此外 你也需要深入理解这个流程和流程逻辑
有一个大局观就是按照订单po_num来定义状态, 而细节观, 就是进入订单, 按照po_sku,po_price去匹配其对应的数量去深究订单中每个货物在流程中的状态

这个理解你需要写入 aid/Logic 订收发流程.md里
你好好去理解一下 也可以查看现有的数据库表 数据 和 采购板块的里的流程去理解
注意在in_diff和明细表和终态表in_diff_final有个列 status本来设计来展示异常处理情况的 后面也没有用
所以你可以忽略

看看有没有什么不懂的内容 千万不要猜 不要改变原有逻辑 如果哪怕有一点点的不懂和不理解 可以来问我




此外在财务板块的hub页中 最好在每个功能的图标上面有个数字标记
这个数据标记类似于 苹果UI中 那种提示
例如收取了短信 没有阅读 数字显示多少个未读在图标上

所以这里一样

逻辑我说一下
物流财务管理里 数字就是待付物流单数量
厂商预付款管理是一个独立于订单外的内容 所以不需要
定金付款管理  数字就定金待付清单的数量 (涵盖每个厂商待付的订单号数量的总和)

付款单管理 数字就是订单待付清单数量(涵盖每个厂商待付的订单号数量总和)

好了 你现在对于整个流程是不是有很清晰的认知了
现在我们需要做一个功能 放在财务板块下面作为子理由
定发收总预览 flow
该页面打开是一个列表的展示页面 
列为 
订单号: 这个为的po_num
订单总金额: 这个为该po_nun的下的总货值 货币TAG为该订单的结算采用的货币 数据源于in_po_final 货币源于in_po_strategy(用seq最大的行)
定金状态: 若该订单不需要定金 则显示 无定金需求 如果需要定金 则需要显示定金费用 和 支付状态 这个在定金板块有很详细的解析
已付货款: 显示该po_num的已付货款 这个去in_pmt_po_final找该po_num下所有行的 pmt_cash_anount和pmt_prepay_amount相加 注意货币的换算 这个在 定金板块有非常详细的解析
货款剩余: 订单总金额-定金金额-已付货款 若无定金要求可跳过定金 这个在订单付款板块有非常详细的解析
订单实际支付金额: 已付货款+已付定金  这个在订单付款板块有非常详细的解析
额外费用: 这个为物流单的额外费用+定金的额外费用+货款的额外费用, 记住这几个费用都是需要摊销的 我想这三个功能的final终态表中应该都有做 你审计一下
发货单号: 为该po_num的 logistic_num 在 in_sned_final去找, 多个发货单号需要都被写入, 一个单号一个tag
订单物流重量: 根据in_send_final的表中该订单的终态信息, 然后需要按照物流单号划分, 根据物流单号计算后汇总, 每个物流单号中以该订单中下面的po_sku去汇总send_quantity, 然后根据po_sku去匹配 数据库表Data_COGS 中SKU列, 拿到其后面的weight, 这个weight就是该SKU的重量, 然后乘以前面拿到Quantity得到总重量, 汇总后除以1000 得到KG
订单物流摊销: 这个需要根据每物流单的情况去摊销后相加, 每个物流单的摊销如下, 拿到物流单总价之后, 我们也可以从该物流单 在in_send表中的total_weight, 然后通过当前订单的总重占比去摊销该物流单的费用
订单总成本: 订单实际支付金额+额外费用+订单总成本
订单状态: 发货状态, 已发货/部分发货 已收货/部分收货(有差异) 因为一个订单可能对应多个物流单, 那么我们需要一个原则就是当所有物流单都是完成状态才能确定完成状态
付款状态: 分为定金,货款, 物流三个部分展示 因为一个订单可能对应多个物流单, 那么我们需要一个原则就是当所有物流单都是完成状态才能确定完成状态
展开列(不要表头): 一个向下箭头 可以展开看明细, 明细后面补充


这里逻辑十分复杂 如果你有丝毫不懂的 就要问我 或者自己查数据表结构理解
千万不要猜测 尤其是字段名字


我们接下来做展开的列表

展开的列表 会按照物流单来分块(若是 带 {物流单号}_delay_V## 这种的都算入母单去) 这些数据也需要是动态的

块的header为 物流单号
列为 

SKU: 该物流单号下该订单号里所有的SKU 这个可以去in_sned_final这里有
理论单价: 该SKU的单价 po_price (若一个订单里同一个SKU有多个价格 则需要分多行,所以po_sku, po_price是key),记得在前面加上货币TAG 这里采用订单的货币符号 若不是USD要转换成为USD 汇率转化同等于该订单上面计算订单总金额的汇率转化方式
实际单价: 实际单价需要根据首先获取 实际支付费用和订单总金额 比例, 按照这个去实现实际单价的等比转换 这里不需要汇率的计算 直接按比例转换即可
费用摊销: 
费用摊销的计算方式分两块, 额外费用和物流摊销


物流摊销 计算和 母表一样, 但是母表中会把同订单不同的发货单的叠加, 这里不需要, 这里就是单独当前这个物流单下 该po_num的费用 (若是 带 {物流单号}_delay_V## 这种的都算入母单去)
拿到这个费用后, 我们需要首先按照当前SKU的数量和重量(获取方式去Data_COGS找这个SKU的Weight, 单位是g你转化成为kg)相乘得到当前SKU发货的总重量
同样的方式去计算该物流单下所有的SKU重量和数量相乘的总重量 这里注意这个总重量计算会无视掉这个SKU 是否来与当前订单 是完全按照发货单号来算的 这一点我希望你懂得原因
然后前者除以后者可以拿到一个比例, 通过这个比例 乘以 总物流费用 再除以当前SKU的的数量, 可以得到这个单个SKU 物流的摊销
为了动态法则, 物流总费用 汇率来源和目标是保持一致的

额外费用方面 额外费用来自于定金和货款是被记录在po_num下的 所以一个po_num中汇总的额外费用, 需要根据一个po_num中有多少发货单进行摊销(delay不算+1发货单), 所以就是这块的额外费用汇总后 除以一个订单号下有多少个物流单号, 分摊后把这个费用在做物流摊销之前加入物流总费用 再去做摊销

而物流额外费用方面,因为是跟着物流走单走的, 所以我们把这个物流的额外费用除以一个物流单有多少个po_num分摊后进入订单中去, 所以我们在做摊销的时候可以把这个费用在做物流摊销之前加入物流总费用 再去做摊销
这个摊销费用保留5位小数 全流程注意货币的换算和汇率的获取 这个东西我们做过很多次了 

入库单价: 等于 货物单价+物流摊销, 保持5位小数
数量: 该SKU在表中的sent_quantity
总价: 入库单价成语数控 保留2小数 四舍五入


我再给你一个例子

假设AA01物流单100KG 和 BB01物流单150KG 我们从来不管这东西 因为这个是来自于 in_send里的用于计算运费 与我们内部成本摊销比例毫无关系
A,B,C, D 是产品 分别重3g, 5g, 7g, 2g


那么我们有订单 D001 和 D002
D001 里的产品有
A 100个
B 150个
C 300个

D002 的产品有
A 200个
B 100个
C 150个
D 300个



其中额外费用 AA01 额外物流费 50

订单定金额外费用 DD01 额外 60 已知AD001发了2单了(包含了AA01) 但是依然没发完


发货单AA01
发了 D001
A: 100个 重量为 3x100=300  这里A的占比就是300/(300+500+1400+500+700+600)
B: 100个 重量为 5x100=500 这里B的占比就是500/(300+500+1400+500+700+600)
C: 200个 重量为 7x200=1400 这里C的占比就是1400/(300+500+1400+500+700+600)

也发了D002
B 100个 重量为 5X100=500 这里B的占比就是500/(300+500+1400+500+700+600)
C 100个 重量为 7X100=700 这里C的占比就是700/(300+500+1400+500+700+600)
D 300个 重量为 2X300=600 这里D的占比就是600/(300+500+1400+500+700+600)

通过占比去摊销AA01的 物流费 假如物流费是10000
那么D001单的A产品的成本摊销是多少  

先来算物流额外费用
原来物流费10000+物流额外费50=10050
再来算订单额外费用
额外60发了两单 还没发完的的咋办 关我屁事, 我暂时算已经发过的 多了日后再改
60/2=30
当前物流费10050+30=100080

D001中的A 根据重量算出来他的总重是300 那么占比就是300/4000= 7.5% 
所以D001里A的运费分担 就是10080x7.5%=756
那么A有100个 每个分担怎么算 756/100=7.56

假如A的原价是300 那么A现在就是307.56


那怎么没有发货的怎么算
D002里的A 没发货
要分担运费么? 他都没有费用怎么摊销
要分单额外费用么? 有订单了再说啊 现在没有咋分担 先分担给已经发过的 没有发的发了再说
那么A的最终成本是多少 300+0+0=300

后来有人说本来这个订单是30000, 但是实际实付是33000 因为汇率或者其他原因
多了3000 咋摊销 比例10%
额外费用他增加了么? 没有
运费他增加了么? 没有 
发货量增加了么? 没有
那么增量算给谁 算给原价 300*(1+10%)=330

现在费用咋算 330+之前分担的=330+7.56=337.56


我们来手动算一下 TEST01这单
你物流费5000RMB

XX20260102-S01 订单 
NE3C3B37K 4200个 重量是79/个  总重331800
5102SH571T12 100个 重量是 443/个 总重44300
这单你给了832.01的运费分摊
这单占比 (331800+44300)/(331800+44300+904340+425700)=0.2204391199
5000x22.4%1102.195599


LF20260101-S01 订单修改向导的
NU1C9E46C 2060 重量439一个  总重904340
NU1C9H36K 990 重量430一个    总重425700
这单占比0.7795608801
费用分担3897.804401

这单你给了4167.99的运费分摊





好 现在你去看看我们数据库的fifo系列表格 也就是in_dynamic系列
我先解释一下意图
交易数据上传 这个功能流程结束后 会把交易数据做清洗和处理 准备好给 报表生成器 和 数据交互可视化 分析
所以这相当于一个前置流程 对么

那么我想知道一下 交易数据上传中 系统是否具备自动判定哪些是重复数据 自动去掉 不产生重复数据在数据库表中








采购订单管理 - 删除/回复 成功报错

采购订单管理 - 查看历史  策略修改栏错误

发货管理 -  





Listing Management

Listing Metadata

https://developer.ebay.com/api-docs/sell/fulfillment/static/overview.html
https://developer.ebay.com/api-docs/sell/logistics/resources/methods

https://developer.ebay.com/devzone/post-order/index.html
https://developer.ebay.com/api-docs/sell/fulfillment/static/overview.html
https://developer.ebay.com/api-docs/sell/static/performance/analyzing-performance.html
https://developer.ebay.com/api-docs/sell/analytics/resources/methods