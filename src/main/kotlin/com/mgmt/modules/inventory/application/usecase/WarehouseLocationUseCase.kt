package com.mgmt.modules.inventory.application.usecase

import com.mgmt.common.exception.ConflictException
import com.mgmt.common.exception.NotFoundException
import com.mgmt.modules.inventory.application.dto.*
import com.mgmt.modules.inventory.domain.model.WarehouseLocation
import com.mgmt.modules.inventory.domain.repository.WarehouseLocationRepository
import jakarta.persistence.EntityManager
import org.springframework.data.domain.PageRequest
import org.springframework.data.domain.Sort
import org.springframework.data.jpa.domain.Specification
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.time.Instant

/**
 * WarehouseLocationUseCase — warehouse bin/slot management.
 *
 * Business rules:
 *  - (warehouse, aisle, bay, level, bin, slot) is UNIQUE
 *  - barcode is auto-generated by PostgreSQL stored column
 */
@Service
class WarehouseLocationUseCase(
    private val repo: WarehouseLocationRepository,
    private val em: EntityManager,
) {

    // ═══════════ Query ═══════════

    @Transactional(readOnly = true)
    fun findAll(params: WarehouseLocationQueryParams): Pair<List<WarehouseLocation>, Long> {
        val page = maxOf(1, params.page)
        val limit = maxOf(1, minOf(params.limit, 200))
        val spec = buildSpec(params)
        val pageable = PageRequest.of(page - 1, limit, Sort.by("warehouse", "aisle", "bay", "level"))
        val result = repo.findAll(spec, pageable)
        return result.content to result.totalElements
    }

    @Transactional(readOnly = true)
    fun findOne(id: Long): WarehouseLocation =
        repo.findById(id).orElseThrow {
            NotFoundException("inventory.errors.warehouseLocationNotFound")
        }

    @Transactional(readOnly = true)
    fun findByBarcode(barcode: String): WarehouseLocation? =
        repo.findByBarcode(barcode)

    // ═══════════ Create ═══════════

    @Transactional
    fun create(dto: CreateWarehouseLocationRequest, username: String): WarehouseLocation {
        if (repo.existsByWarehouseAndAisleAndBayAndLevelAndBinAndSlot(
                dto.warehouse, dto.aisle, dto.bay, dto.level, dto.bin, dto.slot
            )) {
            throw ConflictException("inventory.errors.warehouseLocationExists")
        }

        val loc = WarehouseLocation(
            warehouse = dto.warehouse.trim(),
            aisle = dto.aisle.trim(),
            bay = dto.bay,
            level = dto.level.trim(),
            bin = dto.bin.trim(),
            slot = dto.slot.trim(),
            createdBy = username,
            updatedBy = username,
        )
        val saved = repo.save(loc)
        // Refresh to read back the PostgreSQL GENERATED ALWAYS AS barcode
        em.refresh(saved)
        return saved
    }

    // ═══════════ Delete ═══════════

    @Transactional
    fun delete(id: Long) {
        val loc = findOne(id)
        repo.delete(loc)
    }

    // ═══════════ Helpers ═══════════

    private fun buildSpec(params: WarehouseLocationQueryParams): Specification<WarehouseLocation> {
        @Suppress("DEPRECATION")
        var spec = Specification.where<WarehouseLocation>(null)

        params.warehouse?.let { w ->
            spec = spec.and { root, _, cb -> cb.equal(root.get<String>("warehouse"), w) }
        }

        params.search?.let { s ->
            spec = spec.and { root, _, cb ->
                cb.like(cb.lower(root.get("barcode")), "%${s.lowercase()}%")
            }
        }

        return spec
    }
}
