# 工程强制规则 (Engineering Rules)

> **状态**: 所有工程师必须遵守。违反 CRITICAL 规则 = 自动驳回。
> **来源**: ECC v1.5.0 Rules + 项目实践提炼
> **⚠️ 按需加载: 根据下方路由表跳到需要的 section, 不要全部阅读。**

## 路由表

| 关键词 | 跳转 |
|--------|------|
| `代码风格`, `命名`, `不可变` | → §1 代码风格 |
| `Git`, `commit`, `分支` | → §2 Git 纪律 |
| `验证`, `测试`, `编译`, `lint` | → §5 验证循环 (集成测试门禁) |
| `影响分析`, `消费者`, `共享模块` | → §6 跨文件影响分析 + 共享模块追溯 |
| `React`, `Next.js`, `组件` | → §7 React/Next.js 规则 |
| `Spring`, `后端` | → §8 后端规则 |
| `拆分`, `复用`, `300行`, `新建文件` | → §9 代码拆分与复用 |
| `死循环`, `卡死`, `timeout`, `重试` | → §10 反死循环与终端安全执行 |
| `hooks`, `PreToolUse`, `PostToolUse`, `Stop` | → §10.1 Hooks 执行拦截 |
| `重构`, `迁移`, `等价`, `像素级审计` | → §11 重构保真门禁 |
| `复盘`, `错误记录`, `ERROR-BOOK`, `交叉检查` | → §12 问题复盘铁律 |

## 0. 变更边界铁律（scope-discipline）

### CRITICAL — 违反即驳回

| 规则 | 标准 |
|------|------|
| Strict Scope Rule | 仅修改用户明确提出范围；未提及内容禁止改动 |
| Minimal Change Rule | 仅做满足需求的最小变更；禁止顺手优化/重构 |
| Ask-First Rule | 若必须扩范围，先说明原因与文件清单并获批 |
| Unauthorized Extra Changes | 未获批超范围修改 = Block |

## 1. 代码风格 (coding-style)

### CRITICAL — 违反即驳回

| 规则 | 禁止 | 正确 |
|------|------|------|
| **不可变性** | `modify(original, field, value)` (原地修改) | `update(original, field, value)` (返回新副本) |
| **硬编码凭据** | 代码中写 API key/密码/token | 环境变量/配置文件 |
| **静默吞错** | `catch(e) {}` 空 catch | 记录详细上下文 + 友好消息 |
| **SQL 注入** | 字符串拼接 SQL | 参数化查询 / ORM |
| **日志泄密** | `console.log(password)` | 敏感字段脱敏 |

### HIGH — 必须修复后合并

| 规则 | 标准 |
|------|------|
| 文件行数 | 单文件 200-400 行 (典型), **≤600 行** (CRITICAL: >600 行必须拆分) |
| 函数行数 | 单函数 **≤50 行** |
| 嵌套深度 | **≤4 层**, 超过用早返回 |
| 输入验证 | 所有外部输入在**边界**验证 (Zod/class-validator) |
| 错误处理 | 每层显式处理, UI 给友好消息, 服务端记录详细上下文 |
| 死代码 | 注释代码/未用 import → **合并前删除** |
| Console.log | 调试用的 → **合并前删除** |

### 组织原则

```
✅ 按功能/领域组织, 非按类型
✅ 从大模块提取工具函数
✅ 高内聚低耦合
✅ 命名清晰: 变量描述内容, 函数描述动作
```

---

## 2. Git 工作流 (git-workflow)

| 规则 | 标准 |
|------|------|
| Commit 粒度 | 一个逻辑变更 = 一个 commit |
| 分支策略 | feature/ → develop → main |
| 合并前 | 必须通过验证循环 6 阶段 |

---

## 3. 测试 (testing)

| 规则 | 标准 |
|------|------|
| 最低覆盖率 | **80%** |
| 三种测试 | Unit (单函数) + Integration (API/DB) + E2E (关键流) |

### TDD 强制流程

```
1. 写测试 (RED) → 应该失败
2. 写最小实现 (GREEN) → 应该通过
3. 重构 (IMPROVE) → 代码更好
4. 验证覆盖率 (80%+)
```

---

## 4. 安全 (security)

| 检查项 | 标准 |
|--------|------|
| XSS | 未转义用户输入 → 禁止渲染到 HTML |
| CSRF | 状态变更端点必须有 CSRF 保护 |
| 路径穿越 | 用户控制的文件路径必须清理 |
| 认证绕过 | 受保护路由必须有 Auth Guard |
| 不安全依赖 | 依赖安全检查（见 CONTEXT.md §5 安全命令）高危即修 |
| CORS | 必须配置白名单, 禁止 `*` |
| 限流 | 公开端点必须有 throttle |

---

## 5. 验证循环 (6 阶段 — 每次提交前必须完成)

| 阶段 | 命令（见 CONTEXT.md §5.2）| 通过标准 | 失败 |
|------|--------------------------|---------|------|
| 1. 编译 | `{build_cmd}` | BUILD SUCCESSFUL | **STOP** |
| 2. 类型 | `{typecheck_cmd}` | 零错误 | 修复 |
| 3. Lint | `{lint_cmd}` | 零错误 | 修复 |
| 4. 测试 | `{test_cmd}` | 全通过 | 修复 |
| 5. 覆盖率 | `{coverage_cmd}` | ≥80% | 补测试 |
| 6. 安全 | `{security_audit_cmd}` | 无高危 | 修复 |

**关键: 阶段 1 失败 = 后续全部 STOP, 不继续。**
**🔴 铁律: 集成测试 (阶段 4) 不通过 = 禁止提交完工报告, 发回工程师重做。(详见 `{project}/reference/iron-laws.md` §4)**

### 验证失败重试协议

```
1. 修复失败的阶段
2. 从失败阶段开始重跑 (不需要全部重跑)
3. 最多重试 3 次/阶段
4. 3 次仍失败 → 停下来, 向用户报告:
   "ℹ️ 编译/测试遇到困难, 需要你的帮助:
    • 错误: {具体错误信息}
    • 已尝试: {3 次修复方案}
    • 建议: {Agent 的建议}"
```

### 5.2 循环触发规则（何时必须重跑验证循环）

| 触发条件 | 必须重跑的范围 |
|---------|-------------|
| 完成一个 Spec §4 步骤 | 从阶段 1 开始全量 |
| 任何文件被修改（不论大小） | 至少阶段 1-4 |
| 合并 / PR 提交前 | 全量（阶段 1-6） |
| 测试 PASS 后发现遗漏 | 全量 |

### 5.3 集成测试规则

| 规则 | 标准 |
|------|------|
| **新代码必须有新测试** | 新增功能 ≥ 1 个对应测试用例 |
| **改动范围内旧测试全通过** | 不允许"先合并后补测试" |
| **验收矩阵驱动测试** | Spec §7 验收矩阵中每行 = 至少 1 个测试场景 |
| **禁止注释测试来过关** | 注释掉的测试 = 未完成，不算通过 |

### 5.4 宣布 PASS 条件（明确退出条件）

```
✅ 宣布通过（同时满足）:
   - 验证循环 6 阶段全 ✅
   - Spec §7 验收矩阵全行 PASS
   - 零 CRITICAL 问题（ROOT CAUSE CLASSIFIER 无类型 A/B 未解决）

❌ 禁止宣布通过（任一）:
   - 存在未解决的 CRITICAL 问题
   - 测试覆盖率 < 80%
   - 验收矩阵有未验证的行

⚠️ HIGH 问题处理:
   - 有修复计划（记录在 Spec §5 风险与陷阱）才允许合并
   - 当前 Phase 不得解锁下一 Phase，直到 HIGH 问题有修复时间表
```

---

## 6. 跨文件影响分析 (每次变更后必做)

```bash
# 1. 向下追踪: 谁消费了我修改的文件?
grep -r "import.*{FileName}" --include="*.kt" --include="*.tsx" --include="*.ts" .

# 2. 接口对齐: 后端 Controller 变了 → 前端 API Client 呢?
# DTO 变了 → 消费方都更新了吗?

# 3. 旧引用清理: 确认零残留
grep -r "旧模块名" --include="*.kt" --include="*.ts" .
# 标准: 零匹配

# 4. 🔴 共享模块追溯 (新增)
# 修改了 shared/utils, shared/types, common/ 等共享代码时:
# → 必须 grep 搜索所有消费者
# → 逐一验证不受影响 → 受影响的必须一并更新
# → 未涉及的消费者也要检查是否因接口变更而隐式破坏
grep -r "{SharedModuleName}" --include="*.kt" --include="*.ts" --include="*.tsx" .
# 每个匹配都要打开确认
```

> **🔴 铁律: 修改共享模块后, 必须追溯所有消费者并验证。遗漏 = 回归 Bug。**

---

## 7. React/Next.js 特定规则

| 规则 | 标准 |
|------|------|
| useEffect 依赖 | 依赖数组必须完整 |
| render 中 setState | 🔴 禁止 (无限循环) |
| 列表 key | 禁止用 index, 必须用唯一 ID |
| Prop 穿透 | >3 层 → 用 Context |
| 三态处理 | 每个数据页面必须有 Loading/Error/Empty |
| Server Component | 禁止使用 useState/useEffect |

---

## 8. 后端特定规则（框架通用，具体配置见 CONTEXT.md §3）

| 规则 | 标准 |
|------|------|
| 输入验证 | 请求体必须有 Schema/DTO 校验 |
| N+1 查询 | 禁止循环中查关联数据 → 用 JOIN/批量 |
| 无界查询 | SELECT * 必须有 LIMIT |
| 外部调用 | HTTP 调用必须有 timeout |
| 错误响应 | 内部错误不暴露给客户端 |
| 迁移脚本 | 新字段必须有默认值 or 允许 NULL |

---

*Version: 2.1.0 — 新增 §12 问题复盘铁律（统一真相源）*
*Created: 2026-02-15 | Updated: 2026-02-19*

---

## 9. 代码拆分与复用 (🔴 强制)

### 9.1 拆分规则

| 规则 | 标准 | 违反后果 |
|------|------|----------|
| **单文件上限** | ≤400 行 (典型), ≤600 行 (硬上限, 与 §1 一致) | 超出 → 必须按功能拆分 |
| **单函数上限** | 50 行 | 超出 → 提取子函数 |
| **单组件职责** | 一个组件 = 一个职责 | 多职责 → 拆分 |
| **接口/实现分离** | DTO/Interface 独立文件 | 混写 → 拆分 |

### 9.2 复用检查 (新建文件前必做)

新建前：① grep 搜索相似功能是否已有实现；② 检查 `shared/utils` `common/` 是否有可复用工具函数。
找到 → 导入使用，不重新实现；确无 → 通用逻辑放 `shared/`，不放模块私有目录。

### 9.3 复用追溯 (修改共享代码时)

与 §6 跨文件影响分析相同流程 → `→ §6`。**特别注意**: 工具函数返回值类型/参数顺序变更编译器可能不报错（any/unknown），但运行时崩。

---

## 10. 反死循环与终端安全执行 (🔴 强制)

### 10.1 认知死循环防护

| 规则 | 标准 | 违反后果 |
|------|------|----------|
| 同策略重试上限 | 同一“策略指纹”(方法+目标+关键参数) 最多尝试 **2 次** | 第 3 次禁止，必须换思路 |
| 连续失败熔断 | 连续失败 **3 次** 或 **10 分钟**无净进展 | 触发 `LOOP_BREAK` |
| 止损预算 | 每子任务最大 6 次尝试 / 25 分钟 | 超预算必须上报阻塞 |

`LOOP_BREAK` 最小输出：
1. 已证伪方案列表  
2. 最小可复现  
3. 三个新路径（含风险）  
4. 下一步选择理由

### 10.2 终端执行防卡死

**写任何 terminal 命令前，必须先做预检（防范于未然）：**
1. 这个命令是否有范围边界？（路径/文件类型/limit）
2. 这个命令是否有超时边界？（total + idle）
3. 这个命令是否会重复已失败策略？（同策略 ≤2 次）
4. 这个命令是否可并行或可降级为更小范围？

> 任一项不满足：禁止直接执行，先改命令再运行。

| 规则 | 标准 |
|------|------|
| 默认超时 | 短命令 30-90s；重命令 300-900s（需显式） |
| 无输出看门狗 | 30-60s 无输出视为疑似卡死，终止并降级策略 |
| 无界命令禁止 | `rg/find` 必须限制范围；日志必须 `head/tail/limit` |
| 同命令重试 | 同参数失败 2 次后，必须改参数/改工具/改路径 |

### 10.3 执行入口

- 推荐统一包装器：`core/scripts/safe-exec.sh`
- 所有高风险命令优先用包装器执行，确保 timeout 与输出边界生效。

### 10.4 Hooks 执行拦截（新增）

- PreToolUse：执行前必须过 `core/scripts/hook-pretool.sh`
- PostToolUse：关键写操作后执行 `core/scripts/hook-posttool.sh`
- Stop：任务收尾执行 `core/scripts/hook-stop.sh`
- 任一 Hook 失败：不得宣称任务完成

---

## 11. 重构保真门禁（🔴 强制）

### 11.1 基本原则
- 重构 = 架构转换；业务语义、功能行为、边界副作用必须保持一致。
- 禁止猜测/臆测/杜撰；未确认项一律标记 `UNKNOWN` 并回源验证。

### 11.2 重构前置条件
1. 像素级审计原实现（入口/分支/异常/状态变化/隐式约束）
2. 形成等价性矩阵（旧实现 vs 新实现）
3. 形成执行计划并切片（每片可独立验证）

### 11.3 执行与验证
- 每片改动后立即执行增量验证（Build/Type/Lint/Test）
- 完成后执行等价性验证：输入、输出、副作用、错误语义
- 必做跨文件消费者追溯，防止隐式破坏

### 11.4 收尾规则
- 任务级计划文件在迁移结束后删除
- 保留审计结论与来源证据
- 归档分账本：错误进 ERROR-BOOK；可复用需求进 PROJECT-MEMORY

### 11.5 标准清单
- `core/reference/refactor-fidelity-checklist.md`

---

## 12. 问题复盘铁律（🔴 强制 — 每次错误修复后必做）

> **真相源**: 所有工作流（build/guard/ship）中的「问题复盘铁律」均指向本节。

1. **记录** → `.agent/projects/{project}/data/errors/ERROR-BOOK.md`
   - 格式见 `memory.md §3.2`：错误标题 / 触发条件 / 根因 / 修复方案 / 关键词索引
2. **交叉检查** → 抽象错误模式 → grep 同类代码 → 逐一核查 → 批量修复
   - 流程见 `memory.md §3.5`
3. **确认** → 零同类残留

> 不执行复盘 = 不完整修复 = 驳回。

---

*Version: 2.1.0 | Updated: 2026-02-19*
