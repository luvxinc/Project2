---
name: collaboration
description: 跨团队协作 SOP — 工程师之间的交接标准/依赖管理/讨论协议/冲突升级。
---

# 跨团队协作 (Cross-Team Collaboration)

> **每个工程师是专家, 但项目不会只有一个人。这个 SOP 定义他们怎么协作。**

---

## 1. 协作原则

| 原则 | 说明 |
|------|------|
| **接口先行** | 协作双方先约定接口 (DTO/API/Props), 再各自实现 |
| **依赖明确** | 每个任务的前置依赖必须写清楚 |
| **交接记录** | 每次交接都有记录 (什么时候, 给谁, 给了什么) |
| **问题上报** | 协作遇到冲突, 30 分钟解决不了 → 上报总工 |

---

## 2. 常见协作场景

### 2.1 数据→后端 (Schema 先行)

```
数据架构师                      后端架构师
    │                              │
    │  1. 设计 Schema              │
    │  2. 创建 Migration           │
    │  3. 交付:                    │
    │     - 表结构                  │
    │     - 字段说明                │
    │     - 索引/约束               │
    │─────── 交接 ─────────────────→│
    │                              │  4. 基于 Schema 创建 Entity
    │                              │  5. 创建 Repository
    │                              │  6. 创建 Service + Controller
```

### 2.2 后端→前端 (API 契约先行)

```
后端架构师                      前端架构师
    │                              │
    │  1. 设计 DTO                 │
    │  2. 实现 Controller          │
    │  3. 交付:                    │
    │     - API 路径               │
    │     - 请求/响应 DTO          │
    │     - 错误码                  │
    │─────── 交接 ─────────────────→│
    │                              │  4. 创建 API Client
    │                              │  5. 创建 React Query Hooks
    │                              │  6. 创建 UI 组件
```

### 2.3 安全→后端 (约束先行)

```
安全架构师                      后端架构师
    │                              │
    │  1. 定义权限矩阵             │
    │  2. 定义安全等级             │
    │  3. 交付:                    │
    │     - 哪些 API 需要什么权限    │
    │     - 审计日志要求            │
    │─────── 交接 ─────────────────→│
    │                              │  4. 添加 @PreAuthorize
    │                              │  5. 添加审计日志
```

---

## 3. 交接协议

### 3.1 交接记录格式

```markdown
## 🔄 交接记录

从: {交出方 Skill}
到: {接收方 Skill}
时间: {YYYY-MM-DD HH:MM}

### 交付物
- {文件/API/Schema/文档}

### 接口约定
- {DTO 结构 / API 路径 / 表结构}

### 注意事项
- {陷阱/约束/特殊要求}
```

### 3.2 交接验证

接收方收到交付物后, 必须:
```
[ ] 确认交付物完整
[ ] 确认接口约定清晰
[ ] 确认能基于交付物开始工作
[ ] 有问题立即反馈 (不要等到最后)
```

---

## 4. 内部讨论协议

### 4.1 何时触发团队讨论

| 场景 | 触发 |
|------|------|
| 架构决策 (多个可行方案) | 列出方案 → 分析优缺 → 选最优 |
| 技术分歧 (工程师意见不同) | 各自陈述 → 总工裁决 |
| 风险发现 (实现中发现新风险) | 评估影响 → 报告总工 |
| 需求疑问 (工程语言有歧义) | 收集问题 → 总工反馈 PM |

### 4.2 讨论格式

```markdown
## 💬 技术讨论: {主题}

### 背景
{为什么需要讨论}

### 方案
| 方案 | 优点 | 缺点 | 工作量 |
|------|------|------|--------|
| A    | ...  | ...  | S/M/L  |
| B    | ...  | ...  | S/M/L  |

### 决策
选择方案 {X}
理由: ...
决策人: 总工
```

---

## 5. 依赖管理

### 5.1 依赖类型

| 类型 | 说明 | 处理 |
|------|------|------|
| **硬依赖** | A 必须在 B 之前完成 | 严格排序 |
| **软依赖** | A 的接口约定后 B 可以并行 | 约定接口 → 并行 |
| **无依赖** | A 和 B 完全独立 | 并行执行 |

### 5.2 依赖可视化

```
Schema [数据] ──→ Entity [后端] ──→ API [后端] ──→ 前端页面 [前端]
                                         │
                              安全注解 [安全] ──→ 审计 [QA]
```

---

## 6. 冲突升级

```
工程师之间有分歧
    ↓
自行讨论 (≤ 5 分钟)
    ↓
解决 → 继续   未解决 → 上报总工
                         ↓
              总工介入协调
                         ↓
              总工做最终技术决策
                         ↓
              涉及需求变更 → 总工通知 PM → PM 与用户确认
```

---

## 7. 变更传播协议 (🔴 新增 — 解决协作遗漏根源)

> **核心原则: 任何修改都有下游影响。没有影响分析 = 不完整的交付。**

### 7.1 变更影响矩阵

当以下文件被修改时, **必须**通知对应工程师:

| 变更源 | 必须同步的下游 | 具体同步内容 |
|--------|----------------|---------------|
| DB Schema (Migration) | 后端 Entity | 字段名/类型/约束 |
| 后端 Entity | 后端 DTO + Mapper | 字段映射 |
| 后端 DTO | 前端 TypeScript Types | 类型定义 |
| 后端 Controller | 前端 API Client | URL + 请求/响应结构 |
| 前端 API Client | 前端组件 | Props/调用方式 |
| API 路径修改 | 前端 + 后端 + Nginx | URL 同步 |
| 权限矩阵修改 | 后端 Security + 前端 Guard | 权限码 |
| i18n Key 修改 | 所有语言文件 | 翻译同步 |
| 删除文件 | 所有 import 该文件的位置 | 删除引用 |
| 模块包名修改 | 所有 import 该模块的位置 | 路径更新 |

### 7.2 工程师完成后传播检查 (每个工程师必做)

```
完成编码后, 在交付前必须:

1. 列出本次修改的所有文件:
   git diff --name-only HEAD~1

2. 对照影响矩阵 (§7.1), 检查:
   [ ] 是否有下游影响?
   [ ] 下游已同步? OR 已通知 CTO 安排下游工程师?

3. 在交接记录中明确标注:
   - 如有下游影响: "需要 [XXX 工程师] 同步 [YYY 文件]"
   - 如无影响: "无下游影响"
```

### 7.3 CTO 协调检查点

```
CTO 在收到工程师交付后, 必须:

[ ] 检查影响矩阵 → 所有下游是否已安排同步
[ ] 如果有链式影响 (A→B→C), 确认全链路都安排了
[ ] 在任务分配单中标注: "已安排 X/Y/Z 同步"
[ ] 只有所有下游都完成后, 才标记整体任务为完成
```

### 7.4 链式影响示例

```
Schema 加了新字段
  → Entity 加字段 (数据架构师)
  → DTO 加字段 (后端架构师)
  → TypeScript Type 加字段 (前端架构师)
  → 前端组件显示新字段 (前端架构师)
  → i18n 加新 key (前端架构师)

只做了第 1 步而没做后续 = 不完整 = 驳回
```

---

*Version: 2.0.0 — 强化版 (含变更传播协议 + 影响矩阵)*
*Updated: 2026-02-12*
